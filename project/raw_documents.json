{
    "artifact_data": [
        {
            "id": "38046d0b-c249-427b-9c15-61c256fe7ed4",
            "content": {
                "Title": "ROS/Introduction - ROS Wiki",
                "Subtitle": null,
                "Content": "|  About | Support | Discussion Forum | Index | Service Status | ros @ Robotics Stack Exchange  \n---|---  \n  \n  * ROS\n  * Introduction\n\n#### ROS 2 Documentation\n\nThe ROS Wiki is for ROS 1. Are you using ROS 2 (Humble, Iron, or Rolling)?  \nCheck out the ROS 2 Project Documentation  \nPackage specific documentation can be found on index.ros.org\n\n# Wiki\n\n  * Distributions\n  * ROS/Installation\n  * ROS/Tutorials\n  * RecentChanges\n  * ROS/Introduction\n\n# Page\n\n  * Immutable Page\n  * Comments\n  * Info\n  * Attachments\n  * More Actions: Raw Text Print View Render as Docbook Delete Cache \\------------------------ Check Spelling Like Pages Local Site Map \\------------------------ Rename Page Copy Page Delete Page \\------------------------ My Pages Subscribe User \\------------------------ Remove Spam Revert to this revision Package Pages Sync Pages \\------------------------ CreatePdfDocument Load RawFile Save SlideShow\n\n# User\n\n  * Login\n\n**_Getting Started** : Introduction | Concepts | Higher-Level Concepts | Client Libraries | Technical Overview_\n\nContents\n\n  1. What is ROS?\n  2. Goals\n  3. Operating Systems\n  4. Releases\n  5. Contributing\n  6. Next\n\n## What is ROS?\n\nROS is an open-source, meta-operating system for your robot. It provides the\nservices you would expect from an operating system, including hardware\nabstraction, low-level device control, implementation of commonly-used\nfunctionality, message-passing between processes, and package management. It\nalso provides tools and libraries for obtaining, building, writing, and\nrunning code across multiple computers. ROS is similar in some respects to\n'robot frameworks,' such as Player, YARP, Orocos, CARMEN, Orca, MOOS, and\nMicrosoft Robotics Studio.\n\nThe ROS runtime \"graph\" is a peer-to-peer network of processes (potentially\ndistributed across machines) that are loosely coupled using the ROS\ncommunication infrastructure. ROS implements several different styles of\ncommunication, including synchronous RPC-style communication over services,\nasynchronous streaming of data over topics, and storage of data on a Parameter\nServer. These are explained in greater detail in our Conceptual Overview.\n\nROS is not a realtime framework, though it is possible to integrate ROS with\nrealtime code. The Willow Garage PR2 robot uses a system called pr2_etherCAT,\nwhich transports ROS messages in and out of a realtime process. ROS also has\nseamless integration with the Orocos Real-time Toolkit.\n\n## Goals\n\nA lot of people ask, \"How is ROS different from X?\" where X is another\nrobotics software platform. It's a difficult question to answer as the goal of\nROS is _not_ to be a framework with the most features. Instead, the primary\ngoal of ROS is to support code _reuse_ in robotics research and development.\nROS is a distributed framework of processes (aka _Nodes_) that enables\nexecutables to be individually designed and loosely coupled at runtime. These\nprocesses can be grouped into _Packages_ and _Stacks_ , which can be easily\nshared and distributed. ROS also supports a federated system of code\n_Repositories_ that enable collaboration to be distributed as well. This\ndesign, from the filesystem level to the community level, enables independent\ndecisions about development and implementation, but all can be brought\ntogether with ROS infrastructure tools.\n\nIn support of this primary goal of sharing and collaboration, there are\nseveral other goals of the ROS framework:\n\n  * Thin: ROS is designed to be as thin as possible -- we won't wrap your main() -- so that code written for ROS can be used with other robot software frameworks. A corollary to this is that ROS is easy to integrate with other robot software frameworks: ROS has already been integrated with OpenRAVE, Orocos, and Player. \n  * ROS-agnostic libraries: the preferred development model is to write ROS-agnostic libraries with clean functional interfaces. \n  * Language independence: the ROS framework is easy to implement in any modern programming language. We have already implemented it in Python, C++, and Lisp, and we have experimental libraries in Java and Lua. \n  * Easy testing: ROS has a builtin unit/integration test framework called rostest that makes it easy to bring up and tear down test fixtures. \n  * Scaling: ROS is appropriate for large runtime systems and for large development processes. \n\nSo, \"How is ROS different from X?\" It's hard to answer for every X, but first,\nif you choose to use X, we hope that you can still use many of the libraries\ndistributed with ROS. As for more specifics, this e-mail by Brian Gerkey (of\nboth Player and ROS) to the ros-users mailing list regarding the differences\nbetween ROS and Player, including OpenCV integration, provides some\ncomparisons:\n\n    \n    \n    The answer, as usual, depends.  In particular, it depends on what you're trying to do.  Player is a great fit for simple, non-articulated mobile platforms.  It was designed to provide easy access to sensors and motors on laser-equipped Pioneers.\n    \n    ROS, on the other hand, is designed around complex mobile manipulation platforms, with actuated sensing (tilting lasers, pan/tilt sensor heads, sensors attached to arms).  As compared to Player, ROS makes it easier to take advantage of a distributed computing environment, and I would say that the higher-level side of things is more developed in ROS than in Player.  Whereas Player offers more hardware drivers, ROS offers more implementations of algorithms.\n    \n    I think that's it's fair to say that ROS is more powerful and flexible than Player, but, as usual, greater power and flexibility come at the cost of greater complexity.  While we're working hard to make ROS easy to use, there is still a significant learning curve.  Of course, familiarly with Player should help in learning to use ROS, as many of the underlying concepts are similar.\n    \n    As to your specific question regarding OpenCV integration, I think that you'll find quite a bit more ROS code than Player code that uses OpenCV in interesting ways.   In the future, you should expect to see even more, as there's significant overlap between the ROS and OpenCV development teams.\n    \n    I should note that ROS leverages a lot of code from the Player project.  There are ROS nodes that reuse code from many Player drivers, and both Stage and Gazebo are well-supported and widely used in the ROS community.\n\n## Operating Systems\n\nROS currently only runs on Unix-based platforms. Software for ROS is primarily\ntested on Ubuntu and Mac OS X systems, though the ROS community has been\ncontributing support for Fedora, Gentoo, Arch Linux and other Linux platforms.\n\nWhile a port to Microsoft Windows for ROS is possible, it has not yet been\nfully explored.\n\n## Releases\n\nThe core ROS system, along with useful tools and libraries are regularly\nreleased as a ROS Distribution. This distribution is similar to a Linux\ndistribution and provides a set of compatible software for others to use and\nbuild upon.\n\n## Contributing\n\nAs ROS is open source, we hope that you will consider contributing to ROS or\nlibraries that are compatible with ROS. Please see our section on Contributing\nfor more information on how you can participate in the ROS community.\n\n## Next\n\nROS Concepts\n\nWiki: ROS/Introduction (last edited 2018-08-08 17:41:46 by AmandaDattalo)\n\nExcept where otherwise noted, the ROS wiki is licensed under the  \nCreative Commons Attribution 3.0\n\n* * *\n\n",
                "language": "No language found."
            },
            "platform": "wiki.ros.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://wiki.ros.org/ROS/Introduction"
        },
        {
            "id": "19863d30-8699-48a2-bdbf-75db95709380",
            "content": {
                "Title": "ROS/Installation - ROS Wiki",
                "Subtitle": null,
                "Content": "|  About | Support | Discussion Forum | Index | Service Status | ros @ Robotics Stack Exchange  \n---|---  \n  \n  * ROS\n  * Installation\n\n#### ROS 2 Documentation\n\nThe ROS Wiki is for ROS 1. Are you using ROS 2 (Humble, Iron, or Rolling)?  \nCheck out the ROS 2 Project Documentation  \nPackage specific documentation can be found on index.ros.org\n\n# Wiki\n\n  * Distributions\n  * ROS/Installation\n  * ROS/Tutorials\n  * RecentChanges\n\n# Page\n\n  * Immutable Page\n  * Comments\n  * Info\n  * Attachments\n  * More Actions: Raw Text Print View Render as Docbook Delete Cache \\------------------------ Check Spelling Like Pages Local Site Map \\------------------------ Rename Page Copy Page Delete Page \\------------------------ My Pages Subscribe User \\------------------------ Remove Spam Revert to this revision Package Pages Sync Pages \\------------------------ CreatePdfDocument Load RawFile Save SlideShow\n\n# User\n\n  * Login\n\nAvailable Translations: German | Spanish | French | Italian | Japanese | Korean | Brazilian Portuguese | Portuguese | \u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian) | Thai | Turkish | \u7b80\u4f53\u4e2d\u6587 | Ukrainian | Vietnamese | \u0627\u0644\u0639\u0631\u0628\u064a\u0629\n\n## See Also:\n\n  1. **ROS/Installation** (this page) \n  2. **Distributions**\n  3. **Installation**\n\n# ROS Installation Options\n\nSee the Distributions page for more details on past ROS versions. We recommend\nthe currently supported version below:\n\nROS Noetic Ninjemys  \nReleased May, 2020  \n**Latest LTS** , supported until May, 2025  \n_Recommended for Ubuntu 20.04_  \n  \n---  \n  \n# ROS 2 Installation\n\nIf you're looking for ROS 2 installation pages please see docs.ros.org\n\nThere are instructions for Humble, Iron, and Rolling.\n\nWiki: ROS/Installation (last edited 2023-06-27 13:35:58 by ChrisLalancette)\n\nExcept where otherwise noted, the ROS wiki is licensed under the  \nCreative Commons Attribution 3.0\n\n* * *\n\n",
                "language": "No language found."
            },
            "platform": "wiki.ros.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://wiki.ros.org/ROS/Installation"
        },
        {
            "id": "6de6392a-fea4-43a5-bc04-1fdb92e7ea01",
            "content": {
                "Title": "ROS/StartGuide - ROS Wiki",
                "Subtitle": null,
                "Content": "|  About | Support | Discussion Forum | Index | Service Status | ros @ Robotics Stack Exchange  \n---|---  \n  \n  * ROS\n  * StartGuide\n\n#### ROS 2 Documentation\n\nThe ROS Wiki is for ROS 1. Are you using ROS 2 (Humble, Iron, or Rolling)?  \nCheck out the ROS 2 Project Documentation  \nPackage specific documentation can be found on index.ros.org\n\n# Wiki\n\n  * Distributions\n  * ROS/Installation\n  * ROS/Tutorials\n  * RecentChanges\n  * ROS/StartGuide\n\n# Page\n\n  * Immutable Page\n  * Comments\n  * Info\n  * Attachments\n  * More Actions: Raw Text Print View Render as Docbook Delete Cache \\------------------------ Check Spelling Like Pages Local Site Map \\------------------------ Rename Page Copy Page Delete Page \\------------------------ My Pages Subscribe User \\------------------------ Remove Spam Revert to this revision Package Pages Sync Pages \\------------------------ CreatePdfDocument Load RawFile Save SlideShow\n\n# User\n\n  * Login\n\n**_Getting Started** : Introduction | Concepts | Higher-Level Concepts | Client Libraries | Technical Overview_\n\nContents\n\n  1. Getting Started/Learning ROS\n  2. Finding Answers\n  3. Finding Code\n  4. How to use this wiki\n\n# Getting Started/Learning ROS\n\nDepending on your learning style and preferences, you can take two approaches\nto learning ROS:\n\n  * Start the Tutorials \\- Dive in right away and start working with ROS. \n  * Get an Overview \\- Read through this written overview of ROS and its capabilities. \n\nTo get an immediate start with a pre-prepared ROS virtual machine, please see\nhere: http://www.clearpathrobotics.com/blog/how-to-guide-ros-101/\n\nFor more detailed information on the ROS framework, see the core ROS\ndocumentation.\n\n# Finding Answers\n\nThere are three places to look for answers to your questions and problems. The\nfirst is this wiki. Try the **Search** feature located at the top right.\n\nIf you can't find a solution to your problem, then try searching Robotics\nStack Exchange or the archived mailing list. Ask a question on Robotics Stack\nExchange.\n\nCheck out the Support page for more information.\n\n# Finding Code\n\nROS Source code is on Github: **https://github.com/ros**. Issues can also be\nopened there.\n\nWondering if there is already a ROS package out there that does what you need?\nThe Browse Software tool also lets search for useful packages. You can also\nbrowse the list of public ROS repositories to look for groups doing similar\nwork.\n\n# How to use this wiki\n\nSee navigating the wiki tutorial for more information.\n\nWiki: ROS/StartGuide (last edited 2023-08-07 22:15:07 by KatherineScott)\n\nExcept where otherwise noted, the ROS wiki is licensed under the  \nCreative Commons Attribution 3.0\n\n* * *\n\n",
                "language": "No language found."
            },
            "platform": "wiki.ros.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://wiki.ros.org/ROS/StartGuide"
        },
        {
            "id": "18fa16b6-17ff-4524-a230-d1c2dde21791",
            "content": {
                "Title": "ROS/Tutorials - ROS Wiki",
                "Subtitle": null,
                "Content": "|  About | Support | Discussion Forum | Index | Service Status | ros @ Robotics Stack Exchange  \n---|---  \n  \n  * ROS\n  * Tutorials\n\n#### ROS 2 Documentation\n\nThe ROS Wiki is for ROS 1. Are you using ROS 2 (Humble, Iron, or Rolling)?  \nCheck out the ROS 2 Project Documentation  \nPackage specific documentation can be found on index.ros.org\n\n# Wiki\n\n  * Distributions\n  * ROS/Installation\n  * ROS/Tutorials\n  * RecentChanges\n\n# Page\n\n  * Immutable Page\n  * Comments\n  * Info\n  * Attachments\n  * More Actions: Raw Text Print View Render as Docbook Delete Cache \\------------------------ Check Spelling Like Pages Local Site Map \\------------------------ Rename Page Copy Page Delete Page \\------------------------ My Pages Subscribe User \\------------------------ Remove Spam Revert to this revision Package Pages Sync Pages \\------------------------ CreatePdfDocument Load RawFile Save SlideShow\n\n# User\n\n  * Login\n\n# ROS Tutorials\n\n**Non-Beginners** : If you're already familiar enough with `ROS` fuerte or\nearlier versions and only want to explore the new build system introduced in\ngroovy and used in hydro and later, called catkin, you can go through more in-\ndepth catkin tutorial here. However, going over all basic Beginner Level\ntutorials is still recommended for all users to get exposed to new features.\n\n**If you are new to Linux** : You may find it helpful to first do a quick\ntutorial on common command line tools for linux. A good one is here.\n\nContents\n\n  1. ROS Tutorials\n    1. Core ROS Tutorials\n      1. Beginner Level\n      2. Intermediate Level\n    2. ROS Standards\n    3. Tutorials for Other ROS Libraries\n    4. Tutorials for Libraries with ROS Interfaces\n    5. External ROS Resources\n      1. External Tutorials\n      2. External Seminar/Lecture\n      3. External Book\n    6. Using ROS on your custom Robot\n\n## Core ROS Tutorials\n\n### Beginner Level\n\n  1. Installing and Configuring Your ROS Environment\n\nThis tutorial walks you through installing ROS and setting up the ROS\nenvironment on your computer.\n\n  2. Navigating the ROS Filesystem\n\nThis tutorial introduces ROS filesystem concepts, and covers using the roscd,\nrosls, and rospack commandline tools.\n\n  3. Creating a ROS Package\n\nThis tutorial covers using roscreate-pkg or catkin to create a new package,\nand rospack to list package dependencies.\n\n  4. Building a ROS Package\n\nThis tutorial covers the toolchain to build a package.\n\n  5. Understanding ROS Nodes\n\nThis tutorial introduces ROS graph concepts and discusses the use of roscore,\nrosnode, and rosrun commandline tools.\n\n  6. Understanding ROS Topics\n\nThis tutorial introduces ROS topics as well as using the rostopic and rqt_plot\ncommandline tools.\n\n  7. Understanding ROS Services and Parameters\n\nThis tutorial introduces ROS services, and parameters as well as using the\nrosservice and rosparam commandline tools.\n\n  8. Using rqt_console and roslaunch\n\nThis tutorial introduces ROS using rqt_console and rqt_logger_level for\ndebugging and roslaunch for starting many nodes at once. If you use `ROS\nfuerte` or ealier distros where rqt isn't fully available, please see this\npage with this page that uses old `rx` based tools.\n\n  9. Using rosed to edit files in ROS\n\nThis tutorial shows how to use rosed to make editing easier.\n\n  10. Creating a ROS msg and srv\n\nThis tutorial covers how to create and build msg and srv files as well as the\nrosmsg, rossrv and roscp commandline tools.\n\n  11. Writing a Simple Publisher and Subscriber (C++)\n\nThis tutorial covers how to write a publisher and subscriber node in C++.\n\n  12. Writing a Simple Publisher and Subscriber (Python)\n\nThis tutorial covers how to write a publisher and subscriber node in python.\n\n  13. Examining the Simple Publisher and Subscriber\n\nThis tutorial examines running the simple publisher and subscriber.\n\n  14. Writing a Simple Service and Client (C++)\n\nThis tutorial covers how to write a service and client node in C++.\n\n  15. Writing a Simple Service and Client (Python)\n\nThis tutorial covers how to write a service and client node in python.\n\n  16. Examining the Simple Service and Client\n\nThis tutorial examines running the simple service and client.\n\n  17. Recording and playing back data\n\nThis tutorial will teach you how to record data from a running ROS system into\na .bag file, and then to play back the data to produce similar behavior in a\nrunning system\n\n  18. Reading messages from a bag file\n\nLearn two ways to read messages from desired topics in a bag file, including\nusing the `ros_readbagfile` script.\n\n  19. Getting started with roswtf\n\nBasic introduction to the roswtf tool.\n\n  20. Navigating the ROS wiki\n\nThis tutorial discusses the layout of the ROS wiki (wiki.ros.org) and talks\nabout how to find what you want to know.\n\n  21. Where Next?\n\nThis tutorial discusses options for getting to know more about using ROS on\nreal or simulated robots.\n\n### Intermediate Level\n\nMore client API tutorials can be found in the relevant package (roscpp, rospy,\nroslisp)\n\n  1. Creating a ROS package by hand.\n\nThis tutorial explains how to manually create a ROS package.\n\n  2. Managing System dependencies\n\nThis explains how to use rosdep to install system dependencies.\n\n  3. Roslaunch tips for large projects\n\nThis tutorial describes some tips for writing roslaunch files for large\nprojects. The focus is on how to structure launch files so they may be reused\nas much as possible in different situations. We'll use the 2dnav_pr2 package\nas a case study.\n\n  4. Running ROS across multiple machines\n\nThis tutorial explains how to start a ROS system using two machines. It\nexplains the use of `ROS_MASTER_URI` to configure multiple machines to use a\nsingle master.\n\n  5. Defining Custom Messages\n\nThis tutorial will show you how to define your own custom message data types\nusing the ROS Message Description Language.\n\n  6. Using a C++ class in Python\n\nThis tutorial illustrates a way to use a C++ class with ROS messages in\nPython.\n\n  7. Packaging your ROS project as a snap\n\nThis tutorial covers how to package and deploy your ROS project as a snap.\n\n  8. How to Write a Tutorial\n\nThis tutorial covers useful template and macros for writing tutorials, along\nwith example tutorials that are available for guidance on ros.org\n\n## ROS Standards\n\n  * ROS Developers Guide Guidelines for coding style, package layout and much more \n  * Standard Units of Measure and Coordinate Conventions\n\n## Tutorials for Other ROS Libraries\n\n  * Robot Model\n  * Visualization\n  * actionlib\n  * Drivers/Tutorials\n  * Pluginlib\n  * Nodelets\n  * Navigation\n  * ROS-Industrial Tutorials\n  * Dynamixel Tutorials\n\n## Tutorials for Libraries with ROS Interfaces\n\n  * Stage\n  * TF\n  * PCL with ROS\n\n## External ROS Resources\n\n### External Tutorials\n\n  * Udemy Course (~16.5 hours): Muhammed O\u011fuz TA\u015e - Temelden Geli\u015fmi\u015fe Python ile Uygulamal\u0131 ROS E\u011fitimi (Turkish) \n  * ROS Tutorials for Beginners: Robomechtrix (Free) \n  * ROS Tutorials for Beginners: Milan Yadav (Paid/English) \n  * New Course on Udemy, \"ROS Tutorials\" (English) \n  * S\u0131f\u0131rdan Uygulamal\u0131 ROS E\u011fitimi, Ali \u00d6ZCAN, Udemy (Turkish Language)\n  * RobotsForRobots Tutorials and ROS Explained Videos\n  * Temel ROS E\u011fitimi (Turkish Language)\n  * ROS - Urdf ve Xacro ile Robot Modelleme (Turkish Language)\n  * Uygulamalar ile ROS E\u011fitimi (Turkish Language)\n  * Course on Udemy: Anis Koubaa, \"ROS for Beginners: Localization, Navigation, and SLAM\" (NEW) \n  * Course on Udemy: Anis Koubaa, \"ROS2 How To: Discover Next Generation ROS\", the first online course on ROS2 \n  * Course on Udemy: Anis Koubaa, \"ROS for Beginners: Basics, Motion, and OpenCV\" Highest Rated \n  * ROS Online Courses Library\n  * ROS Weekly LIVE-Class\n  * Udemy Course on ROS: Video tutorials on learning to program robots from scratch\n  * Online ROS Tutorials:Learn ROS by programming online simulated robots\n  * ROS Q&A Videos Tutorials\n  * ROS Tutorial Video Demos at ANU\n  * NooTriX Step-by-Step ROS Tutorials\n  * Clearpath Robotics' knowledge base\n  * Erle Robotics - Learning ROS\n  * ROS-Industrial Training Class Curriculum\n  * Jonathan Bohren's ROS Tutorials\n  * An Introduction to Robot Operating System (ROS)\n  * Programming Robots Using ROS: An introduction (Arabic Language) \n  * Learn ROS using a URDF simulation model from basics through SLAM - by Husarion\n  * Learn and Develop for Robots using ROS (Persian Language) \n  * ROS Tutorial for Beginners, a YouTube playlist (Arabic Language) \n  * How to Install ROS Melodic in Ubuntu\n  * ROS2 on IBM Cloud Kubernetes\n\n### External Seminar/Lecture\n\n  * Short course on ROS programming 2020 by Institute for Systems and Robotics - Lisbon of T\u00e9cnico\n  * ROS Meetup by The Construct\n  * Free introductory seminar for enterprises by TORK in Tokyo \n\n### External Book\n\n  * e-book: Muhammed O\u011fuz TA\u015e - Yeni Ba\u015flayanlar \u0130\u00e7in Uygulamalarla Robot \u0130\u015fletim Sistemi(ROS) (Turkish) \n\n## Using ROS on your custom Robot\n\n  * Create your own URDF file Creating a custom Universal Robot Description Format file \n  * ros_control Use ROS's standard controller framework for interfacing with hardware. \n  * Using a URDF in Gazebo Add the necessary tags to get your robot in the Gazebo robotic simulator \n  * Setting up MoveIt! Creating the configuration package to use the MoveIt! Motion Planning Framework \n  * Running ROS accross multiple REMOTE machines For outdoor mobile robots applications \n  * Bringing ROS to real life: Barista The first robot serving coffee to the tables in the world \n  * Pilz robot manipulator PRBT Model your application and control a pilz light weight manipulator module PRBT6 \n\nWiki: ROS/Tutorials (last edited 2022-11-02 18:40:34 by TullyFoote)\n\nExcept where otherwise noted, the ROS wiki is licensed under the  \nCreative Commons Attribution 3.0\n\n* * *\n\n",
                "language": "No language found."
            },
            "platform": "wiki.ros.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://wiki.ros.org/ROS/Tutorials"
        },
        {
            "id": "e60d4742-7c4d-4e02-9d77-20c546ef6f2c",
            "content": {
                "Title": "Get Involved - ROS Wiki",
                "Subtitle": null,
                "Content": "|  About | Support | Discussion Forum | Index | Service Status | ros @ Robotics Stack Exchange  \n---|---  \n  \n  * Get Involved\n\n#### ROS 2 Documentation\n\nThe ROS Wiki is for ROS 1. Are you using ROS 2 (Humble, Iron, or Rolling)?  \nCheck out the ROS 2 Project Documentation  \nPackage specific documentation can be found on index.ros.org\n\n# Wiki\n\n  * Distributions\n  * ROS/Installation\n  * ROS/Tutorials\n  * RecentChanges\n  * Get Involved\n\n# Page\n\n  * Immutable Page\n  * Comments\n  * Info\n  * Attachments\n  * More Actions: Raw Text Print View Render as Docbook Delete Cache \\------------------------ Check Spelling Like Pages Local Site Map \\------------------------ Rename Page Copy Page Delete Page \\------------------------ My Pages Subscribe User \\------------------------ Remove Spam Revert to this revision Package Pages Sync Pages \\------------------------ CreatePdfDocument Load RawFile Save SlideShow\n\n# User\n\n  * Login\n\nContents\n\n  1. Editing the ROS Wiki\n  2. Connect with the Community\n    1. ROS Discourse\n    2. ROS Answers\n    3. Robotics Stack Exchange\n    4. Special Interest Groups\n    5. ROSCon\n  3. Development and Best Practices\n  4. Latest Distribution Releases\n  5. ROS Enhancement Proposals (REPs)\n  6. Repositories\n    1. GitHub\n    2. GitHub Organizations\n    3. Historical Hosting Sites\n  7. Create Your Own ROS package Repository\n  8. Release Binary Packages\n  9. Participating in Software Reviews\n\n## Editing the ROS Wiki\n\nSee **EditingTheWiki**.\n\n## Connect with the Community\n\n### ROS Discourse\n\ndiscourse.ros.org is the community's discussion forum. It is not for specific\ntechnical questions, but rather bigger picture topics, announcements and news.\n\n**Please do not post questions on the discourse.ros.org!**\n\nThey should go to Robotics Stack Exchange. As of August 11th, 2023 ROS Answers\nhas been deprecated in favor of Robotics Stack Exchange.\n\n**Deprecated ros-users mailing list**\n\nFor the time being posts from Discourse are being forwarded to the previously\nused ros-users@lists.ros.org mailing list to smooth the transition. For\nexisting subscribers it is recommended to create an account on Discourse,\ncustomize your notifications, and unsubscribe from ros-users. Direct postings\nto ros-users will be disabled. For further details refer to the Discourse\nannouncement.\n\n### ROS Answers\n\nROS Answers was the original ROS Question and Answers website. As of August\n11th, 2023 ROS Answers is deprecated. ROS Answers content is now mirrored at\nRobotics Stack Exchange and is still available as a read-only website. ROS\nusers should use Robotics Stack Exchange as a replacement for ROS Answers.\n\n### Robotics Stack Exchange\n\nAs of August 11th, 2023, Robotics Stack Exchange is the official question and\nanswer website for the ROS community. We recommend ROS users use Robotics\nStack Exchange as their primary mechanism for getting support.\n\n### Special Interest Groups\n\nSpecial Interest Groups - or SIGs - focus on specific subtopics, and help\nguide development efforts.\n\nSIG mailing lists have been deprecated in favor of Discourse categories.\nPlease read http://discourse.ros.org/t/ros-sig-migration-method/35\n\nRefer to the SIG summary page for links to old SIGs and their mailing lists.\n\n### ROSCon\n\nROSCon is the annual ROS developers conference. It is a great opportunity to\nmeet others in the community in real life. And even if you cannot attend we\nrecord the presentations. Visit roscon.ros.org to find out about upcoming\nevents and browse the archives of all the past events.\n\n## Development and Best Practices\n\n  * For a more robot-integration standpoint, see ROS Use Patterns and Best Practices. \n  * For developing ROS libraries and core components see the ROS Developer's Guide. \n  * For maintaining and releasing ROS libraries and core components see the ROS Maintenance Guide. \n  * An older ROS Best Practices still exists here \n  * For usability see Usability Resources. \n  * For ROS-specific test driven development, a tutorial is available (contributed by V\u00edctor Gonz\u00e1lez). \n\n## Latest Distribution Releases\n\nOn the Distributions page, you will see a list of current and future ROS\ndistribution pages. Planning notes for upcoming distributions will be on the\nrelevant wiki page, e.g. Hydro Planning.\n\n## ROS Enhancement Proposals (REPs)\n\nThe REP process, closely modeled on Python's PEP process, allows the community\nto participate in the ongoing development of ROS. For more information, see\nthe REPs page.\n\n## Repositories\n\nTo maximize community participation, we follow a federated repository model:\nrather than having one true place for all ROS packages, users and developers\naround the world can host their own repositories of ROS packages. You can\nsetup your own public repository or use free hosting online.\n\n### GitHub\n\nThe ROS community has standardized repository location by suggesting that\neveryone use GitHub. The Open Source Robotics Foundation has switched to use\nGitHub as the primary hosting site. The ease of collaboration using the GitHub\necosystem has proven very effective. See Recommended Repository Usage.\n\n### GitHub Organizations\n\nThere are several GitHub organizations which host many of the core ROS\npackages. This is the primary location for submitting Issues/bugs,\ncontributing patches and discussing issues directly with the developers. You\nare encouraged to fork projects and send pull requests as needed.\n\nSee ROS GitHub Organizations\n\n### Historical Hosting Sites\n\nCore ROS packages and Willow Garage development work has historically been\nhosted at the following locations but they are no longer active:\n\n  * SourceForge. \n  * code.ros.org \n  * kforge.ros.org \n\nIf you find references to these hosting sites, you'll want to look for newer\nreferences to where they have migrated to.\n\n## Create Your Own ROS package Repository\n\nThere are hundreds of ROS repositories hosted by companies, universities, and\nindividuals around the world. Whether you're releasing one ROS package or\nhundreds, feel free to start your own repository to share your code with the\nrest of the community.\n\nOnce you created your own public repository, add that to ROS package index for\nautomatically generating document. Doing so will automatically populate the\ninformation of your package on `ros.org` so that it can get better visibility\namong the community. It also enables ros.org to add your packages into the\npackage list, which is utilized in various service it provides (e.g. package\nsearch).\n\n## Release Binary Packages\n\nTo release binary packages we use the bloom tool. Here is the list of\ntutorials for releasing software onto the ROS buildfarm for binary packaging.\n\n  * Submitting a package for indexing\n    * This is not specifically bloom related but is a related task to the first time release. Making the release below will prompt to add the package source to the index too. \n  * Releasing a package for the first time\n    * Start with this tutorial if the packages you want to release have not been released previously. \n  * Releasing a new version of a catkin package\n    * Start with this tutorial if the packages you want to release have been released before. \n  * Releasing a third party package\n  * Releasing for a new ROS distro\n  * Running a pre-release test\n  * Changing the default build flags for a package\n\nIf you have two factor authorization enabled on github, and you want bloom to\nbe able to manually create pull requests for you:\n\n  * Manually authorizing bloom to create rosdistro PRs on github\n\nSome helpful information to maintain a ROS package which are not directly\nrelated to bloom:\n\n  * Register a GitHub repository for pull request testing\n\nHere are some unofficial notes and tutorials which can provided additional\nhelp if you are having trouble releasing:\n\n  * Full guide for releasing with catkin (by GaelEcorchard) \n\n## Participating in Software Reviews\n\nDesign and peer review documentation for ROS packages are available online. On\nall package pages, e.g. actionlib, there is a link to 'Reviews' that will show\nyou a list of any API or documentation reviews that have occurred. These\nreview notes generally contain design goals and motivation as well.\n\nThe general process for a review is (this may be out of date: we generally use\nGitHub now):\n\n  * Maintainer puts together documentation for review (e.g. documenting APIs, design notes) \n  * Maintainer creates a new review page for the review that links to the relevant documentation \n  * A week before the review meeting, an e-mail is sent to `ros-users`\n  * Comments are collected in the review page \n  * Meeting is held where comments are reviewed. If necessary, review process is repeated until approval is reached. \n\nWhile meetings have generally been held in person, it is possible to have open\nmeetings (e.g. GitHub) if people express interest on the mailing list.\n\nWiki: Get Involved (last edited 2023-08-07 22:23:00 by KatherineScott)\n\nExcept where otherwise noted, the ROS wiki is licensed under the  \nCreative Commons Attribution 3.0\n\n* * *\n\n",
                "language": "No language found."
            },
            "platform": "wiki.ros.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://wiki.ros.org/Get%20Involved"
        },
        {
            "id": "dcf57309-5bbc-4c51-b30d-29a0efd5df6e",
            "content": {
                "Title": "Support - ROS Wiki",
                "Subtitle": null,
                "Content": "|  About | Support | Discussion Forum | Index | Service Status | ros @ Robotics Stack Exchange  \n---|---  \n  \n  * Support\n\n#### ROS 2 Documentation\n\nThe ROS Wiki is for ROS 1. Are you using ROS 2 (Humble, Iron, or Rolling)?  \nCheck out the ROS 2 Project Documentation  \nPackage specific documentation can be found on index.ros.org\n\n# Wiki\n\n  * Distributions\n  * ROS/Installation\n  * ROS/Tutorials\n  * RecentChanges\n  * Support\n\n# Page\n\n  * Immutable Page\n  * Comments\n  * Info\n  * Attachments\n  * More Actions: Raw Text Print View Render as Docbook Delete Cache \\------------------------ Check Spelling Like Pages Local Site Map \\------------------------ Rename Page Copy Page Delete Page \\------------------------ My Pages Subscribe User \\------------------------ Remove Spam Revert to this revision Package Pages Sync Pages \\------------------------ CreatePdfDocument Load RawFile Save SlideShow\n\n# User\n\n  * Login\n\nContents\n\n  1. ROS Discourse\n  2. When something fails\n  3. Suggestions for reporting issues/requesting features\n  4. Guidelines for asking a question (Please read before posting)\n    1. Do Not\n    2. Do\n    3. Etiquette\n  5. Guidelines for Moderating\n    1. Spam in general\n    2. ROS Answers\n\nRobotics Stack Exchange should be used as the first step in requesting help.\nROS Answers is available as read only resource, as it was officially\ndeprecated as of August 11th, 2023.\n\n## ROS Discourse\n\nTo stay on top of the latest ROS news, join http://discourse.ros.org and\nsubscribe to at least the general topic. Feel free to have a look at the\nhistorical posts.\n\nFor older posts please checkout the ros-users archive.\n\n**Please do not post questions on discourse.ros.org. Questions should be\nposted toRobotics Stack Exchange.**\n\nROS Discourse is for news and general interest discussions. Robotics Stack\nExchange provides a forum which can be filtered by tags to make sure the\nrelevant people can find and/or answer the question, and not overload everyone\nwith hundreds of posts.\n\n## When something fails\n\nIf you are attempting to debug a ROS system\n\n  1. First try to troubleshoot using: \n     * Troubleshooting\n     * FAQ\n  2. If the troubleshooting guide fails to help, search for an answer, and ask a question if you don't find anything related on \n     * Robotics Stack Exchange\n  3. If you find an issue or wish to make a feature request, please see the next section \n\n## Suggestions for reporting issues/requesting features\n\n  1. First, **check** the issue trackers: Known issues, often with patches or workarounds, are generally found there. If you have something to add to an existing issue, add it as a comment to the issue, rather than posting to the mailing lists. \n  2. Next, check Robotics Stack Exchange to see if someone else has asked your question or reported your issue. And try a general search you may also find results from ROS Discourse the ros-users mailing list archive and other sites. \n  3. If all the above steps failed, the best thing to do file a ticket. \n\nIf you're not sure what you found is a bug you can ask on Robotics Stack\nExchange. If the problem is confirmed as a bug, please then open a ticket.\nTickets are preferred if you are posting about a bug because they will be\nreviewed by the developers.\n\nWhen you open a ticket the best way to demonstrate it is with a Short, Self\nContained, Correct (Compilable) Example: http://sscce.org/ or a Minimal,\nComplete, and Verifiable example https://stackoverflow.com/help/mcve\n\n## Guidelines for asking a question (Please read before posting)\n\n### Do Not\n\n  * The following are **not** appropriate questions: \n    * general debugging/programming questions not specific to ROS \n    * questions about software that is not ROS related \n    * your homework \n  * Don't contact the developers/maintainers directly. \n    * The community can't see question or answer(s) not asked/answered publicly. \n    * Open Source development works best when the entire community participates in discussions and helps to answer questions. \n    * It's better to send all questions to Robotics Stack Exchange or the appropriate mailing list, and report all issues to the issue tracker. \n  * On Robotics Stack Exchange, do not use answers for discussion, subsequent questions or just updates. Instead, **edit** your original post or use the comment functionality. \n\n### Do\n\n  * Be as specific as possible, with steps to reproduce. \n    * Describe exactly what you were doing or are trying to do, and exactly what, if anything, went wrong. If you say, _\"rviz doesn't work,\"_ we can't help you. \n      * If following a Tutorial or online instructions provide a link to the specific instructions. \n      * Use a descriptive headline or subject line. **Bad:** _\"rviz doesn't work\"_. **Good:** _\"Rviz crashing looking for missing .so after latest apt update\"_\n    * Always provide the following information: \n      * **Names and versions of stacks/packages** that you're using. _\"I'm using ROS C Turtle with pr2_simulator 1.1.1 and vocabulary_tree r30294\"_\n      * **Your platform** (architecture, OS & version/distro). _\"I'm running OS X 10.5 on an iBook,\"_ or _\"I'm running Ubuntu Karmic on an x86, with kernel 2.6.31.\"_ For Linux, always provide the distro and kernel versions. \n      * **Any warnings or errors**. Cut and paste them _directly_ from the terminal window to which they were printed. \n        * **Please** _**DO NOT_** **re-type them yourself**. Small typing mistakes can make a large difference and time wasted. \n        * **Please** _**DO NOT_** **post a screenshot of the terminal or source file**. Instead, cut/copy and paste whenever you can. Text in the screenshot images is not searchable (e.g. by any web browsers, by Google etc.) \n    * When discussing any compiling/linking/installation issues, also provide: \n      * gcc version \n  * As appropriate, also include your: \n    * ROS environment variables (`env | grep ROS`) \n    * Backtraces \n    * Relevant config files \n    * Graphics card model and driver version \n    * Ogre.log for rviz, if possible (run with `rviz -l`) \n    * Bag files and code samples that can reproduce the problem \n    * Screenshots or movies to demonstrate the problem \n  * Always tag your questions appropriately. You must tag at least the rosdistro version. \n  * Format code snippets. To make your code snippets and error messages better readable, format them correctly (mark the code and press Ctrl-k). \n  * You are most likely to get a good answer if you provide a Short, Self Contained, Correct (Compilable) Example http://sscce.org/ or a Minimal, Complete, and Verifiable example https://stackoverflow.com/help/mcve\n\n### Etiquette\n\n  * **Assume 'good faith**': It's easy to mis-interpret the meaning or tone of comments on the internet. Assuming good faith gives the benefit of the doubt to those trying to help you, avoiding: insulting well meaning community members, and poisoning the mood. Assuming 'good faith' when responding almost always works better _even if the original response was not in fact in good faith_. \n  * **Please don't send your question more than once** : The question was seen. If you didn't get a response then likely nobody has had time to answer you. Alternatively, it could be that nobody knows the answer. In any case, sending it again is poor form and akin to shouting and is likely to aggravate a large number of people. This also applies to crossposting. Try to pick the forum which you think matches best and ask there. If you are referred to a new forum, provide a link to the old discussion. \n    * On Robotics Stack Exchange you can edit your question to provide more details. The more details that you include in your question the easier it is for others to help you find your solution which makes it more likely for you to get a response. \n  * **It's considered bad form to list your personal deadlines; Community members answering questions also have them.**\n  * **Do not beg for help.** If there is someone willing and able to help with your problem, you usually get a response. Asking for faster answers will mostly have a negative effect. \n  * **Do not add unrelated content to posts.** The content of posts should be focused on the topic at hand and not include unrelated content. Content, links, and images unrelated to the topic are considered spam. \n    * For commercial posts, see also this discussion. \n  * **Minimize references to content behind pay walls.** The content posted on the wiki and in Ask should \"generally\" be free and open to all users. Links to content behind pay walls such as private journal articles, text books, and paid news websites, while helpful and relevant, may not be accessible to all users. Where possible primary sources should be free and open with paid content playing a supporting role. \n  * **Single link posts are to be avoided.** Generally speaking, posting a single link answer is less helpful and can be easily confused with spam. Moreover, links may degrade over time or be replaced. Paraphrasing a link's content along with some contextual information and attribution is often much more helpful. \n\n## Guidelines for Moderating\n\nIt is the responsibility of the community to maintain the community ethos. We\nuse several public forums to communicate about our work: mailing lists, issue\ntrackers and ROS Answers. If you see behavior in any of these forums that does\nnot meet our community standards, please promptly respond following the\nguidelines below, always remaining courteous and polite.\n\n### Spam in general\n\n  * Delete spam immediately. If the account has been created just for spamming, block the account as well. \n\n### ROS Answers\n\n  * If a duplicate question is asked, comment on the new question to say that questions should not be duplicated, then delete the less detailed of the two. \n  * If an inappropriate (e.g., rude or offensive) question or answer is given, quickly reword it if possible, including a comment with the reason for the edit. If it cannot be reworded easily, leave a comment as to why the question was deleted and delete it, suggesting that the submitter resubmit following the guidelines. \n\nWiki: Support (last edited 2023-09-06 20:16:43 by TullyFoote)\n\nExcept where otherwise noted, the ROS wiki is licensed under the  \nCreative Commons Attribution 3.0\n\n* * *\n\n",
                "language": "No language found."
            },
            "platform": "wiki.ros.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://wiki.ros.org/Support"
        },
        {
            "id": "6848e665-cbe6-4a7f-9dfb-e5bf2a4b74e0",
            "content": {
                "Title": "Quality - ROS Wiki",
                "Subtitle": null,
                "Content": "|  About | Support | Discussion Forum | Index | Service Status | ros @ Robotics Stack Exchange  \n---|---  \n  \n  * Quality\n\n#### ROS 2 Documentation\n\nThe ROS Wiki is for ROS 1. Are you using ROS 2 (Humble, Iron, or Rolling)?  \nCheck out the ROS 2 Project Documentation  \nPackage specific documentation can be found on index.ros.org\n\n# Wiki\n\n  * Distributions\n  * ROS/Installation\n  * ROS/Tutorials\n  * RecentChanges\n  * Quality\n\n# Page\n\n  * Immutable Page\n  * Comments\n  * Info\n  * Attachments\n  * More Actions: Raw Text Print View Render as Docbook Delete Cache \\------------------------ Check Spelling Like Pages Local Site Map \\------------------------ Rename Page Copy Page Delete Page \\------------------------ My Pages Subscribe User \\------------------------ Remove Spam Revert to this revision Package Pages Sync Pages \\------------------------ CreatePdfDocument Load RawFile Save SlideShow\n\n# User\n\n  * Login\n\n# ROS Software Quality Hub\n\nThe Quality Hub is an online community hub that will provide a focal point and\nresources to foster quality related activity in ROS. Please help to grow it in\nthe interest of the entire community.\n\nThis page is a central entry point for all quality assurance material for ROS.\nThis includes tutorials and patterns on producing and contributing high\nquality code, as well as on testing, and other quality oriented practices. The\nparticular focus are industrial users of ROS, but everybody is welcomed to\nbenefit and to contribute.\n\nPlease create new quality oriented materials under this tree in the wiki.\n\nContents\n\n  1. ROS Software Quality Hub\n    1. Tutorials and articles\n    2. Quality category on ROS Discourse\n    3. Who is behind ROS Quality Hub? (About Us)\n\n## Tutorials and articles\n\nSee Quality/Tutorials for tutorials & articles on quality assurance with ROS\nand for ROS.\n\n## Quality category on ROS Discourse\n\nThere is a dedicated software quality category on ROS Discourse:\ndiscourse.ros.org/Quality.\n\nGo there to discuss issues of quality policies in the ROS projects, and in\nROS-based applications, including proposals of content for this webpage,\noffers to help, etc.\n\n## Who is behind ROS Quality Hub? (About Us)\n\nSo who is behind this page? The answer is simple: **It's you!** We need your\nhelp to create a solid resource on building high quality industrial level\nsystems with ROS. We are a group of self-appointed editors who are generously\nfunded by the European Union H2020 project ROSIN.\n\nWe are trying to spin this effort with a good speed and trajectory, but it\nwill die, if you don't join us. Talk to us on the discourse category for\nQuality (see above), or just grab an article devoted to Quality that needs\nimprovement and work on it! You can take the article from anywhere in the\nwiki, and link it from here, as a sign that it has been edited. If you think\nan article on a topic is missing, create a new one, or ask others to do so in\na discourse discussion.\n\n  1. No Title\n\nNo Description\n\n**Create a new tutorial:**\n\nWiki: Quality (last edited 2018-03-23 18:23:00 by AndrzejWasowski)\n\nExcept where otherwise noted, the ROS wiki is licensed under the  \nCreative Commons Attribution 3.0\n\n* * *\n\n",
                "language": "No language found."
            },
            "platform": "wiki.ros.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://wiki.ros.org/Quality"
        },
        {
            "id": "845fac49-d8b7-4ebf-bfc1-ec0e71926b02",
            "content": {
                "Title": "Distributions - ROS Wiki",
                "Subtitle": null,
                "Content": "|  About | Support | Discussion Forum | Index | Service Status | ros @ Robotics Stack Exchange  \n---|---  \n  \n  * Distributions\n\n#### ROS 2 Documentation\n\nThe ROS Wiki is for ROS 1. Are you using ROS 2 (Humble, Iron, or Rolling)?  \nCheck out the ROS 2 Project Documentation  \nPackage specific documentation can be found on index.ros.org\n\n# Wiki\n\n  * Distributions\n  * ROS/Installation\n  * ROS/Tutorials\n  * RecentChanges\n\n# Page\n\n  * Immutable Page\n  * Comments\n  * Info\n  * Attachments\n  * More Actions: Raw Text Print View Render as Docbook Delete Cache \\------------------------ Check Spelling Like Pages Local Site Map \\------------------------ Rename Page Copy Page Delete Page \\------------------------ My Pages Subscribe User \\------------------------ Remove Spam Revert to this revision Package Pages Sync Pages \\------------------------ CreatePdfDocument Load RawFile Save SlideShow\n\n# User\n\n  * Login\n\nContents\n\n  1. See Also:\n  2. What is a Distribution?\n  3. List of Distributions\n  4. Distribution Details\n  5. Release Schedule\n  6. Upcoming releases\n  7. Which distribution to use\n\n## See Also:\n\n  1. **ROS/Installation**\n  2. **Distributions** (this page) \n  3. **Installation**\n\n## What is a Distribution?\n\nA ROS distribution is a versioned set of ROS packages. These are akin to Linux\ndistributions (e.g. Ubuntu). The purpose of the ROS distributions is to let\ndevelopers work against a relatively stable codebase until they are ready to\nroll everything forward. Therefore once a distribution is released, we try to\nlimit changes to bug fixes and non-breaking improvements for the core packages\n(every thing under `ros-desktop-full`). And generally that applies to the\nwhole community, but for \"higher\" level packages, the rules are less strict,\nand so it falls to the maintainers of a given package to avoid breaking\nchanges.\n\nWe capture the components that make up a distribution in our rosdistro format\nand it allows for multiple distributions. There are many different types of\nrobots with different needs, and we anticipate that parts of the community may\nput together their own distributions in the future to better target these\nplatforms.\n\n## List of Distributions\n\n**Distro** | **Release date** | **Poster** | **_Tuturtle_ , turtle in tutorial** | **EOL date**  \n---|---|---|---|---  \nROS Noetic Ninjemys  \n(**Recommended**) | May 23rd, 2020 |  |  | May, 2025  \n(Focal EOL)  \nROS Melodic Morenia | May 23rd, 2018 |  |  | June 27, 2023  \n(Bionic EOL)  \nROS Lunar Loggerhead | May 23rd, 2017 |  |  | May, 2019  \nROS Kinetic Kame | May 23rd, 2016 |  |  | April, 2021  \n(Xenial EOL)  \nROS Jade Turtle | May 23rd, 2015 |  |  | May, 2017  \nROS Indigo Igloo | July 22nd, 2014 |  |  | April, 2019  \n(Trusty EOL)  \nROS Hydro Medusa | September 4th, 2013 |  |  | May, 2015  \nROS Groovy Galapagos | December 31, 2012 |  |  | July, 2014  \nROS Fuerte Turtle | April 23, 2012 |  |  | \\--  \nROS Electric Emys | August 30, 2011  |  |  | \\--  \nROS Diamondback | March 2, 2011 |  |  | \\--  \nROS C Turtle | August 2, 2010 |  |  | \\--  \nROS Box Turtle | March 2, 2010 |  |  | \\--  \n  \n  \n**Legend**\n\n  * light yellow: future release \n  * green: supported release \n  * grey: unsupported release (End of Life) \n\n## Distribution Details\n\nThe details on the distributions and versions of common dependencies and other\nconsiderations, see the official Target Platforms REP:\n\n  * Target Platforms (REP 3)\n\n## Release Schedule\n\nRelease rules\n\n  * ROS release timing is based on need and available resources \n  * All future ROS 1 releases are LTS, supported for five years \n  * ROS releases will drop support for EOL Ubuntu distributions, even if the ROS release is still supported. \n\nSide effects of the release policy:\n\n  * Every ROS release will be supported on exactly one Ubuntu LTS. \n  * LTS releases will not share a common Ubuntu release with any previous releases. \n  * ROS releases will not add support for new Ubuntu distributions after their release date. \n\nThese simplified rules and side effects are subject to change with changes to\nthe underlying Ubuntu release policy.\n\nFor more details see the official Release Policy.\n\n## Upcoming releases\n\nNoeitc Ninjemys is the final release of ROS 1 by Open Robotics. Future ROS\nreleases will all be based on ROS 2, and are listed on docs.ros.org page.\n\n## Which distribution to use\n\nA rather arbitrary list of usecase driven recommendations. _Updated_ on May\n2020.\n\n**New Capability** | **Major Update Frequency** | **Recommended distro**  \n---|---|---  \nPreferred but not required  |  Not preferred  | Previous LTS (Melodic)  \nMuch preferred  |  Acceptable  | Latest (Noetic)  \nMuch preferred  |  Not preferred  | Switch to the latest LTS every 2 year  \n  \nSpecific platform is required | See REP-3 for supported platform  \n---|---  \nNewer Gazebo is needed  |  | Use Noetic for Gazebo 11  \nI want to use OpenCV3 |  | Kinetic, Melodic or Noetic  \nI want to use OpenCV4 |  | Noetic  \n  \nWiki: Distributions (last edited 2024-10-30 23:22:57 by TullyFoote)\n\nExcept where otherwise noted, the ROS wiki is licensed under the  \nCreative Commons Attribution 3.0\n\n* * *\n\n",
                "language": "No language found."
            },
            "platform": "wiki.ros.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://wiki.ros.org/Distributions"
        },
        {
            "id": "12b14416-36d3-475b-95c1-fa914e7f507d",
            "content": {
                "Title": "Getting Started \u2014 Nav2 1.0.0 documentation",
                "Subtitle": null,
                "Content": "Nav2\n\nlatest\n\n  * Getting Started\n    * Installation\n    * Running the Example\n    * Navigating\n  * Development Guides\n    * Build and Install\n      * Install\n        * For Iron and Older\n        * For Jazzy and Newer\n      * Build\n        * Released Distribution Binaries\n        * Rolling Development Source\n        * Docker Container Images\n      * Generate Doxygen\n      * Help\n        * Build Troubleshooting Guide\n    * Dev Containers\n      * Dev Container Guide\n        * Creating Dev Containers\n        * Using Dev Containers\n      * What, Why, How?\n        * What is a Dev Container?\n        * Why use a Dev Container?\n        * How do Dev Containers work?\n      * Prerequisites\n      * Getting started\n      * Security\n    * Getting Involved\n      * Getting Involved\n      * Process\n      * Licensing\n      * Developer Certification of Origin (DCO)\n  * Navigation Concepts\n    * ROS 2\n      * Action Server\n      * Lifecycle Nodes and Bond\n    * Behavior Trees\n    * Navigation Servers\n      * Planner, Controller, Smoother and Recovery Servers\n      * Planners\n      * Controllers\n      * Behaviors\n      * Smoothers\n      * Robot Footprints\n      * Waypoint Following\n    * State Estimation\n      * Standards\n      * Global Positioning: Localization and SLAM\n      * Odometry\n    * Environmental Representation\n      * Costmaps and Layers\n      * Costmap Filters\n      * Other Forms\n    * Nav2 Academic Overview\n  * First-Time Robot Setup Guide\n    * Setting Up Transformations\n      * Transforms Introduction\n      * Static Transform Publisher Demo\n      * Transforms in Navigation2\n      * Conclusion\n    * Setting Up The URDF\n      * URDF and the Robot State Publisher\n      * Setting Up the Environment\n      * Writing the URDF\n      * Build and Launch\n      * Visualization using RVIZ\n      * Adding Physical Properties\n      * Conclusion\n    * Setting Up Odometry\n      * Odometry Introduction\n      * Setting Up Odometry on your Robot\n      * Simulating an Odometry System using Gazebo\n        * Setup and Prerequisites\n        * Adding Gazebo Plugins to a URDF\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Robot Localization Demo\n        * Configuring Robot Localization\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Conclusion\n    * Setting Up Sensors\n      * Sensor Introduction\n        * Common Sensor Messages\n      * Simulating Sensors using Gazebo\n        * Adding Gazebo Plugins to a URDF\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Mapping and Localization\n      * Costmap 2D\n        * Configuring nav2_costmap_2d\n        * Build, Run and Verification\n      * Conclusion\n    * Setting Up the Robot\u2019s Footprint\n      * Footprint Introduction\n      * Configuring the Robot\u2019s Footprint\n      * Build, Run and Verification\n      * Visualizing Footprint in RViz\n      * Conclusion\n    * Setting Up Navigation Plugins\n      * Planner and Controller Servers\n      * Selecting the Algorithm Plugins\n        * Planner Server\n        * Controller Server\n      * Conclusion\n  * Robots Using\n  * General Tutorials\n    * Navigating with a Physical Turtlebot 3\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Setup Your Environment Variables\n        * 1- Launch Turtlebot 3\n        * 2- Launch Nav2\n        * 3- Launch RVIZ\n        * 4- Initialize the Location of Turtlebot 3\n        * 5- Send a Goal Pose\n    * (SLAM) Navigating While Mapping\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Launch Robot Interfaces\n        * 1- Launch Navigation2\n        * 2- Launch SLAM\n        * 3- Working with SLAM\n        * 4- Getting Started Simplification\n    * (STVL) Using an External Costmap Plugin\n      * Overview\n      * Costmap2D and STVL\n      * Tutorial Steps\n        * 0- Setup\n        * 1- Install STVL\n        * 1- Modify Navigation2 Parameter\n        * 2- Launch Navigation2\n        * 3- RVIZ\n    * Navigating Using GPS Localization\n      * Overview\n      * Requirements\n      * GPS Localization Overview\n      * Tutorial Steps\n        * 0- Setup Gazebo World\n        * 1- Setup GPS Localization system\n        * 2- Setup Navigation system\n        * 3- Interactive GPS Waypoint Follower\n        * 4- Logged GPS Waypoint Follower & Waypoint Logging\n      * Conclusion\n    * Groot - Interacting with Behavior Trees\n      * Overview\n      * Visualize Behavior Trees\n      * Edit Behavior Trees\n      * Adding A Custom Node\n    * Using VIO to Augment Robot Odometry\n      * Overview\n      * Setting Up the ZED X Camera\n      * Setting Up ZED ROS\n      * Fusing VIO Into Local State Estimate\n        * Fusing VSLAM Into Global State Estimate\n      * Testing it Out!\n    * Dynamic Object Following\n      * Overview\n      * Tutorial Steps\n        * 0- Create the Behavior Tree\n        * 1- Setup Rviz clicked point\n        * 2- Run Dynamic Object Following in Nav2 Simulation\n    * Navigating with Keepout Zones\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Prepare filter mask\n        * 2\\. Configure Costmap Filter Info Publisher Server\n        * 3\\. Enable Keepout Filter\n        * 4\\. Run Nav2 stack\n    * Navigating with Speed Limits\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Prepare filter mask\n        * 2\\. Configure Costmap Filter Info Publisher Server\n        * 3\\. Enable Speed Filter\n        * 4\\. Run Nav2 stack\n    * Using Docking Server\n      * Overview\n      * Requirements\n      * ChargingDock Plugins\n      * Dock Database\n      * Configuring Docking Server\n      * Adding Docking Server to Launch\n      * Docking Action API\n      * Putting It All Together\n    * Using Rotation Shim Controller\n      * Overview\n      * What is the Rotation Shim Controller?\n      * Configuring Rotation Shim Controller\n      * Configuring Primary Controller\n      * Demo Execution\n    * Adding a Smoother to a BT\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Familiarization with the Smoother BT Node\n        * 1- Specifying a Smoother Plugin\n        * 2- Modifying your BT XML\n    * Using Collision Monitor\n      * Overview\n      * Requirements\n      * Configuring Collision Monitor\n      * Configuring Collision Monitor with VelocityPolygon\n      * Preparing Nav2 stack\n      * Demo Execution\n    * Adding a New Nav2 Task Server\n      * Lifecycle Nodes\n      * Composition\n      * Error codes\n      * Conclusion\n    * Filtering of Noise-Induced Obstacles\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Enable Denoise Layer\n        * 2\\. Run Nav2 stack\n      * How it works\n    * Camera Calibration\n      * Overview\n      * Requirements\n      * Tutorial Steps\n    * Get Backtrace in ROS 2 / Nav2\n      * Overview\n      * Preliminaries\n      * From a Node\n      * From a Launch File\n      * From Large Project\n      * From Nav2 Bringup\n      * Automatic backtrace on crash\n    * Profiling in ROS 2 / Nav2\n      * Overview\n      * Preliminaries\n      * Profile from a Node\n      * Profile from a Launch File\n      * From Nav2 Bringup\n      * Interpreting Results\n    * Docker for Development: Zero to Hero\n      * Overview\n      * Preliminaries\n      * Important Docker Commands\n      * Exploring Your First Container\n      * Understanding ROS Docker Images\n      * For Docker-Based Development\n        * Building a Development Image\n        * Visualizations from Docker\n      * For Docker-Based Deployment\n      * Conclusion\n      * Appendix\n        * Nav2 Development Image\n        * Nav2 Deployment Image\n  * Plugin Tutorials\n    * Writing a New Costmap2D Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Write a new Costmap2D plugin\n        * 2- Export and make GradientLayer plugin\n        * 3- Enable the plugin in Costmap2D\n        * 4- Run GradientLayer plugin\n    * Writing a New Planner Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new Planner Plugin\n        * 2- Exporting the planner plugin\n        * 3- Pass the plugin name through params file\n        * 4- Run StraightLine plugin\n    * Writing a New Controller Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Create a new Controller Plugin\n        * 2- Exporting the controller plugin\n        * 3- Pass the plugin name through the params file\n        * 4- Run Pure Pursuit Controller plugin\n    * Writing a New Behavior Tree Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new BT Plugin\n        * 2- Exporting the planner plugin\n        * 3- Add plugin library name to config\n        * 4- Run Your Custom plugin\n    * Writing a New Behavior Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new Behavior Plugin\n        * 2- Exporting the Behavior Plugin\n        * 3- Pass the plugin name through params file\n        * 4- Run Behavior Plugin\n    * Writing a New Navigator Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Create a new Navigator Plugin\n        * 2- Exporting the navigator plugin\n        * 3- Pass the plugin name through the params file\n        * 4- Run plugin\n  * Configuration Guide\n    * Behavior-Tree Navigator\n      * Parameters\n      * Example\n    * Behavior Tree XML Nodes\n      * Action Plugins\n        * Wait\n        * Spin\n        * BackUp\n        * DriveOnHeading\n        * AssistedTeleop\n        * ComputePathToPose\n        * FollowPath\n        * NavigateToPose\n        * ClearEntireCostmap\n        * ClearCostmapExceptRegion\n        * ClearCostmapAroundRobot\n        * ReinitializeGlobalLocalization\n        * TruncatePath\n        * TruncatePathLocal\n        * PlannerSelector\n        * ControllerSelector\n        * SmootherSelector\n        * GoalCheckerSelector\n        * ProgressCheckerSelector\n        * NavigateThroughPoses\n        * ComputePathThroughPoses\n        * ComputeCoveragePath\n        * CancelCoverage\n        * RemovePassedGoals\n        * RemoveInCollisionGoals\n        * CancelControl\n        * CancelBackUp\n        * CancelSpin\n        * CancelWait\n        * CancelDriveOnHeading\n        * CancelAssistedTeleop\n        * SmoothPath\n        * GetPoseFromPath\n        * DockRobot\n        * UndockRobot\n      * Condition Plugins\n        * GoalReached\n        * TransformAvailable\n        * DistanceTraveled\n        * GoalUpdated\n        * GloballyUpdatedGoal\n        * InitialPoseReceived\n        * IsStuck\n        * IsStopped\n        * TimeExpired\n        * IsBatteryLow\n        * IsPathValid\n        * PathExpiringTimer\n        * AreErrorCodesPresent\n        * WouldAControllerRecoveryHelp\n        * WouldAPlannerRecoveryHelp\n        * WouldASmootherRecoveryHelp\n        * IsBatteryCharging\n      * Control Plugins\n        * PipelineSequence\n        * RoundRobin\n        * RecoveryNode\n      * Decorator Plugins\n        * RateController\n        * DistanceController\n        * SpeedController\n        * GoalUpdater\n        * PathLongerOnApproach\n        * SingleTrigger\n      * Example\n    * Costmap 2D\n      * Costmap2D ROS Parameters\n      * Default Plugins\n      * Plugin Parameters\n        * Static Layer Parameters\n        * Inflation Layer Parameters\n        * Obstacle Layer Parameters\n        * Voxel Layer Parameters\n        * Range Sensor Parameters\n        * Denoise Layer Parameters\n      * Costmap Filters Parameters\n        * Keepout Filter Parameters\n        * Speed Filter Parameters\n        * Binary Filter Parameters\n      * Example\n    * Lifecycle Manager\n      * Parameters\n      * Example\n    * Planner Server\n      * Parameters\n      * Default Plugins\n      * Example\n    * Coverage Server\n      * Parameters\n      * Example\n    * NavFn Planner\n      * Parameters\n      * Example\n    * Smac Planner\n      * Provided Plugins\n        * Smac 2D Planner\n        * Smac Hybrid-A* Planner\n        * Smac State Lattice Planner\n      * Description\n    * Theta Star Planner\n      * Parameters\n      * Example\n    * Controller Server\n      * Parameters\n      * Provided Plugins\n        * SimpleProgressChecker\n        * PoseProgressChecker\n        * SimpleGoalChecker\n        * StoppedGoalChecker\n      * Default Plugins\n      * Example\n    * DWB Controller\n      * Controller\n        * DWB Controller\n        * XYTheta Iterator\n        * Kinematic Parameters\n        * Publisher\n      * Plugins\n        * LimitedAccelGenerator\n        * StandardTrajectoryGenerator\n      * Trajectory Critics\n        * BaseObstacleCritic\n        * GoalAlignCritic\n        * GoalDistCritic\n        * ObstacleFootprintCritic\n        * OscillationCritic\n        * PathAlignCritic\n        * PathDistCritic\n        * PreferForwardCritic\n        * RotateToGoalCritic\n        * TwirlingCritic\n      * Example\n    * Regulated Pure Pursuit\n      * Regulated Pure Pursuit Parameters\n      * Example\n    * Model Predictive Path Integral Controller\n      * MPPI Parameters\n        * Trajectory Visualization\n        * Path Handler\n        * Ackermann Motion Model\n        * Constraint Critic\n        * Goal Angle Critic\n        * Goal Critic\n        * Obstacles Critic\n        * Cost Critic\n        * Path Align Critic\n        * Path Angle Critic\n        * Path Follow Critic\n        * Prefer Forward Critic\n        * Twirling Critic\n        * Velocity Deadband Critic\n      * Example\n      * Notes to Users\n        * General Words of Wisdom\n        * Prediction Horizon, Costmap Sizing, and Offsets\n        * Obstacle, Inflation Layer, and Path Following\n    * Rotation Shim Controller\n      * Rotation Shim Controller Parameters\n      * Example\n    * Graceful Controller\n      * Graceful Controller Parameters\n      * Example\n    * Map Server / Saver\n      * Map Saver Parameters\n      * Map Server Parameters\n      * Costmap Filter Info Server Parameters\n      * Example\n    * AMCL\n      * Parameters\n      * Example\n    * Behavior Server\n      * Behavior Server Parameters\n      * Default Plugins\n      * Spin Behavior Parameters\n      * BackUp Behavior Parameters\n      * DriveOnHeading Behavior Parameters\n      * AssistedTeleop Behavior Parameters\n      * Example\n    * Smoother Server\n      * Smoother Server Parameters\n      * Example\n    * Simple Smoother\n      * Simple Smoother Parameters\n      * Example\n    * Savitzky-Golay Smoother\n      * Savitzky-Golay Smoother Parameters\n      * Example\n    * Constrained smoother\n      * Smoother Server Parameters\n      * Example\n    * Velocity Smoother\n      * Velocity Smoother Parameters\n      * Example\n    * Collision Monitor\n      * Provided Nodes\n        * Collision Monitor Node\n        * Collision Detector Node\n    * Waypoint Follower\n      * Parameters\n      * Provided Plugins\n        * WaitAtWaypoint\n        * PhotoAtWaypoint\n        * InputAtWaypoint\n      * Default Plugin\n      * Example\n    * Loopback Simulator\n      * Parameters\n      * Example\n    * Docking Server\n      * Parameters\n      * SimpleChargingDock Parameters\n      * Example\n  * Tuning Guide\n    * Inflation Potential Fields\n    * Robot Footprint vs Radius\n    * Rotate in Place Behavior\n    * Planner Plugin Selection\n    * Controller Plugin Selection\n    * Caching Obstacle Heuristic in Smac Planners\n    * Costmap2D Plugins\n    * Nav2 Launch Options\n    * Other Pages We\u2019d Love To Offer\n  * Nav2 Behavior Trees\n    * Introduction To Nav2 Specific Nodes\n      * Action Nodes\n      * Condition Nodes\n      * Decorator Nodes\n      * Control: PipelineSequence\n      * Control: Recovery\n      * Control: RoundRobin\n    * Detailed Behavior Tree Walkthrough\n      * Overview\n      * Prerequisites\n      * Navigate To Pose With Replanning and Recovery\n      * Navigation Subtree\n      * Recovery Subtree\n    * Navigate To Pose\n    * Navigate Through Poses\n    * Navigate To Pose and Pause Near Goal-Obstacle\n    * Navigate To Pose With Consistent Replanning And If Path Becomes Invalid\n    * Follow Dynamic Point\n    * Odometry Calibration\n  * Navigation Plugins\n    * Behavior-Tree Navigators\n    * Costmap Layers\n    * Costmap Filters\n    * Controllers\n    * Planners\n    * Smoothers\n    * Behaviors\n    * Waypoint Task Executors\n    * Goal Checkers\n    * Progress Checkers\n    * Behavior Tree Nodes\n  * Migration Guides\n    * Dashing to Eloquent\n      * New Packages\n      * New Plugins\n      * Navigation2 Architectural Changes\n    * Eloquent to Foxy\n      * General\n      * Server Updates\n      * New Plugins\n      * Map Server Re-Work\n      * New Particle Filter Messages\n      * Selection of Behavior Tree in each navigation action\n      * FollowPoint Capability\n      * New Costmap Layer\n    * Foxy to Galactic\n      * NavigateToPose Action Feedback updates\n      * NavigateToPose BT-node Interface Changes\n      * NavigateThroughPoses and ComputePathThroughPoses Actions Added\n      * ComputePathToPose BT-node Interface Changes\n      * ComputePathToPose Action Interface Changes\n      * BackUp BT-node Interface Changes\n      * BackUp Recovery Interface Changes\n      * Nav2 Controllers and Goal Checker Plugin Interface Changes\n      * FollowPath goal_checker_id attribute\n      * Groot Support\n      * New Plugins\n      * Costmap Filters\n      * SmacPlanner\n      * ThetaStarPlanner\n      * RegulatedPurePursuitController\n      * Costmap2D `current_` Usage\n      * Standard time units in parameters\n      * Ray Tracing Parameters\n      * Obstacle Marking Parameters\n      * Recovery Action Changes\n      * Default Behavior Tree Changes\n      * NavFn Planner Parameters\n      * New ClearCostmapExceptRegion and ClearCostmapAroundRobot BT-nodes\n      * New Behavior Tree Nodes\n      * sensor_msgs/PointCloud to sensor_msgs/PointCloud2 Change\n      * ControllerServer New Parameter failure_tolerance\n      * Removed BT XML Launch Configurations\n      * Nav2 RViz Panel Action Feedback Information\n    * Galactic to Humble\n      * Major improvements to Smac Planners\n      * Simple (Python) Commander\n      * Reduce Nodes and Executors\n      * API Change for nav2_core\n      * Extending the BtServiceNode to process Service-Results\n      * Including new Rotation Shim Controller Plugin\n      * Spawning the robot in Gazebo\n      * Recovery Behavior Timeout\n      * New parameter `use_final_approach_orientation` for the 3 2D planners\n      * SmacPlanner2D and Theta*: fix goal orientation being ignored\n      * SmacPlanner2D, NavFn and Theta*: fix small path corner cases\n      * Change and fix behavior of dynamic parameter change detection\n      * Dynamic Parameters\n      * BT Action Nodes Exception Changes\n      * BT Navigator Groot Multiple Navigators\n      * Removed Kinematic Limiting in RPP\n      * Added Smoother Task Server\n      * Removed Use Approach Velocity Scaling Param in RPP\n      * Refactored AMCL motion models as plugins\n      * Dropping Support for Live Groot Monitoring of Nav2\n      * Replanning Only if Path is Invalid\n      * Fix CostmapLayer clearArea invert param logic\n      * Dynamic Composition\n      * BT Cancel Node\n      * BT PathLongerOnApproach Node\n      * BT TruncatePathLocal Node\n      * Constrained Smoother\n      * Replanning at a Constant Rate and if the Path is Invalid\n      * Euclidean Distance 2D\n      * Recovery To Behavior\n      * Respawn Support in Launch and Lifecycle Manager\n      * New Nav2 Velocity Smoother\n      * Goal Checker API Changed\n      * Added Assisted Teleop\n    * Humble to Iron\n      * New Behavior-Tree Navigator Plugins\n      * Added Collision Monitor\n      * Removed use_sim_time from yaml\n      * Run-time Speed up of Smac Planner\n      * Recursive Refinement of Smac and Simple Smoothers\n      * Simple Commander Python API\n      * Smac Planner Start Pose Included in Path\n      * Parameterizable Collision Checking in RPP\n      * Expanded Planner Benchmark Tests\n      * Smac Planner Path Tolerances\n      * costmap_2d_node default constructor\n      * Feedback for Navigation Failures\n      * Costmap Filters\n      * Savitzky-Golay Smoother\n      * Changes to Map yaml file path for map_server node in Launch\n      * SmootherSelector BT Node\n      * Publish Costmap Layers\n      * Give Behavior Server Access to Both Costmaps\n      * New Model Predictive Path Integral Controller\n      * Behavior Tree Uses Error Codes\n      * Load, Save and Loop Waypoints from the Nav2 Panel in RViz\n      * DWB Forward vs Reverse Pruning\n      * More stable regulation on curves for long lookahead distances\n      * Publish Collision Monitor State\n      * Renamed ROS-parameter in Collision Monitor\n      * New safety behavior model \u201climit\u201d in Collision Monitor\n      * Velocity smoother applies deceleration when timeout\n      * PoseProgressChecker plugin\n      * Allow multiple goal checkers and change parameter progress_checker_plugin(s) name and type\n      * IsBatteryChargingCondition BT Node\n      * Behavior Server Error Codes\n      * New Denoise Costmap Layer Plugin\n      * SmacPlannerHybrid viz_expansions parameter\n    * Iron to Jazzy\n      * BehaviorTree.CPP upgraded to version 4.5+\n      * Added TwistStamped Option for Commands\n      * Add VelocityPolygon in Collision Monitor\n      * Change polygon points parameter format in Collision Monitor\n      * Introduction of Soft-Real Time Action Servers\n      * `opennav_coverage` Project\n      * `opennav_docking` Project\n      * Introduce a new Multi-Robot Bringup Launch\n      * New option for the Voxel and Obstacle Layers\n      * use_interpolation RPP Parameter Depreciated\n      * Changes to MPPI Goal Critic\n      * Changes to MPPI Path Angle Critic\n      * Changes to MPPI Path Handling For Directionality\n      * Addition of new MPPI Cost Critic\n      * MPPI Acceleration\n      * Move Error Code Enumerations\n      * Substitution in parameter file\n      * Allow Behavior Server Plugins to Access The Action Result\n      * Smac Planner Debug Param Name Change\n      * Smac Planner On Approach to Goal Shortcutting Solutions\n      * Added GPS Waypoint Follower Server\n      * Smac Planner Hybrid-A* New Features\n      * New node in nav2_collision_monitor: Collision Detector\n      * Dynamic enabling/disabling of sources/polygons in Collision Monitor/Detector\n      * Expose action server\u2019s result timeout\n      * RewrittenYaml could add new parameters to YAMLs\n      * Simple Commander API Allows Multi-Robot Namespacing\n      * Change duration type in wait_action node\n      * The costmap activation fails when required transforms are not available\n      * Subtrees Obtain Shared Resources\n      * Collision Monitor: added watchdog mechanism based on `source_timeout` parameter with default blocking behavior\n      * BtActionServer: use native library haltTree()\n      * Global Frame Removed from 2 BT Nodes\n      * Introduction of `CostmapUpdate.msg`\n      * Full Stack Uses Node Clocks\n      * New Graceful Motion Controller\n      * Plugin Libraries in BT Navigator Only Includes Custom Nodes\n      * New RViz Plugin for selecting Planners, Controllers, Goal Checkers, Progress Checkers and Smoothers\n      * RPP new optional `interpolate_curvature_after_goal` behavior and fix conflict between `use_rotate_to_heading` and `allow_reversing`\n      * Cancel Checker Interface For GlobalPlanner\n      * New BtActionServer/BtNavigator parameter\n      * New collision monitor parameter\n      * New graceful cancellation API for Controllers\n      * Standardization of Plugin Naming with Double Colons (::)\n      * Collision monitor: dynamic radius for circle type polygons\n      * Static Layer: new parameter `footprint_clearing_enabled`\n      * Lifecycle Node: added bond_heartbeat_period parameter (and allow disabling the bond mechanism)\n      * Rotation Shim Controller: new parameter `rotate_to_goal_heading`\n      * MPPI Controller: Addition of acceleration constraints\n      * RegulatedPurePursuit Controller [RPP]: new parameter `use_cancel_deceleration`\n    * Jazzy to K-Turtle\n      * TwistStamped Default CmdVel Change\n      * New Nav2 Loopback Simulator\n      * Docking with Static Infrastructure or Dynamic Docking\n      * New RViz panel for Docking\n      * New BT Nodes\n      * New RViz Tool for Costmap Cost Cell Inspection\n      * Fix flickering visualization\n      * Option to limit velocity through DWB trajectory\n      * Option to disable zero velocity publishing on goal exit\n      * Added optional collision checking for the Docking Server\n      * Revamped multirobot bringup and config files to use namespaces\n      * Removed global map_topic from Costmap node\n      * Simplified Costmap2DROS constructors\n  * Simple Commander API\n    * Overview\n    * Commander API\n    * Costmap API\n    * Footprint Collision Checker API\n    * Examples and Demos\n  * Roadmaps\n    * Jazzy Roadmap\n    * Iron Roadmap\n    * Humble Roadmap\n  * About and Contact\n    * Related Projects\n    * About\n    * Contact\n\n__Nav2\n\nEdit\n\n  *   * Getting Started\n  * \n\n* * *\n\n# Getting Started\uf0c1\n\nThis document will take you through the process of installing the Nav2\nbinaries and navigating a simulated Turtlebot 3 in the Gazebo simulator.\n\nNote\n\nSee the Build and Install for other situations such as building from source or\nworking with other types of robots.\n\nWarning\n\nThis is a simplified version of the Turtlebot 3 instructions. We highly\nrecommend you follow the official Turtlebot 3 manual if you intend to continue\nworking with this robot beyond the minimal example provided here.\n\n## Installation\uf0c1\n\nJazzy introduced the new Gazebo modern simulator, replacing Gazebo Classic.\nThus, for Jazzy and newer, the installation packages and instructions are\nslightly different to pull in the appropriate packages.\n\n  1. Install the ROS 2 binary packages as described in the official docs\n\n  2. Install the Nav2 packages using your operating system\u2019s package manager:\n    \n        sudo apt install ros-<ros2-distro>-navigation2\n    sudo apt install ros-<ros2-distro>-nav2-bringup\n    \n\n  3. Install the demo robot (Turtlebot) for gazebo:\n\nFor **Jazzy and newer** , install the Turtlebot 3 & 4 packages for Gazebo\nModern. It should be automatically installed with `nav2_bringup`:\n\n>\n>     sudo apt install ros-<ros2-distro>-nav2-minimal-tb*\n>  \n\nFor **Iron and older** , install Turtlebot 3 packages for gazebo classic:\n\n>\n>     sudo apt install ros-<ros2-distro>-turtlebot3-gazebo\n>  \n\n## Running the Example\uf0c1\n\n  1. Start a terminal in your GUI\n\n  2. Set key environment variables, some of which are only required for Iron and older:\n    \n        source /opt/ros/<ros2-distro>/setup.bash\n    export TURTLEBOT3_MODEL=waffle  # Iron and older only with Gazebo Classic\n    export GAZEBO_MODEL_PATH=$GAZEBO_MODEL_PATH:/opt/ros/<ros2-distro>/share/turtlebot3_gazebo/models # Iron and older only with Gazebo Classic\n    \n\n  3. In the same terminal, run:\n    \n        ros2 launch nav2_bringup tb3_simulation_launch.py headless:=False\n    \n\nNote\n\n`headless` defaults to true; if not set to false, gzclient (the 3d view) is\nnot started.\n\nThis launch file will launch Nav2 with the AMCL localizer in the simulation\nworld. It will also launch the robot state publisher to provide transforms, a\nGazebo instance with the Turtlebot3 URDF, and RVIZ.\n\nIf everything has started correctly, you will see the RViz and Gazebo GUIs\nlike this (this is Gazebo Classic, but what you see with modern Gazebo is\nvirtually identical):\n\n  4. If not autostarting, click the \u201cStartup\u201d button in the bottom left corner of RViz. This will cause Nav2 to change to the Active state. It should change appearance to show the map.\n\n## Navigating\uf0c1\n\nAfter starting, the robot initially has no idea where it is. By default, Nav2\nwaits for you to give it an approximate starting position. Take a look at\nwhere the robot is in the Gazebo world, and find that spot on the map. Set the\ninitial pose by clicking the \u201c2D Pose Estimate\u201d button in RViz, and then down\nclicking on the map in that location. You set the orientation by dragging\nforward from the down click.\n\nIf you are using the defaults so far, the robot should look roughly like this.\n\n> If you don\u2019t get the location exactly right, that\u2019s fine. Nav2 will refine\n> the position as it navigates. You can also, click the \u201c2D Pose Estimate\u201d\n> button and try again, if you prefer.\n\nOnce you\u2019ve set the initial pose, the transform tree will be complete and Nav2\nwill be fully active and ready to go. You should see the robot and particle\ncloud now.\n\n> Next, click the \u201cNavigaton2 Goal\u201d button and choose a destination. This will\n> call the BT navigator to go to that goal through an action server. You can\n> pause (cancel) or reset the action through the Nav2 rviz plugin shown.\n\n> Now watch the robot go!\n\n* * *\n\n(C) Copyright 2023.\n\n",
                "language": "en"
            },
            "platform": "docs.nav2.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://docs.nav2.org/getting_started/index.html"
        },
        {
            "id": "1d6e72b2-75ef-46bd-877f-595102097b17",
            "content": {
                "Title": "Getting Started \u2014 Nav2 1.0.0 documentation",
                "Subtitle": null,
                "Content": "Nav2\n\nlatest\n\n  * Getting Started\n    * Installation\n    * Running the Example\n    * Navigating\n  * Development Guides\n    * Build and Install\n      * Install\n        * For Iron and Older\n        * For Jazzy and Newer\n      * Build\n        * Released Distribution Binaries\n        * Rolling Development Source\n        * Docker Container Images\n      * Generate Doxygen\n      * Help\n        * Build Troubleshooting Guide\n    * Dev Containers\n      * Dev Container Guide\n        * Creating Dev Containers\n        * Using Dev Containers\n      * What, Why, How?\n        * What is a Dev Container?\n        * Why use a Dev Container?\n        * How do Dev Containers work?\n      * Prerequisites\n      * Getting started\n      * Security\n    * Getting Involved\n      * Getting Involved\n      * Process\n      * Licensing\n      * Developer Certification of Origin (DCO)\n  * Navigation Concepts\n    * ROS 2\n      * Action Server\n      * Lifecycle Nodes and Bond\n    * Behavior Trees\n    * Navigation Servers\n      * Planner, Controller, Smoother and Recovery Servers\n      * Planners\n      * Controllers\n      * Behaviors\n      * Smoothers\n      * Robot Footprints\n      * Waypoint Following\n    * State Estimation\n      * Standards\n      * Global Positioning: Localization and SLAM\n      * Odometry\n    * Environmental Representation\n      * Costmaps and Layers\n      * Costmap Filters\n      * Other Forms\n    * Nav2 Academic Overview\n  * First-Time Robot Setup Guide\n    * Setting Up Transformations\n      * Transforms Introduction\n      * Static Transform Publisher Demo\n      * Transforms in Navigation2\n      * Conclusion\n    * Setting Up The URDF\n      * URDF and the Robot State Publisher\n      * Setting Up the Environment\n      * Writing the URDF\n      * Build and Launch\n      * Visualization using RVIZ\n      * Adding Physical Properties\n      * Conclusion\n    * Setting Up Odometry\n      * Odometry Introduction\n      * Setting Up Odometry on your Robot\n      * Simulating an Odometry System using Gazebo\n        * Setup and Prerequisites\n        * Adding Gazebo Plugins to a URDF\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Robot Localization Demo\n        * Configuring Robot Localization\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Conclusion\n    * Setting Up Sensors\n      * Sensor Introduction\n        * Common Sensor Messages\n      * Simulating Sensors using Gazebo\n        * Adding Gazebo Plugins to a URDF\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Mapping and Localization\n      * Costmap 2D\n        * Configuring nav2_costmap_2d\n        * Build, Run and Verification\n      * Conclusion\n    * Setting Up the Robot\u2019s Footprint\n      * Footprint Introduction\n      * Configuring the Robot\u2019s Footprint\n      * Build, Run and Verification\n      * Visualizing Footprint in RViz\n      * Conclusion\n    * Setting Up Navigation Plugins\n      * Planner and Controller Servers\n      * Selecting the Algorithm Plugins\n        * Planner Server\n        * Controller Server\n      * Conclusion\n  * Robots Using\n  * General Tutorials\n    * Navigating with a Physical Turtlebot 3\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Setup Your Environment Variables\n        * 1- Launch Turtlebot 3\n        * 2- Launch Nav2\n        * 3- Launch RVIZ\n        * 4- Initialize the Location of Turtlebot 3\n        * 5- Send a Goal Pose\n    * (SLAM) Navigating While Mapping\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Launch Robot Interfaces\n        * 1- Launch Navigation2\n        * 2- Launch SLAM\n        * 3- Working with SLAM\n        * 4- Getting Started Simplification\n    * (STVL) Using an External Costmap Plugin\n      * Overview\n      * Costmap2D and STVL\n      * Tutorial Steps\n        * 0- Setup\n        * 1- Install STVL\n        * 1- Modify Navigation2 Parameter\n        * 2- Launch Navigation2\n        * 3- RVIZ\n    * Navigating Using GPS Localization\n      * Overview\n      * Requirements\n      * GPS Localization Overview\n      * Tutorial Steps\n        * 0- Setup Gazebo World\n        * 1- Setup GPS Localization system\n        * 2- Setup Navigation system\n        * 3- Interactive GPS Waypoint Follower\n        * 4- Logged GPS Waypoint Follower & Waypoint Logging\n      * Conclusion\n    * Groot - Interacting with Behavior Trees\n      * Overview\n      * Visualize Behavior Trees\n      * Edit Behavior Trees\n      * Adding A Custom Node\n    * Using VIO to Augment Robot Odometry\n      * Overview\n      * Setting Up the ZED X Camera\n      * Setting Up ZED ROS\n      * Fusing VIO Into Local State Estimate\n        * Fusing VSLAM Into Global State Estimate\n      * Testing it Out!\n    * Dynamic Object Following\n      * Overview\n      * Tutorial Steps\n        * 0- Create the Behavior Tree\n        * 1- Setup Rviz clicked point\n        * 2- Run Dynamic Object Following in Nav2 Simulation\n    * Navigating with Keepout Zones\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Prepare filter mask\n        * 2\\. Configure Costmap Filter Info Publisher Server\n        * 3\\. Enable Keepout Filter\n        * 4\\. Run Nav2 stack\n    * Navigating with Speed Limits\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Prepare filter mask\n        * 2\\. Configure Costmap Filter Info Publisher Server\n        * 3\\. Enable Speed Filter\n        * 4\\. Run Nav2 stack\n    * Using Docking Server\n      * Overview\n      * Requirements\n      * ChargingDock Plugins\n      * Dock Database\n      * Configuring Docking Server\n      * Adding Docking Server to Launch\n      * Docking Action API\n      * Putting It All Together\n    * Using Rotation Shim Controller\n      * Overview\n      * What is the Rotation Shim Controller?\n      * Configuring Rotation Shim Controller\n      * Configuring Primary Controller\n      * Demo Execution\n    * Adding a Smoother to a BT\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Familiarization with the Smoother BT Node\n        * 1- Specifying a Smoother Plugin\n        * 2- Modifying your BT XML\n    * Using Collision Monitor\n      * Overview\n      * Requirements\n      * Configuring Collision Monitor\n      * Configuring Collision Monitor with VelocityPolygon\n      * Preparing Nav2 stack\n      * Demo Execution\n    * Adding a New Nav2 Task Server\n      * Lifecycle Nodes\n      * Composition\n      * Error codes\n      * Conclusion\n    * Filtering of Noise-Induced Obstacles\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Enable Denoise Layer\n        * 2\\. Run Nav2 stack\n      * How it works\n    * Camera Calibration\n      * Overview\n      * Requirements\n      * Tutorial Steps\n    * Get Backtrace in ROS 2 / Nav2\n      * Overview\n      * Preliminaries\n      * From a Node\n      * From a Launch File\n      * From Large Project\n      * From Nav2 Bringup\n      * Automatic backtrace on crash\n    * Profiling in ROS 2 / Nav2\n      * Overview\n      * Preliminaries\n      * Profile from a Node\n      * Profile from a Launch File\n      * From Nav2 Bringup\n      * Interpreting Results\n    * Docker for Development: Zero to Hero\n      * Overview\n      * Preliminaries\n      * Important Docker Commands\n      * Exploring Your First Container\n      * Understanding ROS Docker Images\n      * For Docker-Based Development\n        * Building a Development Image\n        * Visualizations from Docker\n      * For Docker-Based Deployment\n      * Conclusion\n      * Appendix\n        * Nav2 Development Image\n        * Nav2 Deployment Image\n  * Plugin Tutorials\n    * Writing a New Costmap2D Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Write a new Costmap2D plugin\n        * 2- Export and make GradientLayer plugin\n        * 3- Enable the plugin in Costmap2D\n        * 4- Run GradientLayer plugin\n    * Writing a New Planner Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new Planner Plugin\n        * 2- Exporting the planner plugin\n        * 3- Pass the plugin name through params file\n        * 4- Run StraightLine plugin\n    * Writing a New Controller Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Create a new Controller Plugin\n        * 2- Exporting the controller plugin\n        * 3- Pass the plugin name through the params file\n        * 4- Run Pure Pursuit Controller plugin\n    * Writing a New Behavior Tree Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new BT Plugin\n        * 2- Exporting the planner plugin\n        * 3- Add plugin library name to config\n        * 4- Run Your Custom plugin\n    * Writing a New Behavior Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new Behavior Plugin\n        * 2- Exporting the Behavior Plugin\n        * 3- Pass the plugin name through params file\n        * 4- Run Behavior Plugin\n    * Writing a New Navigator Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Create a new Navigator Plugin\n        * 2- Exporting the navigator plugin\n        * 3- Pass the plugin name through the params file\n        * 4- Run plugin\n  * Configuration Guide\n    * Behavior-Tree Navigator\n      * Parameters\n      * Example\n    * Behavior Tree XML Nodes\n      * Action Plugins\n        * Wait\n        * Spin\n        * BackUp\n        * DriveOnHeading\n        * AssistedTeleop\n        * ComputePathToPose\n        * FollowPath\n        * NavigateToPose\n        * ClearEntireCostmap\n        * ClearCostmapExceptRegion\n        * ClearCostmapAroundRobot\n        * ReinitializeGlobalLocalization\n        * TruncatePath\n        * TruncatePathLocal\n        * PlannerSelector\n        * ControllerSelector\n        * SmootherSelector\n        * GoalCheckerSelector\n        * ProgressCheckerSelector\n        * NavigateThroughPoses\n        * ComputePathThroughPoses\n        * ComputeCoveragePath\n        * CancelCoverage\n        * RemovePassedGoals\n        * RemoveInCollisionGoals\n        * CancelControl\n        * CancelBackUp\n        * CancelSpin\n        * CancelWait\n        * CancelDriveOnHeading\n        * CancelAssistedTeleop\n        * SmoothPath\n        * GetPoseFromPath\n        * DockRobot\n        * UndockRobot\n      * Condition Plugins\n        * GoalReached\n        * TransformAvailable\n        * DistanceTraveled\n        * GoalUpdated\n        * GloballyUpdatedGoal\n        * InitialPoseReceived\n        * IsStuck\n        * IsStopped\n        * TimeExpired\n        * IsBatteryLow\n        * IsPathValid\n        * PathExpiringTimer\n        * AreErrorCodesPresent\n        * WouldAControllerRecoveryHelp\n        * WouldAPlannerRecoveryHelp\n        * WouldASmootherRecoveryHelp\n        * IsBatteryCharging\n      * Control Plugins\n        * PipelineSequence\n        * RoundRobin\n        * RecoveryNode\n      * Decorator Plugins\n        * RateController\n        * DistanceController\n        * SpeedController\n        * GoalUpdater\n        * PathLongerOnApproach\n        * SingleTrigger\n      * Example\n    * Costmap 2D\n      * Costmap2D ROS Parameters\n      * Default Plugins\n      * Plugin Parameters\n        * Static Layer Parameters\n        * Inflation Layer Parameters\n        * Obstacle Layer Parameters\n        * Voxel Layer Parameters\n        * Range Sensor Parameters\n        * Denoise Layer Parameters\n      * Costmap Filters Parameters\n        * Keepout Filter Parameters\n        * Speed Filter Parameters\n        * Binary Filter Parameters\n      * Example\n    * Lifecycle Manager\n      * Parameters\n      * Example\n    * Planner Server\n      * Parameters\n      * Default Plugins\n      * Example\n    * Coverage Server\n      * Parameters\n      * Example\n    * NavFn Planner\n      * Parameters\n      * Example\n    * Smac Planner\n      * Provided Plugins\n        * Smac 2D Planner\n        * Smac Hybrid-A* Planner\n        * Smac State Lattice Planner\n      * Description\n    * Theta Star Planner\n      * Parameters\n      * Example\n    * Controller Server\n      * Parameters\n      * Provided Plugins\n        * SimpleProgressChecker\n        * PoseProgressChecker\n        * SimpleGoalChecker\n        * StoppedGoalChecker\n      * Default Plugins\n      * Example\n    * DWB Controller\n      * Controller\n        * DWB Controller\n        * XYTheta Iterator\n        * Kinematic Parameters\n        * Publisher\n      * Plugins\n        * LimitedAccelGenerator\n        * StandardTrajectoryGenerator\n      * Trajectory Critics\n        * BaseObstacleCritic\n        * GoalAlignCritic\n        * GoalDistCritic\n        * ObstacleFootprintCritic\n        * OscillationCritic\n        * PathAlignCritic\n        * PathDistCritic\n        * PreferForwardCritic\n        * RotateToGoalCritic\n        * TwirlingCritic\n      * Example\n    * Regulated Pure Pursuit\n      * Regulated Pure Pursuit Parameters\n      * Example\n    * Model Predictive Path Integral Controller\n      * MPPI Parameters\n        * Trajectory Visualization\n        * Path Handler\n        * Ackermann Motion Model\n        * Constraint Critic\n        * Goal Angle Critic\n        * Goal Critic\n        * Obstacles Critic\n        * Cost Critic\n        * Path Align Critic\n        * Path Angle Critic\n        * Path Follow Critic\n        * Prefer Forward Critic\n        * Twirling Critic\n        * Velocity Deadband Critic\n      * Example\n      * Notes to Users\n        * General Words of Wisdom\n        * Prediction Horizon, Costmap Sizing, and Offsets\n        * Obstacle, Inflation Layer, and Path Following\n    * Rotation Shim Controller\n      * Rotation Shim Controller Parameters\n      * Example\n    * Graceful Controller\n      * Graceful Controller Parameters\n      * Example\n    * Map Server / Saver\n      * Map Saver Parameters\n      * Map Server Parameters\n      * Costmap Filter Info Server Parameters\n      * Example\n    * AMCL\n      * Parameters\n      * Example\n    * Behavior Server\n      * Behavior Server Parameters\n      * Default Plugins\n      * Spin Behavior Parameters\n      * BackUp Behavior Parameters\n      * DriveOnHeading Behavior Parameters\n      * AssistedTeleop Behavior Parameters\n      * Example\n    * Smoother Server\n      * Smoother Server Parameters\n      * Example\n    * Simple Smoother\n      * Simple Smoother Parameters\n      * Example\n    * Savitzky-Golay Smoother\n      * Savitzky-Golay Smoother Parameters\n      * Example\n    * Constrained smoother\n      * Smoother Server Parameters\n      * Example\n    * Velocity Smoother\n      * Velocity Smoother Parameters\n      * Example\n    * Collision Monitor\n      * Provided Nodes\n        * Collision Monitor Node\n        * Collision Detector Node\n    * Waypoint Follower\n      * Parameters\n      * Provided Plugins\n        * WaitAtWaypoint\n        * PhotoAtWaypoint\n        * InputAtWaypoint\n      * Default Plugin\n      * Example\n    * Loopback Simulator\n      * Parameters\n      * Example\n    * Docking Server\n      * Parameters\n      * SimpleChargingDock Parameters\n      * Example\n  * Tuning Guide\n    * Inflation Potential Fields\n    * Robot Footprint vs Radius\n    * Rotate in Place Behavior\n    * Planner Plugin Selection\n    * Controller Plugin Selection\n    * Caching Obstacle Heuristic in Smac Planners\n    * Costmap2D Plugins\n    * Nav2 Launch Options\n    * Other Pages We\u2019d Love To Offer\n  * Nav2 Behavior Trees\n    * Introduction To Nav2 Specific Nodes\n      * Action Nodes\n      * Condition Nodes\n      * Decorator Nodes\n      * Control: PipelineSequence\n      * Control: Recovery\n      * Control: RoundRobin\n    * Detailed Behavior Tree Walkthrough\n      * Overview\n      * Prerequisites\n      * Navigate To Pose With Replanning and Recovery\n      * Navigation Subtree\n      * Recovery Subtree\n    * Navigate To Pose\n    * Navigate Through Poses\n    * Navigate To Pose and Pause Near Goal-Obstacle\n    * Navigate To Pose With Consistent Replanning And If Path Becomes Invalid\n    * Follow Dynamic Point\n    * Odometry Calibration\n  * Navigation Plugins\n    * Behavior-Tree Navigators\n    * Costmap Layers\n    * Costmap Filters\n    * Controllers\n    * Planners\n    * Smoothers\n    * Behaviors\n    * Waypoint Task Executors\n    * Goal Checkers\n    * Progress Checkers\n    * Behavior Tree Nodes\n  * Migration Guides\n    * Dashing to Eloquent\n      * New Packages\n      * New Plugins\n      * Navigation2 Architectural Changes\n    * Eloquent to Foxy\n      * General\n      * Server Updates\n      * New Plugins\n      * Map Server Re-Work\n      * New Particle Filter Messages\n      * Selection of Behavior Tree in each navigation action\n      * FollowPoint Capability\n      * New Costmap Layer\n    * Foxy to Galactic\n      * NavigateToPose Action Feedback updates\n      * NavigateToPose BT-node Interface Changes\n      * NavigateThroughPoses and ComputePathThroughPoses Actions Added\n      * ComputePathToPose BT-node Interface Changes\n      * ComputePathToPose Action Interface Changes\n      * BackUp BT-node Interface Changes\n      * BackUp Recovery Interface Changes\n      * Nav2 Controllers and Goal Checker Plugin Interface Changes\n      * FollowPath goal_checker_id attribute\n      * Groot Support\n      * New Plugins\n      * Costmap Filters\n      * SmacPlanner\n      * ThetaStarPlanner\n      * RegulatedPurePursuitController\n      * Costmap2D `current_` Usage\n      * Standard time units in parameters\n      * Ray Tracing Parameters\n      * Obstacle Marking Parameters\n      * Recovery Action Changes\n      * Default Behavior Tree Changes\n      * NavFn Planner Parameters\n      * New ClearCostmapExceptRegion and ClearCostmapAroundRobot BT-nodes\n      * New Behavior Tree Nodes\n      * sensor_msgs/PointCloud to sensor_msgs/PointCloud2 Change\n      * ControllerServer New Parameter failure_tolerance\n      * Removed BT XML Launch Configurations\n      * Nav2 RViz Panel Action Feedback Information\n    * Galactic to Humble\n      * Major improvements to Smac Planners\n      * Simple (Python) Commander\n      * Reduce Nodes and Executors\n      * API Change for nav2_core\n      * Extending the BtServiceNode to process Service-Results\n      * Including new Rotation Shim Controller Plugin\n      * Spawning the robot in Gazebo\n      * Recovery Behavior Timeout\n      * New parameter `use_final_approach_orientation` for the 3 2D planners\n      * SmacPlanner2D and Theta*: fix goal orientation being ignored\n      * SmacPlanner2D, NavFn and Theta*: fix small path corner cases\n      * Change and fix behavior of dynamic parameter change detection\n      * Dynamic Parameters\n      * BT Action Nodes Exception Changes\n      * BT Navigator Groot Multiple Navigators\n      * Removed Kinematic Limiting in RPP\n      * Added Smoother Task Server\n      * Removed Use Approach Velocity Scaling Param in RPP\n      * Refactored AMCL motion models as plugins\n      * Dropping Support for Live Groot Monitoring of Nav2\n      * Replanning Only if Path is Invalid\n      * Fix CostmapLayer clearArea invert param logic\n      * Dynamic Composition\n      * BT Cancel Node\n      * BT PathLongerOnApproach Node\n      * BT TruncatePathLocal Node\n      * Constrained Smoother\n      * Replanning at a Constant Rate and if the Path is Invalid\n      * Euclidean Distance 2D\n      * Recovery To Behavior\n      * Respawn Support in Launch and Lifecycle Manager\n      * New Nav2 Velocity Smoother\n      * Goal Checker API Changed\n      * Added Assisted Teleop\n    * Humble to Iron\n      * New Behavior-Tree Navigator Plugins\n      * Added Collision Monitor\n      * Removed use_sim_time from yaml\n      * Run-time Speed up of Smac Planner\n      * Recursive Refinement of Smac and Simple Smoothers\n      * Simple Commander Python API\n      * Smac Planner Start Pose Included in Path\n      * Parameterizable Collision Checking in RPP\n      * Expanded Planner Benchmark Tests\n      * Smac Planner Path Tolerances\n      * costmap_2d_node default constructor\n      * Feedback for Navigation Failures\n      * Costmap Filters\n      * Savitzky-Golay Smoother\n      * Changes to Map yaml file path for map_server node in Launch\n      * SmootherSelector BT Node\n      * Publish Costmap Layers\n      * Give Behavior Server Access to Both Costmaps\n      * New Model Predictive Path Integral Controller\n      * Behavior Tree Uses Error Codes\n      * Load, Save and Loop Waypoints from the Nav2 Panel in RViz\n      * DWB Forward vs Reverse Pruning\n      * More stable regulation on curves for long lookahead distances\n      * Publish Collision Monitor State\n      * Renamed ROS-parameter in Collision Monitor\n      * New safety behavior model \u201climit\u201d in Collision Monitor\n      * Velocity smoother applies deceleration when timeout\n      * PoseProgressChecker plugin\n      * Allow multiple goal checkers and change parameter progress_checker_plugin(s) name and type\n      * IsBatteryChargingCondition BT Node\n      * Behavior Server Error Codes\n      * New Denoise Costmap Layer Plugin\n      * SmacPlannerHybrid viz_expansions parameter\n    * Iron to Jazzy\n      * BehaviorTree.CPP upgraded to version 4.5+\n      * Added TwistStamped Option for Commands\n      * Add VelocityPolygon in Collision Monitor\n      * Change polygon points parameter format in Collision Monitor\n      * Introduction of Soft-Real Time Action Servers\n      * `opennav_coverage` Project\n      * `opennav_docking` Project\n      * Introduce a new Multi-Robot Bringup Launch\n      * New option for the Voxel and Obstacle Layers\n      * use_interpolation RPP Parameter Depreciated\n      * Changes to MPPI Goal Critic\n      * Changes to MPPI Path Angle Critic\n      * Changes to MPPI Path Handling For Directionality\n      * Addition of new MPPI Cost Critic\n      * MPPI Acceleration\n      * Move Error Code Enumerations\n      * Substitution in parameter file\n      * Allow Behavior Server Plugins to Access The Action Result\n      * Smac Planner Debug Param Name Change\n      * Smac Planner On Approach to Goal Shortcutting Solutions\n      * Added GPS Waypoint Follower Server\n      * Smac Planner Hybrid-A* New Features\n      * New node in nav2_collision_monitor: Collision Detector\n      * Dynamic enabling/disabling of sources/polygons in Collision Monitor/Detector\n      * Expose action server\u2019s result timeout\n      * RewrittenYaml could add new parameters to YAMLs\n      * Simple Commander API Allows Multi-Robot Namespacing\n      * Change duration type in wait_action node\n      * The costmap activation fails when required transforms are not available\n      * Subtrees Obtain Shared Resources\n      * Collision Monitor: added watchdog mechanism based on `source_timeout` parameter with default blocking behavior\n      * BtActionServer: use native library haltTree()\n      * Global Frame Removed from 2 BT Nodes\n      * Introduction of `CostmapUpdate.msg`\n      * Full Stack Uses Node Clocks\n      * New Graceful Motion Controller\n      * Plugin Libraries in BT Navigator Only Includes Custom Nodes\n      * New RViz Plugin for selecting Planners, Controllers, Goal Checkers, Progress Checkers and Smoothers\n      * RPP new optional `interpolate_curvature_after_goal` behavior and fix conflict between `use_rotate_to_heading` and `allow_reversing`\n      * Cancel Checker Interface For GlobalPlanner\n      * New BtActionServer/BtNavigator parameter\n      * New collision monitor parameter\n      * New graceful cancellation API for Controllers\n      * Standardization of Plugin Naming with Double Colons (::)\n      * Collision monitor: dynamic radius for circle type polygons\n      * Static Layer: new parameter `footprint_clearing_enabled`\n      * Lifecycle Node: added bond_heartbeat_period parameter (and allow disabling the bond mechanism)\n      * Rotation Shim Controller: new parameter `rotate_to_goal_heading`\n      * MPPI Controller: Addition of acceleration constraints\n      * RegulatedPurePursuit Controller [RPP]: new parameter `use_cancel_deceleration`\n    * Jazzy to K-Turtle\n      * TwistStamped Default CmdVel Change\n      * New Nav2 Loopback Simulator\n      * Docking with Static Infrastructure or Dynamic Docking\n      * New RViz panel for Docking\n      * New BT Nodes\n      * New RViz Tool for Costmap Cost Cell Inspection\n      * Fix flickering visualization\n      * Option to limit velocity through DWB trajectory\n      * Option to disable zero velocity publishing on goal exit\n      * Added optional collision checking for the Docking Server\n      * Revamped multirobot bringup and config files to use namespaces\n      * Removed global map_topic from Costmap node\n      * Simplified Costmap2DROS constructors\n  * Simple Commander API\n    * Overview\n    * Commander API\n    * Costmap API\n    * Footprint Collision Checker API\n    * Examples and Demos\n  * Roadmaps\n    * Jazzy Roadmap\n    * Iron Roadmap\n    * Humble Roadmap\n  * About and Contact\n    * Related Projects\n    * About\n    * Contact\n\n__Nav2\n\nEdit\n\n  *   * Getting Started\n  * \n\n* * *\n\n# Getting Started\uf0c1\n\nThis document will take you through the process of installing the Nav2\nbinaries and navigating a simulated Turtlebot 3 in the Gazebo simulator.\n\nNote\n\nSee the Build and Install for other situations such as building from source or\nworking with other types of robots.\n\nWarning\n\nThis is a simplified version of the Turtlebot 3 instructions. We highly\nrecommend you follow the official Turtlebot 3 manual if you intend to continue\nworking with this robot beyond the minimal example provided here.\n\n## Installation\uf0c1\n\nJazzy introduced the new Gazebo modern simulator, replacing Gazebo Classic.\nThus, for Jazzy and newer, the installation packages and instructions are\nslightly different to pull in the appropriate packages.\n\n  1. Install the ROS 2 binary packages as described in the official docs\n\n  2. Install the Nav2 packages using your operating system\u2019s package manager:\n    \n        sudo apt install ros-<ros2-distro>-navigation2\n    sudo apt install ros-<ros2-distro>-nav2-bringup\n    \n\n  3. Install the demo robot (Turtlebot) for gazebo:\n\nFor **Jazzy and newer** , install the Turtlebot 3 & 4 packages for Gazebo\nModern. It should be automatically installed with `nav2_bringup`:\n\n>\n>     sudo apt install ros-<ros2-distro>-nav2-minimal-tb*\n>  \n\nFor **Iron and older** , install Turtlebot 3 packages for gazebo classic:\n\n>\n>     sudo apt install ros-<ros2-distro>-turtlebot3-gazebo\n>  \n\n## Running the Example\uf0c1\n\n  1. Start a terminal in your GUI\n\n  2. Set key environment variables, some of which are only required for Iron and older:\n    \n        source /opt/ros/<ros2-distro>/setup.bash\n    export TURTLEBOT3_MODEL=waffle  # Iron and older only with Gazebo Classic\n    export GAZEBO_MODEL_PATH=$GAZEBO_MODEL_PATH:/opt/ros/<ros2-distro>/share/turtlebot3_gazebo/models # Iron and older only with Gazebo Classic\n    \n\n  3. In the same terminal, run:\n    \n        ros2 launch nav2_bringup tb3_simulation_launch.py headless:=False\n    \n\nNote\n\n`headless` defaults to true; if not set to false, gzclient (the 3d view) is\nnot started.\n\nThis launch file will launch Nav2 with the AMCL localizer in the simulation\nworld. It will also launch the robot state publisher to provide transforms, a\nGazebo instance with the Turtlebot3 URDF, and RVIZ.\n\nIf everything has started correctly, you will see the RViz and Gazebo GUIs\nlike this (this is Gazebo Classic, but what you see with modern Gazebo is\nvirtually identical):\n\n  4. If not autostarting, click the \u201cStartup\u201d button in the bottom left corner of RViz. This will cause Nav2 to change to the Active state. It should change appearance to show the map.\n\n## Navigating\uf0c1\n\nAfter starting, the robot initially has no idea where it is. By default, Nav2\nwaits for you to give it an approximate starting position. Take a look at\nwhere the robot is in the Gazebo world, and find that spot on the map. Set the\ninitial pose by clicking the \u201c2D Pose Estimate\u201d button in RViz, and then down\nclicking on the map in that location. You set the orientation by dragging\nforward from the down click.\n\nIf you are using the defaults so far, the robot should look roughly like this.\n\n> If you don\u2019t get the location exactly right, that\u2019s fine. Nav2 will refine\n> the position as it navigates. You can also, click the \u201c2D Pose Estimate\u201d\n> button and try again, if you prefer.\n\nOnce you\u2019ve set the initial pose, the transform tree will be complete and Nav2\nwill be fully active and ready to go. You should see the robot and particle\ncloud now.\n\n> Next, click the \u201cNavigaton2 Goal\u201d button and choose a destination. This will\n> call the BT navigator to go to that goal through an action server. You can\n> pause (cancel) or reset the action through the Nav2 rviz plugin shown.\n\n> Now watch the robot go!\n\n* * *\n\n(C) Copyright 2023.\n\n",
                "language": "en"
            },
            "platform": "docs.nav2.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://docs.nav2.org/getting_started/index.html#running-the-example"
        },
        {
            "id": "ff9c0f7b-257e-4a77-94f8-432874ba4fd9",
            "content": {
                "Title": "Getting Started \u2014 Nav2 1.0.0 documentation",
                "Subtitle": null,
                "Content": "Nav2\n\nlatest\n\n  * Getting Started\n    * Installation\n    * Running the Example\n    * Navigating\n  * Development Guides\n    * Build and Install\n      * Install\n        * For Iron and Older\n        * For Jazzy and Newer\n      * Build\n        * Released Distribution Binaries\n        * Rolling Development Source\n        * Docker Container Images\n      * Generate Doxygen\n      * Help\n        * Build Troubleshooting Guide\n    * Dev Containers\n      * Dev Container Guide\n        * Creating Dev Containers\n        * Using Dev Containers\n      * What, Why, How?\n        * What is a Dev Container?\n        * Why use a Dev Container?\n        * How do Dev Containers work?\n      * Prerequisites\n      * Getting started\n      * Security\n    * Getting Involved\n      * Getting Involved\n      * Process\n      * Licensing\n      * Developer Certification of Origin (DCO)\n  * Navigation Concepts\n    * ROS 2\n      * Action Server\n      * Lifecycle Nodes and Bond\n    * Behavior Trees\n    * Navigation Servers\n      * Planner, Controller, Smoother and Recovery Servers\n      * Planners\n      * Controllers\n      * Behaviors\n      * Smoothers\n      * Robot Footprints\n      * Waypoint Following\n    * State Estimation\n      * Standards\n      * Global Positioning: Localization and SLAM\n      * Odometry\n    * Environmental Representation\n      * Costmaps and Layers\n      * Costmap Filters\n      * Other Forms\n    * Nav2 Academic Overview\n  * First-Time Robot Setup Guide\n    * Setting Up Transformations\n      * Transforms Introduction\n      * Static Transform Publisher Demo\n      * Transforms in Navigation2\n      * Conclusion\n    * Setting Up The URDF\n      * URDF and the Robot State Publisher\n      * Setting Up the Environment\n      * Writing the URDF\n      * Build and Launch\n      * Visualization using RVIZ\n      * Adding Physical Properties\n      * Conclusion\n    * Setting Up Odometry\n      * Odometry Introduction\n      * Setting Up Odometry on your Robot\n      * Simulating an Odometry System using Gazebo\n        * Setup and Prerequisites\n        * Adding Gazebo Plugins to a URDF\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Robot Localization Demo\n        * Configuring Robot Localization\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Conclusion\n    * Setting Up Sensors\n      * Sensor Introduction\n        * Common Sensor Messages\n      * Simulating Sensors using Gazebo\n        * Adding Gazebo Plugins to a URDF\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Mapping and Localization\n      * Costmap 2D\n        * Configuring nav2_costmap_2d\n        * Build, Run and Verification\n      * Conclusion\n    * Setting Up the Robot\u2019s Footprint\n      * Footprint Introduction\n      * Configuring the Robot\u2019s Footprint\n      * Build, Run and Verification\n      * Visualizing Footprint in RViz\n      * Conclusion\n    * Setting Up Navigation Plugins\n      * Planner and Controller Servers\n      * Selecting the Algorithm Plugins\n        * Planner Server\n        * Controller Server\n      * Conclusion\n  * Robots Using\n  * General Tutorials\n    * Navigating with a Physical Turtlebot 3\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Setup Your Environment Variables\n        * 1- Launch Turtlebot 3\n        * 2- Launch Nav2\n        * 3- Launch RVIZ\n        * 4- Initialize the Location of Turtlebot 3\n        * 5- Send a Goal Pose\n    * (SLAM) Navigating While Mapping\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Launch Robot Interfaces\n        * 1- Launch Navigation2\n        * 2- Launch SLAM\n        * 3- Working with SLAM\n        * 4- Getting Started Simplification\n    * (STVL) Using an External Costmap Plugin\n      * Overview\n      * Costmap2D and STVL\n      * Tutorial Steps\n        * 0- Setup\n        * 1- Install STVL\n        * 1- Modify Navigation2 Parameter\n        * 2- Launch Navigation2\n        * 3- RVIZ\n    * Navigating Using GPS Localization\n      * Overview\n      * Requirements\n      * GPS Localization Overview\n      * Tutorial Steps\n        * 0- Setup Gazebo World\n        * 1- Setup GPS Localization system\n        * 2- Setup Navigation system\n        * 3- Interactive GPS Waypoint Follower\n        * 4- Logged GPS Waypoint Follower & Waypoint Logging\n      * Conclusion\n    * Groot - Interacting with Behavior Trees\n      * Overview\n      * Visualize Behavior Trees\n      * Edit Behavior Trees\n      * Adding A Custom Node\n    * Using VIO to Augment Robot Odometry\n      * Overview\n      * Setting Up the ZED X Camera\n      * Setting Up ZED ROS\n      * Fusing VIO Into Local State Estimate\n        * Fusing VSLAM Into Global State Estimate\n      * Testing it Out!\n    * Dynamic Object Following\n      * Overview\n      * Tutorial Steps\n        * 0- Create the Behavior Tree\n        * 1- Setup Rviz clicked point\n        * 2- Run Dynamic Object Following in Nav2 Simulation\n    * Navigating with Keepout Zones\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Prepare filter mask\n        * 2\\. Configure Costmap Filter Info Publisher Server\n        * 3\\. Enable Keepout Filter\n        * 4\\. Run Nav2 stack\n    * Navigating with Speed Limits\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Prepare filter mask\n        * 2\\. Configure Costmap Filter Info Publisher Server\n        * 3\\. Enable Speed Filter\n        * 4\\. Run Nav2 stack\n    * Using Docking Server\n      * Overview\n      * Requirements\n      * ChargingDock Plugins\n      * Dock Database\n      * Configuring Docking Server\n      * Adding Docking Server to Launch\n      * Docking Action API\n      * Putting It All Together\n    * Using Rotation Shim Controller\n      * Overview\n      * What is the Rotation Shim Controller?\n      * Configuring Rotation Shim Controller\n      * Configuring Primary Controller\n      * Demo Execution\n    * Adding a Smoother to a BT\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Familiarization with the Smoother BT Node\n        * 1- Specifying a Smoother Plugin\n        * 2- Modifying your BT XML\n    * Using Collision Monitor\n      * Overview\n      * Requirements\n      * Configuring Collision Monitor\n      * Configuring Collision Monitor with VelocityPolygon\n      * Preparing Nav2 stack\n      * Demo Execution\n    * Adding a New Nav2 Task Server\n      * Lifecycle Nodes\n      * Composition\n      * Error codes\n      * Conclusion\n    * Filtering of Noise-Induced Obstacles\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Enable Denoise Layer\n        * 2\\. Run Nav2 stack\n      * How it works\n    * Camera Calibration\n      * Overview\n      * Requirements\n      * Tutorial Steps\n    * Get Backtrace in ROS 2 / Nav2\n      * Overview\n      * Preliminaries\n      * From a Node\n      * From a Launch File\n      * From Large Project\n      * From Nav2 Bringup\n      * Automatic backtrace on crash\n    * Profiling in ROS 2 / Nav2\n      * Overview\n      * Preliminaries\n      * Profile from a Node\n      * Profile from a Launch File\n      * From Nav2 Bringup\n      * Interpreting Results\n    * Docker for Development: Zero to Hero\n      * Overview\n      * Preliminaries\n      * Important Docker Commands\n      * Exploring Your First Container\n      * Understanding ROS Docker Images\n      * For Docker-Based Development\n        * Building a Development Image\n        * Visualizations from Docker\n      * For Docker-Based Deployment\n      * Conclusion\n      * Appendix\n        * Nav2 Development Image\n        * Nav2 Deployment Image\n  * Plugin Tutorials\n    * Writing a New Costmap2D Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Write a new Costmap2D plugin\n        * 2- Export and make GradientLayer plugin\n        * 3- Enable the plugin in Costmap2D\n        * 4- Run GradientLayer plugin\n    * Writing a New Planner Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new Planner Plugin\n        * 2- Exporting the planner plugin\n        * 3- Pass the plugin name through params file\n        * 4- Run StraightLine plugin\n    * Writing a New Controller Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Create a new Controller Plugin\n        * 2- Exporting the controller plugin\n        * 3- Pass the plugin name through the params file\n        * 4- Run Pure Pursuit Controller plugin\n    * Writing a New Behavior Tree Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new BT Plugin\n        * 2- Exporting the planner plugin\n        * 3- Add plugin library name to config\n        * 4- Run Your Custom plugin\n    * Writing a New Behavior Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new Behavior Plugin\n        * 2- Exporting the Behavior Plugin\n        * 3- Pass the plugin name through params file\n        * 4- Run Behavior Plugin\n    * Writing a New Navigator Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Create a new Navigator Plugin\n        * 2- Exporting the navigator plugin\n        * 3- Pass the plugin name through the params file\n        * 4- Run plugin\n  * Configuration Guide\n    * Behavior-Tree Navigator\n      * Parameters\n      * Example\n    * Behavior Tree XML Nodes\n      * Action Plugins\n        * Wait\n        * Spin\n        * BackUp\n        * DriveOnHeading\n        * AssistedTeleop\n        * ComputePathToPose\n        * FollowPath\n        * NavigateToPose\n        * ClearEntireCostmap\n        * ClearCostmapExceptRegion\n        * ClearCostmapAroundRobot\n        * ReinitializeGlobalLocalization\n        * TruncatePath\n        * TruncatePathLocal\n        * PlannerSelector\n        * ControllerSelector\n        * SmootherSelector\n        * GoalCheckerSelector\n        * ProgressCheckerSelector\n        * NavigateThroughPoses\n        * ComputePathThroughPoses\n        * ComputeCoveragePath\n        * CancelCoverage\n        * RemovePassedGoals\n        * RemoveInCollisionGoals\n        * CancelControl\n        * CancelBackUp\n        * CancelSpin\n        * CancelWait\n        * CancelDriveOnHeading\n        * CancelAssistedTeleop\n        * SmoothPath\n        * GetPoseFromPath\n        * DockRobot\n        * UndockRobot\n      * Condition Plugins\n        * GoalReached\n        * TransformAvailable\n        * DistanceTraveled\n        * GoalUpdated\n        * GloballyUpdatedGoal\n        * InitialPoseReceived\n        * IsStuck\n        * IsStopped\n        * TimeExpired\n        * IsBatteryLow\n        * IsPathValid\n        * PathExpiringTimer\n        * AreErrorCodesPresent\n        * WouldAControllerRecoveryHelp\n        * WouldAPlannerRecoveryHelp\n        * WouldASmootherRecoveryHelp\n        * IsBatteryCharging\n      * Control Plugins\n        * PipelineSequence\n        * RoundRobin\n        * RecoveryNode\n      * Decorator Plugins\n        * RateController\n        * DistanceController\n        * SpeedController\n        * GoalUpdater\n        * PathLongerOnApproach\n        * SingleTrigger\n      * Example\n    * Costmap 2D\n      * Costmap2D ROS Parameters\n      * Default Plugins\n      * Plugin Parameters\n        * Static Layer Parameters\n        * Inflation Layer Parameters\n        * Obstacle Layer Parameters\n        * Voxel Layer Parameters\n        * Range Sensor Parameters\n        * Denoise Layer Parameters\n      * Costmap Filters Parameters\n        * Keepout Filter Parameters\n        * Speed Filter Parameters\n        * Binary Filter Parameters\n      * Example\n    * Lifecycle Manager\n      * Parameters\n      * Example\n    * Planner Server\n      * Parameters\n      * Default Plugins\n      * Example\n    * Coverage Server\n      * Parameters\n      * Example\n    * NavFn Planner\n      * Parameters\n      * Example\n    * Smac Planner\n      * Provided Plugins\n        * Smac 2D Planner\n        * Smac Hybrid-A* Planner\n        * Smac State Lattice Planner\n      * Description\n    * Theta Star Planner\n      * Parameters\n      * Example\n    * Controller Server\n      * Parameters\n      * Provided Plugins\n        * SimpleProgressChecker\n        * PoseProgressChecker\n        * SimpleGoalChecker\n        * StoppedGoalChecker\n      * Default Plugins\n      * Example\n    * DWB Controller\n      * Controller\n        * DWB Controller\n        * XYTheta Iterator\n        * Kinematic Parameters\n        * Publisher\n      * Plugins\n        * LimitedAccelGenerator\n        * StandardTrajectoryGenerator\n      * Trajectory Critics\n        * BaseObstacleCritic\n        * GoalAlignCritic\n        * GoalDistCritic\n        * ObstacleFootprintCritic\n        * OscillationCritic\n        * PathAlignCritic\n        * PathDistCritic\n        * PreferForwardCritic\n        * RotateToGoalCritic\n        * TwirlingCritic\n      * Example\n    * Regulated Pure Pursuit\n      * Regulated Pure Pursuit Parameters\n      * Example\n    * Model Predictive Path Integral Controller\n      * MPPI Parameters\n        * Trajectory Visualization\n        * Path Handler\n        * Ackermann Motion Model\n        * Constraint Critic\n        * Goal Angle Critic\n        * Goal Critic\n        * Obstacles Critic\n        * Cost Critic\n        * Path Align Critic\n        * Path Angle Critic\n        * Path Follow Critic\n        * Prefer Forward Critic\n        * Twirling Critic\n        * Velocity Deadband Critic\n      * Example\n      * Notes to Users\n        * General Words of Wisdom\n        * Prediction Horizon, Costmap Sizing, and Offsets\n        * Obstacle, Inflation Layer, and Path Following\n    * Rotation Shim Controller\n      * Rotation Shim Controller Parameters\n      * Example\n    * Graceful Controller\n      * Graceful Controller Parameters\n      * Example\n    * Map Server / Saver\n      * Map Saver Parameters\n      * Map Server Parameters\n      * Costmap Filter Info Server Parameters\n      * Example\n    * AMCL\n      * Parameters\n      * Example\n    * Behavior Server\n      * Behavior Server Parameters\n      * Default Plugins\n      * Spin Behavior Parameters\n      * BackUp Behavior Parameters\n      * DriveOnHeading Behavior Parameters\n      * AssistedTeleop Behavior Parameters\n      * Example\n    * Smoother Server\n      * Smoother Server Parameters\n      * Example\n    * Simple Smoother\n      * Simple Smoother Parameters\n      * Example\n    * Savitzky-Golay Smoother\n      * Savitzky-Golay Smoother Parameters\n      * Example\n    * Constrained smoother\n      * Smoother Server Parameters\n      * Example\n    * Velocity Smoother\n      * Velocity Smoother Parameters\n      * Example\n    * Collision Monitor\n      * Provided Nodes\n        * Collision Monitor Node\n        * Collision Detector Node\n    * Waypoint Follower\n      * Parameters\n      * Provided Plugins\n        * WaitAtWaypoint\n        * PhotoAtWaypoint\n        * InputAtWaypoint\n      * Default Plugin\n      * Example\n    * Loopback Simulator\n      * Parameters\n      * Example\n    * Docking Server\n      * Parameters\n      * SimpleChargingDock Parameters\n      * Example\n  * Tuning Guide\n    * Inflation Potential Fields\n    * Robot Footprint vs Radius\n    * Rotate in Place Behavior\n    * Planner Plugin Selection\n    * Controller Plugin Selection\n    * Caching Obstacle Heuristic in Smac Planners\n    * Costmap2D Plugins\n    * Nav2 Launch Options\n    * Other Pages We\u2019d Love To Offer\n  * Nav2 Behavior Trees\n    * Introduction To Nav2 Specific Nodes\n      * Action Nodes\n      * Condition Nodes\n      * Decorator Nodes\n      * Control: PipelineSequence\n      * Control: Recovery\n      * Control: RoundRobin\n    * Detailed Behavior Tree Walkthrough\n      * Overview\n      * Prerequisites\n      * Navigate To Pose With Replanning and Recovery\n      * Navigation Subtree\n      * Recovery Subtree\n    * Navigate To Pose\n    * Navigate Through Poses\n    * Navigate To Pose and Pause Near Goal-Obstacle\n    * Navigate To Pose With Consistent Replanning And If Path Becomes Invalid\n    * Follow Dynamic Point\n    * Odometry Calibration\n  * Navigation Plugins\n    * Behavior-Tree Navigators\n    * Costmap Layers\n    * Costmap Filters\n    * Controllers\n    * Planners\n    * Smoothers\n    * Behaviors\n    * Waypoint Task Executors\n    * Goal Checkers\n    * Progress Checkers\n    * Behavior Tree Nodes\n  * Migration Guides\n    * Dashing to Eloquent\n      * New Packages\n      * New Plugins\n      * Navigation2 Architectural Changes\n    * Eloquent to Foxy\n      * General\n      * Server Updates\n      * New Plugins\n      * Map Server Re-Work\n      * New Particle Filter Messages\n      * Selection of Behavior Tree in each navigation action\n      * FollowPoint Capability\n      * New Costmap Layer\n    * Foxy to Galactic\n      * NavigateToPose Action Feedback updates\n      * NavigateToPose BT-node Interface Changes\n      * NavigateThroughPoses and ComputePathThroughPoses Actions Added\n      * ComputePathToPose BT-node Interface Changes\n      * ComputePathToPose Action Interface Changes\n      * BackUp BT-node Interface Changes\n      * BackUp Recovery Interface Changes\n      * Nav2 Controllers and Goal Checker Plugin Interface Changes\n      * FollowPath goal_checker_id attribute\n      * Groot Support\n      * New Plugins\n      * Costmap Filters\n      * SmacPlanner\n      * ThetaStarPlanner\n      * RegulatedPurePursuitController\n      * Costmap2D `current_` Usage\n      * Standard time units in parameters\n      * Ray Tracing Parameters\n      * Obstacle Marking Parameters\n      * Recovery Action Changes\n      * Default Behavior Tree Changes\n      * NavFn Planner Parameters\n      * New ClearCostmapExceptRegion and ClearCostmapAroundRobot BT-nodes\n      * New Behavior Tree Nodes\n      * sensor_msgs/PointCloud to sensor_msgs/PointCloud2 Change\n      * ControllerServer New Parameter failure_tolerance\n      * Removed BT XML Launch Configurations\n      * Nav2 RViz Panel Action Feedback Information\n    * Galactic to Humble\n      * Major improvements to Smac Planners\n      * Simple (Python) Commander\n      * Reduce Nodes and Executors\n      * API Change for nav2_core\n      * Extending the BtServiceNode to process Service-Results\n      * Including new Rotation Shim Controller Plugin\n      * Spawning the robot in Gazebo\n      * Recovery Behavior Timeout\n      * New parameter `use_final_approach_orientation` for the 3 2D planners\n      * SmacPlanner2D and Theta*: fix goal orientation being ignored\n      * SmacPlanner2D, NavFn and Theta*: fix small path corner cases\n      * Change and fix behavior of dynamic parameter change detection\n      * Dynamic Parameters\n      * BT Action Nodes Exception Changes\n      * BT Navigator Groot Multiple Navigators\n      * Removed Kinematic Limiting in RPP\n      * Added Smoother Task Server\n      * Removed Use Approach Velocity Scaling Param in RPP\n      * Refactored AMCL motion models as plugins\n      * Dropping Support for Live Groot Monitoring of Nav2\n      * Replanning Only if Path is Invalid\n      * Fix CostmapLayer clearArea invert param logic\n      * Dynamic Composition\n      * BT Cancel Node\n      * BT PathLongerOnApproach Node\n      * BT TruncatePathLocal Node\n      * Constrained Smoother\n      * Replanning at a Constant Rate and if the Path is Invalid\n      * Euclidean Distance 2D\n      * Recovery To Behavior\n      * Respawn Support in Launch and Lifecycle Manager\n      * New Nav2 Velocity Smoother\n      * Goal Checker API Changed\n      * Added Assisted Teleop\n    * Humble to Iron\n      * New Behavior-Tree Navigator Plugins\n      * Added Collision Monitor\n      * Removed use_sim_time from yaml\n      * Run-time Speed up of Smac Planner\n      * Recursive Refinement of Smac and Simple Smoothers\n      * Simple Commander Python API\n      * Smac Planner Start Pose Included in Path\n      * Parameterizable Collision Checking in RPP\n      * Expanded Planner Benchmark Tests\n      * Smac Planner Path Tolerances\n      * costmap_2d_node default constructor\n      * Feedback for Navigation Failures\n      * Costmap Filters\n      * Savitzky-Golay Smoother\n      * Changes to Map yaml file path for map_server node in Launch\n      * SmootherSelector BT Node\n      * Publish Costmap Layers\n      * Give Behavior Server Access to Both Costmaps\n      * New Model Predictive Path Integral Controller\n      * Behavior Tree Uses Error Codes\n      * Load, Save and Loop Waypoints from the Nav2 Panel in RViz\n      * DWB Forward vs Reverse Pruning\n      * More stable regulation on curves for long lookahead distances\n      * Publish Collision Monitor State\n      * Renamed ROS-parameter in Collision Monitor\n      * New safety behavior model \u201climit\u201d in Collision Monitor\n      * Velocity smoother applies deceleration when timeout\n      * PoseProgressChecker plugin\n      * Allow multiple goal checkers and change parameter progress_checker_plugin(s) name and type\n      * IsBatteryChargingCondition BT Node\n      * Behavior Server Error Codes\n      * New Denoise Costmap Layer Plugin\n      * SmacPlannerHybrid viz_expansions parameter\n    * Iron to Jazzy\n      * BehaviorTree.CPP upgraded to version 4.5+\n      * Added TwistStamped Option for Commands\n      * Add VelocityPolygon in Collision Monitor\n      * Change polygon points parameter format in Collision Monitor\n      * Introduction of Soft-Real Time Action Servers\n      * `opennav_coverage` Project\n      * `opennav_docking` Project\n      * Introduce a new Multi-Robot Bringup Launch\n      * New option for the Voxel and Obstacle Layers\n      * use_interpolation RPP Parameter Depreciated\n      * Changes to MPPI Goal Critic\n      * Changes to MPPI Path Angle Critic\n      * Changes to MPPI Path Handling For Directionality\n      * Addition of new MPPI Cost Critic\n      * MPPI Acceleration\n      * Move Error Code Enumerations\n      * Substitution in parameter file\n      * Allow Behavior Server Plugins to Access The Action Result\n      * Smac Planner Debug Param Name Change\n      * Smac Planner On Approach to Goal Shortcutting Solutions\n      * Added GPS Waypoint Follower Server\n      * Smac Planner Hybrid-A* New Features\n      * New node in nav2_collision_monitor: Collision Detector\n      * Dynamic enabling/disabling of sources/polygons in Collision Monitor/Detector\n      * Expose action server\u2019s result timeout\n      * RewrittenYaml could add new parameters to YAMLs\n      * Simple Commander API Allows Multi-Robot Namespacing\n      * Change duration type in wait_action node\n      * The costmap activation fails when required transforms are not available\n      * Subtrees Obtain Shared Resources\n      * Collision Monitor: added watchdog mechanism based on `source_timeout` parameter with default blocking behavior\n      * BtActionServer: use native library haltTree()\n      * Global Frame Removed from 2 BT Nodes\n      * Introduction of `CostmapUpdate.msg`\n      * Full Stack Uses Node Clocks\n      * New Graceful Motion Controller\n      * Plugin Libraries in BT Navigator Only Includes Custom Nodes\n      * New RViz Plugin for selecting Planners, Controllers, Goal Checkers, Progress Checkers and Smoothers\n      * RPP new optional `interpolate_curvature_after_goal` behavior and fix conflict between `use_rotate_to_heading` and `allow_reversing`\n      * Cancel Checker Interface For GlobalPlanner\n      * New BtActionServer/BtNavigator parameter\n      * New collision monitor parameter\n      * New graceful cancellation API for Controllers\n      * Standardization of Plugin Naming with Double Colons (::)\n      * Collision monitor: dynamic radius for circle type polygons\n      * Static Layer: new parameter `footprint_clearing_enabled`\n      * Lifecycle Node: added bond_heartbeat_period parameter (and allow disabling the bond mechanism)\n      * Rotation Shim Controller: new parameter `rotate_to_goal_heading`\n      * MPPI Controller: Addition of acceleration constraints\n      * RegulatedPurePursuit Controller [RPP]: new parameter `use_cancel_deceleration`\n    * Jazzy to K-Turtle\n      * TwistStamped Default CmdVel Change\n      * New Nav2 Loopback Simulator\n      * Docking with Static Infrastructure or Dynamic Docking\n      * New RViz panel for Docking\n      * New BT Nodes\n      * New RViz Tool for Costmap Cost Cell Inspection\n      * Fix flickering visualization\n      * Option to limit velocity through DWB trajectory\n      * Option to disable zero velocity publishing on goal exit\n      * Added optional collision checking for the Docking Server\n      * Revamped multirobot bringup and config files to use namespaces\n      * Removed global map_topic from Costmap node\n      * Simplified Costmap2DROS constructors\n  * Simple Commander API\n    * Overview\n    * Commander API\n    * Costmap API\n    * Footprint Collision Checker API\n    * Examples and Demos\n  * Roadmaps\n    * Jazzy Roadmap\n    * Iron Roadmap\n    * Humble Roadmap\n  * About and Contact\n    * Related Projects\n    * About\n    * Contact\n\n__Nav2\n\nEdit\n\n  *   * Getting Started\n  * \n\n* * *\n\n# Getting Started\uf0c1\n\nThis document will take you through the process of installing the Nav2\nbinaries and navigating a simulated Turtlebot 3 in the Gazebo simulator.\n\nNote\n\nSee the Build and Install for other situations such as building from source or\nworking with other types of robots.\n\nWarning\n\nThis is a simplified version of the Turtlebot 3 instructions. We highly\nrecommend you follow the official Turtlebot 3 manual if you intend to continue\nworking with this robot beyond the minimal example provided here.\n\n## Installation\uf0c1\n\nJazzy introduced the new Gazebo modern simulator, replacing Gazebo Classic.\nThus, for Jazzy and newer, the installation packages and instructions are\nslightly different to pull in the appropriate packages.\n\n  1. Install the ROS 2 binary packages as described in the official docs\n\n  2. Install the Nav2 packages using your operating system\u2019s package manager:\n    \n        sudo apt install ros-<ros2-distro>-navigation2\n    sudo apt install ros-<ros2-distro>-nav2-bringup\n    \n\n  3. Install the demo robot (Turtlebot) for gazebo:\n\nFor **Jazzy and newer** , install the Turtlebot 3 & 4 packages for Gazebo\nModern. It should be automatically installed with `nav2_bringup`:\n\n>\n>     sudo apt install ros-<ros2-distro>-nav2-minimal-tb*\n>  \n\nFor **Iron and older** , install Turtlebot 3 packages for gazebo classic:\n\n>\n>     sudo apt install ros-<ros2-distro>-turtlebot3-gazebo\n>  \n\n## Running the Example\uf0c1\n\n  1. Start a terminal in your GUI\n\n  2. Set key environment variables, some of which are only required for Iron and older:\n    \n        source /opt/ros/<ros2-distro>/setup.bash\n    export TURTLEBOT3_MODEL=waffle  # Iron and older only with Gazebo Classic\n    export GAZEBO_MODEL_PATH=$GAZEBO_MODEL_PATH:/opt/ros/<ros2-distro>/share/turtlebot3_gazebo/models # Iron and older only with Gazebo Classic\n    \n\n  3. In the same terminal, run:\n    \n        ros2 launch nav2_bringup tb3_simulation_launch.py headless:=False\n    \n\nNote\n\n`headless` defaults to true; if not set to false, gzclient (the 3d view) is\nnot started.\n\nThis launch file will launch Nav2 with the AMCL localizer in the simulation\nworld. It will also launch the robot state publisher to provide transforms, a\nGazebo instance with the Turtlebot3 URDF, and RVIZ.\n\nIf everything has started correctly, you will see the RViz and Gazebo GUIs\nlike this (this is Gazebo Classic, but what you see with modern Gazebo is\nvirtually identical):\n\n  4. If not autostarting, click the \u201cStartup\u201d button in the bottom left corner of RViz. This will cause Nav2 to change to the Active state. It should change appearance to show the map.\n\n## Navigating\uf0c1\n\nAfter starting, the robot initially has no idea where it is. By default, Nav2\nwaits for you to give it an approximate starting position. Take a look at\nwhere the robot is in the Gazebo world, and find that spot on the map. Set the\ninitial pose by clicking the \u201c2D Pose Estimate\u201d button in RViz, and then down\nclicking on the map in that location. You set the orientation by dragging\nforward from the down click.\n\nIf you are using the defaults so far, the robot should look roughly like this.\n\n> If you don\u2019t get the location exactly right, that\u2019s fine. Nav2 will refine\n> the position as it navigates. You can also, click the \u201c2D Pose Estimate\u201d\n> button and try again, if you prefer.\n\nOnce you\u2019ve set the initial pose, the transform tree will be complete and Nav2\nwill be fully active and ready to go. You should see the robot and particle\ncloud now.\n\n> Next, click the \u201cNavigaton2 Goal\u201d button and choose a destination. This will\n> call the BT navigator to go to that goal through an action server. You can\n> pause (cancel) or reset the action through the Nav2 rviz plugin shown.\n\n> Now watch the robot go!\n\n* * *\n\n(C) Copyright 2023.\n\n",
                "language": "en"
            },
            "platform": "docs.nav2.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://docs.nav2.org/getting_started/index.html#navigating"
        },
        {
            "id": "9fe2f357-fd78-4388-b10e-cdcd929489fa",
            "content": {
                "Title": "Build and Install \u2014 Nav2 1.0.0 documentation",
                "Subtitle": null,
                "Content": "Nav2\n\nlatest\n\n  * Getting Started\n    * Installation\n    * Running the Example\n    * Navigating\n  * Development Guides\n    * Build and Install\n      * Install\n        * For Iron and Older\n        * For Jazzy and Newer\n      * Build\n        * Released Distribution Binaries\n        * Rolling Development Source\n        * Docker Container Images\n      * Generate Doxygen\n      * Help\n        * Build Troubleshooting Guide\n    * Dev Containers\n      * Dev Container Guide\n        * Creating Dev Containers\n        * Using Dev Containers\n      * What, Why, How?\n        * What is a Dev Container?\n        * Why use a Dev Container?\n        * How do Dev Containers work?\n      * Prerequisites\n      * Getting started\n      * Security\n    * Getting Involved\n      * Getting Involved\n      * Process\n      * Licensing\n      * Developer Certification of Origin (DCO)\n  * Navigation Concepts\n    * ROS 2\n      * Action Server\n      * Lifecycle Nodes and Bond\n    * Behavior Trees\n    * Navigation Servers\n      * Planner, Controller, Smoother and Recovery Servers\n      * Planners\n      * Controllers\n      * Behaviors\n      * Smoothers\n      * Robot Footprints\n      * Waypoint Following\n    * State Estimation\n      * Standards\n      * Global Positioning: Localization and SLAM\n      * Odometry\n    * Environmental Representation\n      * Costmaps and Layers\n      * Costmap Filters\n      * Other Forms\n    * Nav2 Academic Overview\n  * First-Time Robot Setup Guide\n    * Setting Up Transformations\n      * Transforms Introduction\n      * Static Transform Publisher Demo\n      * Transforms in Navigation2\n      * Conclusion\n    * Setting Up The URDF\n      * URDF and the Robot State Publisher\n      * Setting Up the Environment\n      * Writing the URDF\n      * Build and Launch\n      * Visualization using RVIZ\n      * Adding Physical Properties\n      * Conclusion\n    * Setting Up Odometry\n      * Odometry Introduction\n      * Setting Up Odometry on your Robot\n      * Simulating an Odometry System using Gazebo\n        * Setup and Prerequisites\n        * Adding Gazebo Plugins to a URDF\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Robot Localization Demo\n        * Configuring Robot Localization\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Conclusion\n    * Setting Up Sensors\n      * Sensor Introduction\n        * Common Sensor Messages\n      * Simulating Sensors using Gazebo\n        * Adding Gazebo Plugins to a URDF\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Mapping and Localization\n      * Costmap 2D\n        * Configuring nav2_costmap_2d\n        * Build, Run and Verification\n      * Conclusion\n    * Setting Up the Robot\u2019s Footprint\n      * Footprint Introduction\n      * Configuring the Robot\u2019s Footprint\n      * Build, Run and Verification\n      * Visualizing Footprint in RViz\n      * Conclusion\n    * Setting Up Navigation Plugins\n      * Planner and Controller Servers\n      * Selecting the Algorithm Plugins\n        * Planner Server\n        * Controller Server\n      * Conclusion\n  * Robots Using\n  * General Tutorials\n    * Navigating with a Physical Turtlebot 3\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Setup Your Environment Variables\n        * 1- Launch Turtlebot 3\n        * 2- Launch Nav2\n        * 3- Launch RVIZ\n        * 4- Initialize the Location of Turtlebot 3\n        * 5- Send a Goal Pose\n    * (SLAM) Navigating While Mapping\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Launch Robot Interfaces\n        * 1- Launch Navigation2\n        * 2- Launch SLAM\n        * 3- Working with SLAM\n        * 4- Getting Started Simplification\n    * (STVL) Using an External Costmap Plugin\n      * Overview\n      * Costmap2D and STVL\n      * Tutorial Steps\n        * 0- Setup\n        * 1- Install STVL\n        * 1- Modify Navigation2 Parameter\n        * 2- Launch Navigation2\n        * 3- RVIZ\n    * Navigating Using GPS Localization\n      * Overview\n      * Requirements\n      * GPS Localization Overview\n      * Tutorial Steps\n        * 0- Setup Gazebo World\n        * 1- Setup GPS Localization system\n        * 2- Setup Navigation system\n        * 3- Interactive GPS Waypoint Follower\n        * 4- Logged GPS Waypoint Follower & Waypoint Logging\n      * Conclusion\n    * Groot - Interacting with Behavior Trees\n      * Overview\n      * Visualize Behavior Trees\n      * Edit Behavior Trees\n      * Adding A Custom Node\n    * Using VIO to Augment Robot Odometry\n      * Overview\n      * Setting Up the ZED X Camera\n      * Setting Up ZED ROS\n      * Fusing VIO Into Local State Estimate\n        * Fusing VSLAM Into Global State Estimate\n      * Testing it Out!\n    * Dynamic Object Following\n      * Overview\n      * Tutorial Steps\n        * 0- Create the Behavior Tree\n        * 1- Setup Rviz clicked point\n        * 2- Run Dynamic Object Following in Nav2 Simulation\n    * Navigating with Keepout Zones\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Prepare filter mask\n        * 2\\. Configure Costmap Filter Info Publisher Server\n        * 3\\. Enable Keepout Filter\n        * 4\\. Run Nav2 stack\n    * Navigating with Speed Limits\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Prepare filter mask\n        * 2\\. Configure Costmap Filter Info Publisher Server\n        * 3\\. Enable Speed Filter\n        * 4\\. Run Nav2 stack\n    * Using Docking Server\n      * Overview\n      * Requirements\n      * ChargingDock Plugins\n      * Dock Database\n      * Configuring Docking Server\n      * Adding Docking Server to Launch\n      * Docking Action API\n      * Putting It All Together\n    * Using Rotation Shim Controller\n      * Overview\n      * What is the Rotation Shim Controller?\n      * Configuring Rotation Shim Controller\n      * Configuring Primary Controller\n      * Demo Execution\n    * Adding a Smoother to a BT\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Familiarization with the Smoother BT Node\n        * 1- Specifying a Smoother Plugin\n        * 2- Modifying your BT XML\n    * Using Collision Monitor\n      * Overview\n      * Requirements\n      * Configuring Collision Monitor\n      * Configuring Collision Monitor with VelocityPolygon\n      * Preparing Nav2 stack\n      * Demo Execution\n    * Adding a New Nav2 Task Server\n      * Lifecycle Nodes\n      * Composition\n      * Error codes\n      * Conclusion\n    * Filtering of Noise-Induced Obstacles\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Enable Denoise Layer\n        * 2\\. Run Nav2 stack\n      * How it works\n    * Camera Calibration\n      * Overview\n      * Requirements\n      * Tutorial Steps\n    * Get Backtrace in ROS 2 / Nav2\n      * Overview\n      * Preliminaries\n      * From a Node\n      * From a Launch File\n      * From Large Project\n      * From Nav2 Bringup\n      * Automatic backtrace on crash\n    * Profiling in ROS 2 / Nav2\n      * Overview\n      * Preliminaries\n      * Profile from a Node\n      * Profile from a Launch File\n      * From Nav2 Bringup\n      * Interpreting Results\n    * Docker for Development: Zero to Hero\n      * Overview\n      * Preliminaries\n      * Important Docker Commands\n      * Exploring Your First Container\n      * Understanding ROS Docker Images\n      * For Docker-Based Development\n        * Building a Development Image\n        * Visualizations from Docker\n      * For Docker-Based Deployment\n      * Conclusion\n      * Appendix\n        * Nav2 Development Image\n        * Nav2 Deployment Image\n  * Plugin Tutorials\n    * Writing a New Costmap2D Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Write a new Costmap2D plugin\n        * 2- Export and make GradientLayer plugin\n        * 3- Enable the plugin in Costmap2D\n        * 4- Run GradientLayer plugin\n    * Writing a New Planner Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new Planner Plugin\n        * 2- Exporting the planner plugin\n        * 3- Pass the plugin name through params file\n        * 4- Run StraightLine plugin\n    * Writing a New Controller Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Create a new Controller Plugin\n        * 2- Exporting the controller plugin\n        * 3- Pass the plugin name through the params file\n        * 4- Run Pure Pursuit Controller plugin\n    * Writing a New Behavior Tree Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new BT Plugin\n        * 2- Exporting the planner plugin\n        * 3- Add plugin library name to config\n        * 4- Run Your Custom plugin\n    * Writing a New Behavior Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new Behavior Plugin\n        * 2- Exporting the Behavior Plugin\n        * 3- Pass the plugin name through params file\n        * 4- Run Behavior Plugin\n    * Writing a New Navigator Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Create a new Navigator Plugin\n        * 2- Exporting the navigator plugin\n        * 3- Pass the plugin name through the params file\n        * 4- Run plugin\n  * Configuration Guide\n    * Behavior-Tree Navigator\n      * Parameters\n      * Example\n    * Behavior Tree XML Nodes\n      * Action Plugins\n        * Wait\n        * Spin\n        * BackUp\n        * DriveOnHeading\n        * AssistedTeleop\n        * ComputePathToPose\n        * FollowPath\n        * NavigateToPose\n        * ClearEntireCostmap\n        * ClearCostmapExceptRegion\n        * ClearCostmapAroundRobot\n        * ReinitializeGlobalLocalization\n        * TruncatePath\n        * TruncatePathLocal\n        * PlannerSelector\n        * ControllerSelector\n        * SmootherSelector\n        * GoalCheckerSelector\n        * ProgressCheckerSelector\n        * NavigateThroughPoses\n        * ComputePathThroughPoses\n        * ComputeCoveragePath\n        * CancelCoverage\n        * RemovePassedGoals\n        * RemoveInCollisionGoals\n        * CancelControl\n        * CancelBackUp\n        * CancelSpin\n        * CancelWait\n        * CancelDriveOnHeading\n        * CancelAssistedTeleop\n        * SmoothPath\n        * GetPoseFromPath\n        * DockRobot\n        * UndockRobot\n      * Condition Plugins\n        * GoalReached\n        * TransformAvailable\n        * DistanceTraveled\n        * GoalUpdated\n        * GloballyUpdatedGoal\n        * InitialPoseReceived\n        * IsStuck\n        * IsStopped\n        * TimeExpired\n        * IsBatteryLow\n        * IsPathValid\n        * PathExpiringTimer\n        * AreErrorCodesPresent\n        * WouldAControllerRecoveryHelp\n        * WouldAPlannerRecoveryHelp\n        * WouldASmootherRecoveryHelp\n        * IsBatteryCharging\n      * Control Plugins\n        * PipelineSequence\n        * RoundRobin\n        * RecoveryNode\n      * Decorator Plugins\n        * RateController\n        * DistanceController\n        * SpeedController\n        * GoalUpdater\n        * PathLongerOnApproach\n        * SingleTrigger\n      * Example\n    * Costmap 2D\n      * Costmap2D ROS Parameters\n      * Default Plugins\n      * Plugin Parameters\n        * Static Layer Parameters\n        * Inflation Layer Parameters\n        * Obstacle Layer Parameters\n        * Voxel Layer Parameters\n        * Range Sensor Parameters\n        * Denoise Layer Parameters\n      * Costmap Filters Parameters\n        * Keepout Filter Parameters\n        * Speed Filter Parameters\n        * Binary Filter Parameters\n      * Example\n    * Lifecycle Manager\n      * Parameters\n      * Example\n    * Planner Server\n      * Parameters\n      * Default Plugins\n      * Example\n    * Coverage Server\n      * Parameters\n      * Example\n    * NavFn Planner\n      * Parameters\n      * Example\n    * Smac Planner\n      * Provided Plugins\n        * Smac 2D Planner\n        * Smac Hybrid-A* Planner\n        * Smac State Lattice Planner\n      * Description\n    * Theta Star Planner\n      * Parameters\n      * Example\n    * Controller Server\n      * Parameters\n      * Provided Plugins\n        * SimpleProgressChecker\n        * PoseProgressChecker\n        * SimpleGoalChecker\n        * StoppedGoalChecker\n      * Default Plugins\n      * Example\n    * DWB Controller\n      * Controller\n        * DWB Controller\n        * XYTheta Iterator\n        * Kinematic Parameters\n        * Publisher\n      * Plugins\n        * LimitedAccelGenerator\n        * StandardTrajectoryGenerator\n      * Trajectory Critics\n        * BaseObstacleCritic\n        * GoalAlignCritic\n        * GoalDistCritic\n        * ObstacleFootprintCritic\n        * OscillationCritic\n        * PathAlignCritic\n        * PathDistCritic\n        * PreferForwardCritic\n        * RotateToGoalCritic\n        * TwirlingCritic\n      * Example\n    * Regulated Pure Pursuit\n      * Regulated Pure Pursuit Parameters\n      * Example\n    * Model Predictive Path Integral Controller\n      * MPPI Parameters\n        * Trajectory Visualization\n        * Path Handler\n        * Ackermann Motion Model\n        * Constraint Critic\n        * Goal Angle Critic\n        * Goal Critic\n        * Obstacles Critic\n        * Cost Critic\n        * Path Align Critic\n        * Path Angle Critic\n        * Path Follow Critic\n        * Prefer Forward Critic\n        * Twirling Critic\n        * Velocity Deadband Critic\n      * Example\n      * Notes to Users\n        * General Words of Wisdom\n        * Prediction Horizon, Costmap Sizing, and Offsets\n        * Obstacle, Inflation Layer, and Path Following\n    * Rotation Shim Controller\n      * Rotation Shim Controller Parameters\n      * Example\n    * Graceful Controller\n      * Graceful Controller Parameters\n      * Example\n    * Map Server / Saver\n      * Map Saver Parameters\n      * Map Server Parameters\n      * Costmap Filter Info Server Parameters\n      * Example\n    * AMCL\n      * Parameters\n      * Example\n    * Behavior Server\n      * Behavior Server Parameters\n      * Default Plugins\n      * Spin Behavior Parameters\n      * BackUp Behavior Parameters\n      * DriveOnHeading Behavior Parameters\n      * AssistedTeleop Behavior Parameters\n      * Example\n    * Smoother Server\n      * Smoother Server Parameters\n      * Example\n    * Simple Smoother\n      * Simple Smoother Parameters\n      * Example\n    * Savitzky-Golay Smoother\n      * Savitzky-Golay Smoother Parameters\n      * Example\n    * Constrained smoother\n      * Smoother Server Parameters\n      * Example\n    * Velocity Smoother\n      * Velocity Smoother Parameters\n      * Example\n    * Collision Monitor\n      * Provided Nodes\n        * Collision Monitor Node\n        * Collision Detector Node\n    * Waypoint Follower\n      * Parameters\n      * Provided Plugins\n        * WaitAtWaypoint\n        * PhotoAtWaypoint\n        * InputAtWaypoint\n      * Default Plugin\n      * Example\n    * Loopback Simulator\n      * Parameters\n      * Example\n    * Docking Server\n      * Parameters\n      * SimpleChargingDock Parameters\n      * Example\n  * Tuning Guide\n    * Inflation Potential Fields\n    * Robot Footprint vs Radius\n    * Rotate in Place Behavior\n    * Planner Plugin Selection\n    * Controller Plugin Selection\n    * Caching Obstacle Heuristic in Smac Planners\n    * Costmap2D Plugins\n    * Nav2 Launch Options\n    * Other Pages We\u2019d Love To Offer\n  * Nav2 Behavior Trees\n    * Introduction To Nav2 Specific Nodes\n      * Action Nodes\n      * Condition Nodes\n      * Decorator Nodes\n      * Control: PipelineSequence\n      * Control: Recovery\n      * Control: RoundRobin\n    * Detailed Behavior Tree Walkthrough\n      * Overview\n      * Prerequisites\n      * Navigate To Pose With Replanning and Recovery\n      * Navigation Subtree\n      * Recovery Subtree\n    * Navigate To Pose\n    * Navigate Through Poses\n    * Navigate To Pose and Pause Near Goal-Obstacle\n    * Navigate To Pose With Consistent Replanning And If Path Becomes Invalid\n    * Follow Dynamic Point\n    * Odometry Calibration\n  * Navigation Plugins\n    * Behavior-Tree Navigators\n    * Costmap Layers\n    * Costmap Filters\n    * Controllers\n    * Planners\n    * Smoothers\n    * Behaviors\n    * Waypoint Task Executors\n    * Goal Checkers\n    * Progress Checkers\n    * Behavior Tree Nodes\n  * Migration Guides\n    * Dashing to Eloquent\n      * New Packages\n      * New Plugins\n      * Navigation2 Architectural Changes\n    * Eloquent to Foxy\n      * General\n      * Server Updates\n      * New Plugins\n      * Map Server Re-Work\n      * New Particle Filter Messages\n      * Selection of Behavior Tree in each navigation action\n      * FollowPoint Capability\n      * New Costmap Layer\n    * Foxy to Galactic\n      * NavigateToPose Action Feedback updates\n      * NavigateToPose BT-node Interface Changes\n      * NavigateThroughPoses and ComputePathThroughPoses Actions Added\n      * ComputePathToPose BT-node Interface Changes\n      * ComputePathToPose Action Interface Changes\n      * BackUp BT-node Interface Changes\n      * BackUp Recovery Interface Changes\n      * Nav2 Controllers and Goal Checker Plugin Interface Changes\n      * FollowPath goal_checker_id attribute\n      * Groot Support\n      * New Plugins\n      * Costmap Filters\n      * SmacPlanner\n      * ThetaStarPlanner\n      * RegulatedPurePursuitController\n      * Costmap2D `current_` Usage\n      * Standard time units in parameters\n      * Ray Tracing Parameters\n      * Obstacle Marking Parameters\n      * Recovery Action Changes\n      * Default Behavior Tree Changes\n      * NavFn Planner Parameters\n      * New ClearCostmapExceptRegion and ClearCostmapAroundRobot BT-nodes\n      * New Behavior Tree Nodes\n      * sensor_msgs/PointCloud to sensor_msgs/PointCloud2 Change\n      * ControllerServer New Parameter failure_tolerance\n      * Removed BT XML Launch Configurations\n      * Nav2 RViz Panel Action Feedback Information\n    * Galactic to Humble\n      * Major improvements to Smac Planners\n      * Simple (Python) Commander\n      * Reduce Nodes and Executors\n      * API Change for nav2_core\n      * Extending the BtServiceNode to process Service-Results\n      * Including new Rotation Shim Controller Plugin\n      * Spawning the robot in Gazebo\n      * Recovery Behavior Timeout\n      * New parameter `use_final_approach_orientation` for the 3 2D planners\n      * SmacPlanner2D and Theta*: fix goal orientation being ignored\n      * SmacPlanner2D, NavFn and Theta*: fix small path corner cases\n      * Change and fix behavior of dynamic parameter change detection\n      * Dynamic Parameters\n      * BT Action Nodes Exception Changes\n      * BT Navigator Groot Multiple Navigators\n      * Removed Kinematic Limiting in RPP\n      * Added Smoother Task Server\n      * Removed Use Approach Velocity Scaling Param in RPP\n      * Refactored AMCL motion models as plugins\n      * Dropping Support for Live Groot Monitoring of Nav2\n      * Replanning Only if Path is Invalid\n      * Fix CostmapLayer clearArea invert param logic\n      * Dynamic Composition\n      * BT Cancel Node\n      * BT PathLongerOnApproach Node\n      * BT TruncatePathLocal Node\n      * Constrained Smoother\n      * Replanning at a Constant Rate and if the Path is Invalid\n      * Euclidean Distance 2D\n      * Recovery To Behavior\n      * Respawn Support in Launch and Lifecycle Manager\n      * New Nav2 Velocity Smoother\n      * Goal Checker API Changed\n      * Added Assisted Teleop\n    * Humble to Iron\n      * New Behavior-Tree Navigator Plugins\n      * Added Collision Monitor\n      * Removed use_sim_time from yaml\n      * Run-time Speed up of Smac Planner\n      * Recursive Refinement of Smac and Simple Smoothers\n      * Simple Commander Python API\n      * Smac Planner Start Pose Included in Path\n      * Parameterizable Collision Checking in RPP\n      * Expanded Planner Benchmark Tests\n      * Smac Planner Path Tolerances\n      * costmap_2d_node default constructor\n      * Feedback for Navigation Failures\n      * Costmap Filters\n      * Savitzky-Golay Smoother\n      * Changes to Map yaml file path for map_server node in Launch\n      * SmootherSelector BT Node\n      * Publish Costmap Layers\n      * Give Behavior Server Access to Both Costmaps\n      * New Model Predictive Path Integral Controller\n      * Behavior Tree Uses Error Codes\n      * Load, Save and Loop Waypoints from the Nav2 Panel in RViz\n      * DWB Forward vs Reverse Pruning\n      * More stable regulation on curves for long lookahead distances\n      * Publish Collision Monitor State\n      * Renamed ROS-parameter in Collision Monitor\n      * New safety behavior model \u201climit\u201d in Collision Monitor\n      * Velocity smoother applies deceleration when timeout\n      * PoseProgressChecker plugin\n      * Allow multiple goal checkers and change parameter progress_checker_plugin(s) name and type\n      * IsBatteryChargingCondition BT Node\n      * Behavior Server Error Codes\n      * New Denoise Costmap Layer Plugin\n      * SmacPlannerHybrid viz_expansions parameter\n    * Iron to Jazzy\n      * BehaviorTree.CPP upgraded to version 4.5+\n      * Added TwistStamped Option for Commands\n      * Add VelocityPolygon in Collision Monitor\n      * Change polygon points parameter format in Collision Monitor\n      * Introduction of Soft-Real Time Action Servers\n      * `opennav_coverage` Project\n      * `opennav_docking` Project\n      * Introduce a new Multi-Robot Bringup Launch\n      * New option for the Voxel and Obstacle Layers\n      * use_interpolation RPP Parameter Depreciated\n      * Changes to MPPI Goal Critic\n      * Changes to MPPI Path Angle Critic\n      * Changes to MPPI Path Handling For Directionality\n      * Addition of new MPPI Cost Critic\n      * MPPI Acceleration\n      * Move Error Code Enumerations\n      * Substitution in parameter file\n      * Allow Behavior Server Plugins to Access The Action Result\n      * Smac Planner Debug Param Name Change\n      * Smac Planner On Approach to Goal Shortcutting Solutions\n      * Added GPS Waypoint Follower Server\n      * Smac Planner Hybrid-A* New Features\n      * New node in nav2_collision_monitor: Collision Detector\n      * Dynamic enabling/disabling of sources/polygons in Collision Monitor/Detector\n      * Expose action server\u2019s result timeout\n      * RewrittenYaml could add new parameters to YAMLs\n      * Simple Commander API Allows Multi-Robot Namespacing\n      * Change duration type in wait_action node\n      * The costmap activation fails when required transforms are not available\n      * Subtrees Obtain Shared Resources\n      * Collision Monitor: added watchdog mechanism based on `source_timeout` parameter with default blocking behavior\n      * BtActionServer: use native library haltTree()\n      * Global Frame Removed from 2 BT Nodes\n      * Introduction of `CostmapUpdate.msg`\n      * Full Stack Uses Node Clocks\n      * New Graceful Motion Controller\n      * Plugin Libraries in BT Navigator Only Includes Custom Nodes\n      * New RViz Plugin for selecting Planners, Controllers, Goal Checkers, Progress Checkers and Smoothers\n      * RPP new optional `interpolate_curvature_after_goal` behavior and fix conflict between `use_rotate_to_heading` and `allow_reversing`\n      * Cancel Checker Interface For GlobalPlanner\n      * New BtActionServer/BtNavigator parameter\n      * New collision monitor parameter\n      * New graceful cancellation API for Controllers\n      * Standardization of Plugin Naming with Double Colons (::)\n      * Collision monitor: dynamic radius for circle type polygons\n      * Static Layer: new parameter `footprint_clearing_enabled`\n      * Lifecycle Node: added bond_heartbeat_period parameter (and allow disabling the bond mechanism)\n      * Rotation Shim Controller: new parameter `rotate_to_goal_heading`\n      * MPPI Controller: Addition of acceleration constraints\n      * RegulatedPurePursuit Controller [RPP]: new parameter `use_cancel_deceleration`\n    * Jazzy to K-Turtle\n      * TwistStamped Default CmdVel Change\n      * New Nav2 Loopback Simulator\n      * Docking with Static Infrastructure or Dynamic Docking\n      * New RViz panel for Docking\n      * New BT Nodes\n      * New RViz Tool for Costmap Cost Cell Inspection\n      * Fix flickering visualization\n      * Option to limit velocity through DWB trajectory\n      * Option to disable zero velocity publishing on goal exit\n      * Added optional collision checking for the Docking Server\n      * Revamped multirobot bringup and config files to use namespaces\n      * Removed global map_topic from Costmap node\n      * Simplified Costmap2DROS constructors\n  * Simple Commander API\n    * Overview\n    * Commander API\n    * Costmap API\n    * Footprint Collision Checker API\n    * Examples and Demos\n  * Roadmaps\n    * Jazzy Roadmap\n    * Iron Roadmap\n    * Humble Roadmap\n  * About and Contact\n    * Related Projects\n    * About\n    * Contact\n\n__Nav2\n\nEdit\n\n  *   * Development Guides\n  * Build and Install\n  * \n\n* * *\n\n# Build and Install\uf0c1\n\n## Install\uf0c1\n\nNav2 and its dependencies are released as binaries. You may install it via the\nfollowing to get the latest stable released version:\n\n### For Iron and Older\uf0c1\n\n    \n    \n    source /opt/ros/<distro>/setup.bash\n    sudo apt install \\\n      ros-$ROS_DISTRO-navigation2 \\\n      ros-$ROS_DISTRO-nav2-bringup \\\n      ros-$ROS_DISTRO-turtlebot3*\n    \n\n### For Jazzy and Newer\uf0c1\n\n    \n    \n    source /opt/ros/<distro>/setup.bash\n    sudo apt install \\\n      ros-$ROS_DISTRO-navigation2 \\\n      ros-$ROS_DISTRO-nav2-bringup \\\n      ros-$ROS_DISTRO-nav2-minimal-tb*\n    \n\n## Build\uf0c1\n\nThere are a few ways to build Nav2 using:\n\n  * Released Distribution Binaries\n\n    * Build Nav2 using readily installable binary dependencies\n\n  * Rolling Development Source\n\n    * Build Nav2 using custom or latest source dependencies\n\n  * Docker Container Images\n\n    * Build Nav2 using cached images and templated Dockerfiles\n\nTip\n\nFor a _repeatable_ , _reproducible_ and _streamlined_ development experience,\ncheck the Nav2 documentation on using Dev Containers!\n\n### Released Distribution Binaries\uf0c1\n\nTo build Nav2, you\u2019ll first need to build or install ROS 2 and related\ndevelopment tools, including: `colcon`, `rosdep` and `vcstool`.\n\nSee also\n\nFor more information on building or installing ROS 2 distros, see the official\ndocumentation:\n\n  * ROS 2 Installation\n\n  * Install development tools and ROS tools\n\nOnce your environment is setup, clone the repo, install all dependencies, and\nbuild the workspace:\n\nAttention\n\nThe branch naming schema for Nav2 is organized by ROS distro, while the\ndefault branch for Rolling is `main`.\n\n    \n    \n    source /opt/ros/<distro>/setup.bash\n    mkdir -p ~/nav2_ws/src && cd ~/nav2_ws\n    git clone https://github.com/ros-navigation/navigation2.git --branch $ROS_DISTRO ./src/navigation2\n    rosdep install -y \\\n      --from-paths ./src \\\n      --ignore-src\n    colcon build \\\n      --symlink-install\n    \n\nYou can then `source ~/nav2_ws/install/setup.bash` to get ready for\ndemonstrations!\n\nHint\n\nFor more examples on building Nav2 from released distribution binaries,\ncheckout distro.Dockerfile.\n\n### Rolling Development Source\uf0c1\n\nBuilding Nav2 using rolling development source is similar to building Nav2\nfrom released distribution binaries, where instead you build dependencies from\nsource using the main development branches for all ROS based packages. Nav2\ndoes not currently release binaries on rolling, so it must be build from\nsource.\n\nSee also\n\nFor more information on building ROS 2 from source, see the official\ndocumentation:\n\n  * ROS 2 Building from source\n\nOnce your environment is setup, clone the repo and build the workspace:\n\n    \n    \n    source <ros_ws>/install/setup.bash\n    mkdir -p ~/nav2_ws/src && cd ~/nav2_ws\n    git clone https://github.com/ros-navigation/navigation2.git --branch main ./src/navigation2\n    git clone https://github.com/ros-navigation/nav2_minimal_turtlebot_simulation.git --branch main ./src/nav2_minimal_turtlebot_simulation\n    rosdep install -r -y \\\n      --from-paths ./src \\\n      --ignore-src\n    colcon build \\\n      --symlink-install\n    \n\nYou can then `source ~/nav2_ws/install/setup.bash` to get ready for\ndemonstrations! It is safe to ignore the rosdep error of from the missing\n`slam_toolbox` key.\n\nHint\n\nFor more examples on building Nav2 from rolling development source, checkout\nsource.Dockerfile.\n\n### Docker Container Images\uf0c1\n\nBuilding Nav2 using Docker container images provides a repeatable and\nreproducible environment to automate and self document the entire setup\nprocess. Instead of manually invoking the development tools as documented\nabove, you can leverage the project\u2019s Dockerfiles to build and install Nav2\nfor various distributions.\n\nSee also\n\nFor more information on installing Docker or leaning about Dockerfiles, see\nthe official documentation:\n\n  * Docker Engine\n\n  * Dockerfile reference\n\nOnce your system is setup, you can build the Nav2 Dockerfile from the root of\nthe repo:\n\n    \n    \n    export ROS_DISTRO=rolling\n    git clone https://github.com/ros-navigation/navigation2.git --branch main\n    docker build --tag navigation2:$ROS_DISTRO \\\n      --build-arg FROM_IMAGE=ros:$ROS_DISTRO \\\n      --build-arg OVERLAY_MIXINS=\"release ccache lld\" \\\n      --cache-from ghcr.io/ros-navigation/navigation2:main \\\n      ./navigation2\n    \n\nThe docker build command above creates a tagged image using the Dockerfile\nfrom the context specified using the path to the repo, where build-time\nvariables are set using additional arguments, e.g. passing a set of colcon\nmixins to configure the workspace build. Check the `ARG` directives in the\nDockerfile to discover all build-time variables available. The command also\nspecifies an external cache source to pull the latest cached image from Nav2\u2019s\nContainer Registry to speed up the build process.\n\nTip\n\nThe images cached from above are used for Nav2 CI, but can also be used with\nNav2 Dev Containers!\n\n* * *\n\n## Generate Doxygen\uf0c1\n\nRun `doxygen` in the root of the Nav2 repository. It will generate a `/doc/*`\ndirectory containing the documentation. The documentation entrypoint in a\nbrowser is index.html.\n\n* * *\n\n## Help\uf0c1\n\nBuild Troubleshooting Guide\n\n* * *\n\n(C) Copyright 2023.\n\n",
                "language": "en"
            },
            "platform": "docs.nav2.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://docs.nav2.org/development_guides/build_docs/index.html"
        },
        {
            "id": "2631e8dd-87f1-4021-b306-4e4296958e3f",
            "content": {
                "Title": "Navigation Concepts \u2014 Nav2 1.0.0 documentation",
                "Subtitle": null,
                "Content": "Nav2\n\nlatest\n\n  * Getting Started\n    * Installation\n    * Running the Example\n    * Navigating\n  * Development Guides\n    * Build and Install\n      * Install\n        * For Iron and Older\n        * For Jazzy and Newer\n      * Build\n        * Released Distribution Binaries\n        * Rolling Development Source\n        * Docker Container Images\n      * Generate Doxygen\n      * Help\n        * Build Troubleshooting Guide\n    * Dev Containers\n      * Dev Container Guide\n        * Creating Dev Containers\n        * Using Dev Containers\n      * What, Why, How?\n        * What is a Dev Container?\n        * Why use a Dev Container?\n        * How do Dev Containers work?\n      * Prerequisites\n      * Getting started\n      * Security\n    * Getting Involved\n      * Getting Involved\n      * Process\n      * Licensing\n      * Developer Certification of Origin (DCO)\n  * Navigation Concepts\n    * ROS 2\n      * Action Server\n      * Lifecycle Nodes and Bond\n    * Behavior Trees\n    * Navigation Servers\n      * Planner, Controller, Smoother and Recovery Servers\n      * Planners\n      * Controllers\n      * Behaviors\n      * Smoothers\n      * Robot Footprints\n      * Waypoint Following\n    * State Estimation\n      * Standards\n      * Global Positioning: Localization and SLAM\n      * Odometry\n    * Environmental Representation\n      * Costmaps and Layers\n      * Costmap Filters\n      * Other Forms\n    * Nav2 Academic Overview\n  * First-Time Robot Setup Guide\n    * Setting Up Transformations\n      * Transforms Introduction\n      * Static Transform Publisher Demo\n      * Transforms in Navigation2\n      * Conclusion\n    * Setting Up The URDF\n      * URDF and the Robot State Publisher\n      * Setting Up the Environment\n      * Writing the URDF\n      * Build and Launch\n      * Visualization using RVIZ\n      * Adding Physical Properties\n      * Conclusion\n    * Setting Up Odometry\n      * Odometry Introduction\n      * Setting Up Odometry on your Robot\n      * Simulating an Odometry System using Gazebo\n        * Setup and Prerequisites\n        * Adding Gazebo Plugins to a URDF\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Robot Localization Demo\n        * Configuring Robot Localization\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Conclusion\n    * Setting Up Sensors\n      * Sensor Introduction\n        * Common Sensor Messages\n      * Simulating Sensors using Gazebo\n        * Adding Gazebo Plugins to a URDF\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Mapping and Localization\n      * Costmap 2D\n        * Configuring nav2_costmap_2d\n        * Build, Run and Verification\n      * Conclusion\n    * Setting Up the Robot\u2019s Footprint\n      * Footprint Introduction\n      * Configuring the Robot\u2019s Footprint\n      * Build, Run and Verification\n      * Visualizing Footprint in RViz\n      * Conclusion\n    * Setting Up Navigation Plugins\n      * Planner and Controller Servers\n      * Selecting the Algorithm Plugins\n        * Planner Server\n        * Controller Server\n      * Conclusion\n  * Robots Using\n  * General Tutorials\n    * Navigating with a Physical Turtlebot 3\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Setup Your Environment Variables\n        * 1- Launch Turtlebot 3\n        * 2- Launch Nav2\n        * 3- Launch RVIZ\n        * 4- Initialize the Location of Turtlebot 3\n        * 5- Send a Goal Pose\n    * (SLAM) Navigating While Mapping\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Launch Robot Interfaces\n        * 1- Launch Navigation2\n        * 2- Launch SLAM\n        * 3- Working with SLAM\n        * 4- Getting Started Simplification\n    * (STVL) Using an External Costmap Plugin\n      * Overview\n      * Costmap2D and STVL\n      * Tutorial Steps\n        * 0- Setup\n        * 1- Install STVL\n        * 1- Modify Navigation2 Parameter\n        * 2- Launch Navigation2\n        * 3- RVIZ\n    * Navigating Using GPS Localization\n      * Overview\n      * Requirements\n      * GPS Localization Overview\n      * Tutorial Steps\n        * 0- Setup Gazebo World\n        * 1- Setup GPS Localization system\n        * 2- Setup Navigation system\n        * 3- Interactive GPS Waypoint Follower\n        * 4- Logged GPS Waypoint Follower & Waypoint Logging\n      * Conclusion\n    * Groot - Interacting with Behavior Trees\n      * Overview\n      * Visualize Behavior Trees\n      * Edit Behavior Trees\n      * Adding A Custom Node\n    * Using VIO to Augment Robot Odometry\n      * Overview\n      * Setting Up the ZED X Camera\n      * Setting Up ZED ROS\n      * Fusing VIO Into Local State Estimate\n        * Fusing VSLAM Into Global State Estimate\n      * Testing it Out!\n    * Dynamic Object Following\n      * Overview\n      * Tutorial Steps\n        * 0- Create the Behavior Tree\n        * 1- Setup Rviz clicked point\n        * 2- Run Dynamic Object Following in Nav2 Simulation\n    * Navigating with Keepout Zones\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Prepare filter mask\n        * 2\\. Configure Costmap Filter Info Publisher Server\n        * 3\\. Enable Keepout Filter\n        * 4\\. Run Nav2 stack\n    * Navigating with Speed Limits\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Prepare filter mask\n        * 2\\. Configure Costmap Filter Info Publisher Server\n        * 3\\. Enable Speed Filter\n        * 4\\. Run Nav2 stack\n    * Using Docking Server\n      * Overview\n      * Requirements\n      * ChargingDock Plugins\n      * Dock Database\n      * Configuring Docking Server\n      * Adding Docking Server to Launch\n      * Docking Action API\n      * Putting It All Together\n    * Using Rotation Shim Controller\n      * Overview\n      * What is the Rotation Shim Controller?\n      * Configuring Rotation Shim Controller\n      * Configuring Primary Controller\n      * Demo Execution\n    * Adding a Smoother to a BT\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Familiarization with the Smoother BT Node\n        * 1- Specifying a Smoother Plugin\n        * 2- Modifying your BT XML\n    * Using Collision Monitor\n      * Overview\n      * Requirements\n      * Configuring Collision Monitor\n      * Configuring Collision Monitor with VelocityPolygon\n      * Preparing Nav2 stack\n      * Demo Execution\n    * Adding a New Nav2 Task Server\n      * Lifecycle Nodes\n      * Composition\n      * Error codes\n      * Conclusion\n    * Filtering of Noise-Induced Obstacles\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Enable Denoise Layer\n        * 2\\. Run Nav2 stack\n      * How it works\n    * Camera Calibration\n      * Overview\n      * Requirements\n      * Tutorial Steps\n    * Get Backtrace in ROS 2 / Nav2\n      * Overview\n      * Preliminaries\n      * From a Node\n      * From a Launch File\n      * From Large Project\n      * From Nav2 Bringup\n      * Automatic backtrace on crash\n    * Profiling in ROS 2 / Nav2\n      * Overview\n      * Preliminaries\n      * Profile from a Node\n      * Profile from a Launch File\n      * From Nav2 Bringup\n      * Interpreting Results\n    * Docker for Development: Zero to Hero\n      * Overview\n      * Preliminaries\n      * Important Docker Commands\n      * Exploring Your First Container\n      * Understanding ROS Docker Images\n      * For Docker-Based Development\n        * Building a Development Image\n        * Visualizations from Docker\n      * For Docker-Based Deployment\n      * Conclusion\n      * Appendix\n        * Nav2 Development Image\n        * Nav2 Deployment Image\n  * Plugin Tutorials\n    * Writing a New Costmap2D Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Write a new Costmap2D plugin\n        * 2- Export and make GradientLayer plugin\n        * 3- Enable the plugin in Costmap2D\n        * 4- Run GradientLayer plugin\n    * Writing a New Planner Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new Planner Plugin\n        * 2- Exporting the planner plugin\n        * 3- Pass the plugin name through params file\n        * 4- Run StraightLine plugin\n    * Writing a New Controller Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Create a new Controller Plugin\n        * 2- Exporting the controller plugin\n        * 3- Pass the plugin name through the params file\n        * 4- Run Pure Pursuit Controller plugin\n    * Writing a New Behavior Tree Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new BT Plugin\n        * 2- Exporting the planner plugin\n        * 3- Add plugin library name to config\n        * 4- Run Your Custom plugin\n    * Writing a New Behavior Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new Behavior Plugin\n        * 2- Exporting the Behavior Plugin\n        * 3- Pass the plugin name through params file\n        * 4- Run Behavior Plugin\n    * Writing a New Navigator Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Create a new Navigator Plugin\n        * 2- Exporting the navigator plugin\n        * 3- Pass the plugin name through the params file\n        * 4- Run plugin\n  * Configuration Guide\n    * Behavior-Tree Navigator\n      * Parameters\n      * Example\n    * Behavior Tree XML Nodes\n      * Action Plugins\n        * Wait\n        * Spin\n        * BackUp\n        * DriveOnHeading\n        * AssistedTeleop\n        * ComputePathToPose\n        * FollowPath\n        * NavigateToPose\n        * ClearEntireCostmap\n        * ClearCostmapExceptRegion\n        * ClearCostmapAroundRobot\n        * ReinitializeGlobalLocalization\n        * TruncatePath\n        * TruncatePathLocal\n        * PlannerSelector\n        * ControllerSelector\n        * SmootherSelector\n        * GoalCheckerSelector\n        * ProgressCheckerSelector\n        * NavigateThroughPoses\n        * ComputePathThroughPoses\n        * ComputeCoveragePath\n        * CancelCoverage\n        * RemovePassedGoals\n        * RemoveInCollisionGoals\n        * CancelControl\n        * CancelBackUp\n        * CancelSpin\n        * CancelWait\n        * CancelDriveOnHeading\n        * CancelAssistedTeleop\n        * SmoothPath\n        * GetPoseFromPath\n        * DockRobot\n        * UndockRobot\n      * Condition Plugins\n        * GoalReached\n        * TransformAvailable\n        * DistanceTraveled\n        * GoalUpdated\n        * GloballyUpdatedGoal\n        * InitialPoseReceived\n        * IsStuck\n        * IsStopped\n        * TimeExpired\n        * IsBatteryLow\n        * IsPathValid\n        * PathExpiringTimer\n        * AreErrorCodesPresent\n        * WouldAControllerRecoveryHelp\n        * WouldAPlannerRecoveryHelp\n        * WouldASmootherRecoveryHelp\n        * IsBatteryCharging\n      * Control Plugins\n        * PipelineSequence\n        * RoundRobin\n        * RecoveryNode\n      * Decorator Plugins\n        * RateController\n        * DistanceController\n        * SpeedController\n        * GoalUpdater\n        * PathLongerOnApproach\n        * SingleTrigger\n      * Example\n    * Costmap 2D\n      * Costmap2D ROS Parameters\n      * Default Plugins\n      * Plugin Parameters\n        * Static Layer Parameters\n        * Inflation Layer Parameters\n        * Obstacle Layer Parameters\n        * Voxel Layer Parameters\n        * Range Sensor Parameters\n        * Denoise Layer Parameters\n      * Costmap Filters Parameters\n        * Keepout Filter Parameters\n        * Speed Filter Parameters\n        * Binary Filter Parameters\n      * Example\n    * Lifecycle Manager\n      * Parameters\n      * Example\n    * Planner Server\n      * Parameters\n      * Default Plugins\n      * Example\n    * Coverage Server\n      * Parameters\n      * Example\n    * NavFn Planner\n      * Parameters\n      * Example\n    * Smac Planner\n      * Provided Plugins\n        * Smac 2D Planner\n        * Smac Hybrid-A* Planner\n        * Smac State Lattice Planner\n      * Description\n    * Theta Star Planner\n      * Parameters\n      * Example\n    * Controller Server\n      * Parameters\n      * Provided Plugins\n        * SimpleProgressChecker\n        * PoseProgressChecker\n        * SimpleGoalChecker\n        * StoppedGoalChecker\n      * Default Plugins\n      * Example\n    * DWB Controller\n      * Controller\n        * DWB Controller\n        * XYTheta Iterator\n        * Kinematic Parameters\n        * Publisher\n      * Plugins\n        * LimitedAccelGenerator\n        * StandardTrajectoryGenerator\n      * Trajectory Critics\n        * BaseObstacleCritic\n        * GoalAlignCritic\n        * GoalDistCritic\n        * ObstacleFootprintCritic\n        * OscillationCritic\n        * PathAlignCritic\n        * PathDistCritic\n        * PreferForwardCritic\n        * RotateToGoalCritic\n        * TwirlingCritic\n      * Example\n    * Regulated Pure Pursuit\n      * Regulated Pure Pursuit Parameters\n      * Example\n    * Model Predictive Path Integral Controller\n      * MPPI Parameters\n        * Trajectory Visualization\n        * Path Handler\n        * Ackermann Motion Model\n        * Constraint Critic\n        * Goal Angle Critic\n        * Goal Critic\n        * Obstacles Critic\n        * Cost Critic\n        * Path Align Critic\n        * Path Angle Critic\n        * Path Follow Critic\n        * Prefer Forward Critic\n        * Twirling Critic\n        * Velocity Deadband Critic\n      * Example\n      * Notes to Users\n        * General Words of Wisdom\n        * Prediction Horizon, Costmap Sizing, and Offsets\n        * Obstacle, Inflation Layer, and Path Following\n    * Rotation Shim Controller\n      * Rotation Shim Controller Parameters\n      * Example\n    * Graceful Controller\n      * Graceful Controller Parameters\n      * Example\n    * Map Server / Saver\n      * Map Saver Parameters\n      * Map Server Parameters\n      * Costmap Filter Info Server Parameters\n      * Example\n    * AMCL\n      * Parameters\n      * Example\n    * Behavior Server\n      * Behavior Server Parameters\n      * Default Plugins\n      * Spin Behavior Parameters\n      * BackUp Behavior Parameters\n      * DriveOnHeading Behavior Parameters\n      * AssistedTeleop Behavior Parameters\n      * Example\n    * Smoother Server\n      * Smoother Server Parameters\n      * Example\n    * Simple Smoother\n      * Simple Smoother Parameters\n      * Example\n    * Savitzky-Golay Smoother\n      * Savitzky-Golay Smoother Parameters\n      * Example\n    * Constrained smoother\n      * Smoother Server Parameters\n      * Example\n    * Velocity Smoother\n      * Velocity Smoother Parameters\n      * Example\n    * Collision Monitor\n      * Provided Nodes\n        * Collision Monitor Node\n        * Collision Detector Node\n    * Waypoint Follower\n      * Parameters\n      * Provided Plugins\n        * WaitAtWaypoint\n        * PhotoAtWaypoint\n        * InputAtWaypoint\n      * Default Plugin\n      * Example\n    * Loopback Simulator\n      * Parameters\n      * Example\n    * Docking Server\n      * Parameters\n      * SimpleChargingDock Parameters\n      * Example\n  * Tuning Guide\n    * Inflation Potential Fields\n    * Robot Footprint vs Radius\n    * Rotate in Place Behavior\n    * Planner Plugin Selection\n    * Controller Plugin Selection\n    * Caching Obstacle Heuristic in Smac Planners\n    * Costmap2D Plugins\n    * Nav2 Launch Options\n    * Other Pages We\u2019d Love To Offer\n  * Nav2 Behavior Trees\n    * Introduction To Nav2 Specific Nodes\n      * Action Nodes\n      * Condition Nodes\n      * Decorator Nodes\n      * Control: PipelineSequence\n      * Control: Recovery\n      * Control: RoundRobin\n    * Detailed Behavior Tree Walkthrough\n      * Overview\n      * Prerequisites\n      * Navigate To Pose With Replanning and Recovery\n      * Navigation Subtree\n      * Recovery Subtree\n    * Navigate To Pose\n    * Navigate Through Poses\n    * Navigate To Pose and Pause Near Goal-Obstacle\n    * Navigate To Pose With Consistent Replanning And If Path Becomes Invalid\n    * Follow Dynamic Point\n    * Odometry Calibration\n  * Navigation Plugins\n    * Behavior-Tree Navigators\n    * Costmap Layers\n    * Costmap Filters\n    * Controllers\n    * Planners\n    * Smoothers\n    * Behaviors\n    * Waypoint Task Executors\n    * Goal Checkers\n    * Progress Checkers\n    * Behavior Tree Nodes\n  * Migration Guides\n    * Dashing to Eloquent\n      * New Packages\n      * New Plugins\n      * Navigation2 Architectural Changes\n    * Eloquent to Foxy\n      * General\n      * Server Updates\n      * New Plugins\n      * Map Server Re-Work\n      * New Particle Filter Messages\n      * Selection of Behavior Tree in each navigation action\n      * FollowPoint Capability\n      * New Costmap Layer\n    * Foxy to Galactic\n      * NavigateToPose Action Feedback updates\n      * NavigateToPose BT-node Interface Changes\n      * NavigateThroughPoses and ComputePathThroughPoses Actions Added\n      * ComputePathToPose BT-node Interface Changes\n      * ComputePathToPose Action Interface Changes\n      * BackUp BT-node Interface Changes\n      * BackUp Recovery Interface Changes\n      * Nav2 Controllers and Goal Checker Plugin Interface Changes\n      * FollowPath goal_checker_id attribute\n      * Groot Support\n      * New Plugins\n      * Costmap Filters\n      * SmacPlanner\n      * ThetaStarPlanner\n      * RegulatedPurePursuitController\n      * Costmap2D `current_` Usage\n      * Standard time units in parameters\n      * Ray Tracing Parameters\n      * Obstacle Marking Parameters\n      * Recovery Action Changes\n      * Default Behavior Tree Changes\n      * NavFn Planner Parameters\n      * New ClearCostmapExceptRegion and ClearCostmapAroundRobot BT-nodes\n      * New Behavior Tree Nodes\n      * sensor_msgs/PointCloud to sensor_msgs/PointCloud2 Change\n      * ControllerServer New Parameter failure_tolerance\n      * Removed BT XML Launch Configurations\n      * Nav2 RViz Panel Action Feedback Information\n    * Galactic to Humble\n      * Major improvements to Smac Planners\n      * Simple (Python) Commander\n      * Reduce Nodes and Executors\n      * API Change for nav2_core\n      * Extending the BtServiceNode to process Service-Results\n      * Including new Rotation Shim Controller Plugin\n      * Spawning the robot in Gazebo\n      * Recovery Behavior Timeout\n      * New parameter `use_final_approach_orientation` for the 3 2D planners\n      * SmacPlanner2D and Theta*: fix goal orientation being ignored\n      * SmacPlanner2D, NavFn and Theta*: fix small path corner cases\n      * Change and fix behavior of dynamic parameter change detection\n      * Dynamic Parameters\n      * BT Action Nodes Exception Changes\n      * BT Navigator Groot Multiple Navigators\n      * Removed Kinematic Limiting in RPP\n      * Added Smoother Task Server\n      * Removed Use Approach Velocity Scaling Param in RPP\n      * Refactored AMCL motion models as plugins\n      * Dropping Support for Live Groot Monitoring of Nav2\n      * Replanning Only if Path is Invalid\n      * Fix CostmapLayer clearArea invert param logic\n      * Dynamic Composition\n      * BT Cancel Node\n      * BT PathLongerOnApproach Node\n      * BT TruncatePathLocal Node\n      * Constrained Smoother\n      * Replanning at a Constant Rate and if the Path is Invalid\n      * Euclidean Distance 2D\n      * Recovery To Behavior\n      * Respawn Support in Launch and Lifecycle Manager\n      * New Nav2 Velocity Smoother\n      * Goal Checker API Changed\n      * Added Assisted Teleop\n    * Humble to Iron\n      * New Behavior-Tree Navigator Plugins\n      * Added Collision Monitor\n      * Removed use_sim_time from yaml\n      * Run-time Speed up of Smac Planner\n      * Recursive Refinement of Smac and Simple Smoothers\n      * Simple Commander Python API\n      * Smac Planner Start Pose Included in Path\n      * Parameterizable Collision Checking in RPP\n      * Expanded Planner Benchmark Tests\n      * Smac Planner Path Tolerances\n      * costmap_2d_node default constructor\n      * Feedback for Navigation Failures\n      * Costmap Filters\n      * Savitzky-Golay Smoother\n      * Changes to Map yaml file path for map_server node in Launch\n      * SmootherSelector BT Node\n      * Publish Costmap Layers\n      * Give Behavior Server Access to Both Costmaps\n      * New Model Predictive Path Integral Controller\n      * Behavior Tree Uses Error Codes\n      * Load, Save and Loop Waypoints from the Nav2 Panel in RViz\n      * DWB Forward vs Reverse Pruning\n      * More stable regulation on curves for long lookahead distances\n      * Publish Collision Monitor State\n      * Renamed ROS-parameter in Collision Monitor\n      * New safety behavior model \u201climit\u201d in Collision Monitor\n      * Velocity smoother applies deceleration when timeout\n      * PoseProgressChecker plugin\n      * Allow multiple goal checkers and change parameter progress_checker_plugin(s) name and type\n      * IsBatteryChargingCondition BT Node\n      * Behavior Server Error Codes\n      * New Denoise Costmap Layer Plugin\n      * SmacPlannerHybrid viz_expansions parameter\n    * Iron to Jazzy\n      * BehaviorTree.CPP upgraded to version 4.5+\n      * Added TwistStamped Option for Commands\n      * Add VelocityPolygon in Collision Monitor\n      * Change polygon points parameter format in Collision Monitor\n      * Introduction of Soft-Real Time Action Servers\n      * `opennav_coverage` Project\n      * `opennav_docking` Project\n      * Introduce a new Multi-Robot Bringup Launch\n      * New option for the Voxel and Obstacle Layers\n      * use_interpolation RPP Parameter Depreciated\n      * Changes to MPPI Goal Critic\n      * Changes to MPPI Path Angle Critic\n      * Changes to MPPI Path Handling For Directionality\n      * Addition of new MPPI Cost Critic\n      * MPPI Acceleration\n      * Move Error Code Enumerations\n      * Substitution in parameter file\n      * Allow Behavior Server Plugins to Access The Action Result\n      * Smac Planner Debug Param Name Change\n      * Smac Planner On Approach to Goal Shortcutting Solutions\n      * Added GPS Waypoint Follower Server\n      * Smac Planner Hybrid-A* New Features\n      * New node in nav2_collision_monitor: Collision Detector\n      * Dynamic enabling/disabling of sources/polygons in Collision Monitor/Detector\n      * Expose action server\u2019s result timeout\n      * RewrittenYaml could add new parameters to YAMLs\n      * Simple Commander API Allows Multi-Robot Namespacing\n      * Change duration type in wait_action node\n      * The costmap activation fails when required transforms are not available\n      * Subtrees Obtain Shared Resources\n      * Collision Monitor: added watchdog mechanism based on `source_timeout` parameter with default blocking behavior\n      * BtActionServer: use native library haltTree()\n      * Global Frame Removed from 2 BT Nodes\n      * Introduction of `CostmapUpdate.msg`\n      * Full Stack Uses Node Clocks\n      * New Graceful Motion Controller\n      * Plugin Libraries in BT Navigator Only Includes Custom Nodes\n      * New RViz Plugin for selecting Planners, Controllers, Goal Checkers, Progress Checkers and Smoothers\n      * RPP new optional `interpolate_curvature_after_goal` behavior and fix conflict between `use_rotate_to_heading` and `allow_reversing`\n      * Cancel Checker Interface For GlobalPlanner\n      * New BtActionServer/BtNavigator parameter\n      * New collision monitor parameter\n      * New graceful cancellation API for Controllers\n      * Standardization of Plugin Naming with Double Colons (::)\n      * Collision monitor: dynamic radius for circle type polygons\n      * Static Layer: new parameter `footprint_clearing_enabled`\n      * Lifecycle Node: added bond_heartbeat_period parameter (and allow disabling the bond mechanism)\n      * Rotation Shim Controller: new parameter `rotate_to_goal_heading`\n      * MPPI Controller: Addition of acceleration constraints\n      * RegulatedPurePursuit Controller [RPP]: new parameter `use_cancel_deceleration`\n    * Jazzy to K-Turtle\n      * TwistStamped Default CmdVel Change\n      * New Nav2 Loopback Simulator\n      * Docking with Static Infrastructure or Dynamic Docking\n      * New RViz panel for Docking\n      * New BT Nodes\n      * New RViz Tool for Costmap Cost Cell Inspection\n      * Fix flickering visualization\n      * Option to limit velocity through DWB trajectory\n      * Option to disable zero velocity publishing on goal exit\n      * Added optional collision checking for the Docking Server\n      * Revamped multirobot bringup and config files to use namespaces\n      * Removed global map_topic from Costmap node\n      * Simplified Costmap2DROS constructors\n  * Simple Commander API\n    * Overview\n    * Commander API\n    * Costmap API\n    * Footprint Collision Checker API\n    * Examples and Demos\n  * Roadmaps\n    * Jazzy Roadmap\n    * Iron Roadmap\n    * Humble Roadmap\n  * About and Contact\n    * Related Projects\n    * About\n    * Contact\n\n__Nav2\n\nEdit\n\n  *   * Navigation Concepts\n  * \n\n* * *\n\n# Navigation Concepts\uf0c1\n\nThis page is to help familiarize new roboticists to the concepts of mobile\nrobot navigation, in particular, with the concepts required to appreciating\nand working with this project.\n\n## ROS 2\uf0c1\n\nROS 2 is the core middleware used for Nav2. If you are unfamiliar with this,\nplease visit the ROS 2 documentation before continuing.\n\n### Action Server\uf0c1\n\nJust as in ROS, action servers are a common way to control long running tasks\nlike navigation. This stack makes more extensive use of actions, and in some\ncases, without an easy topic interface. It is more important to understand\naction servers as a developer in ROS 2. Some simple CLI examples can be found\nin the ROS 2 documentation.\n\nAction servers are similar to a canonical service server. A client will\nrequest some task to be completed, except, this task may take a long time. An\nexample would be moving the shovel up from a bulldozer or ask a robot to\ntravel 10 meters to the right.\n\nIn this situation, action servers and clients allow us to call a long-running\ntask in another process or thread and return a future to its result. It is\npermissible at this point to block until the action is complete, however, you\nmay want to occasionally check if the action is complete and continue to\nprocess work in the client thread. Since it is long-running, action servers\nwill also provide feedback to their clients. This feedback can be anything and\nis defined in the ROS `.action` along with the request and result types. In\nthe bulldozer example, a request may be an angle, a feedback may be the angle\nremaining to be moved, and the result is a success or fail boolean with the\nend angle. In the navigation example, a request may be a position, a feedback\nmay be the time its been navigating for and the distance to the goal, and the\nresult a boolean for success.\n\nFeedback and results can be gathered synchronously by registering callbacks\nwith the action client. They may also be gathered by asynchronously requesting\ninformation from the shared future objects. Both require spinning the client\nnode to process callback groups.\n\nAction servers are used in this stack to communicate with the highest level\nBehavior Tree (BT) navigator through a `NavigateToPose` action message. They\nare also used for the BT navigator to communicate with the subsequent smaller\naction servers to compute plans, control efforts, and recoveries. Each will\nhave their own unique `.action` type in `nav2_msgs` for interacting with the\nservers.\n\n### Lifecycle Nodes and Bond\uf0c1\n\nLifecycle (or Managed, more correctly) nodes are unique to ROS 2. More\ninformation can be found here. They are nodes that contain state machine\ntransitions for bringup and teardown of ROS 2 servers. This helps in\ndeterministic behavior of ROS systems in startup and shutdown. It also helps\nusers structure their programs in reasonable ways for commercial uses and\ndebugging.\n\nWhen a node is started, it is in the unconfigured state, only processing the\nnode\u2019s constructor which should **not** contain any ROS networking setup or\nparameter reading. By the launch system, or the supplied lifecycle manager,\nthe nodes need to be transitioned to inactive by configuring. After, it is\npossible to activate the node by transitioning through the activating stage.\n\nThis state will allow the node to process information and be fully setup to\nrun. The configuration stage, triggering the `on_configure()` method, will\nsetup all parameters, ROS networking interfaces, and for safety systems, all\ndynamically allocated memory. The activation stage, triggering the\n`on_activate()` method, will active the ROS networking interfaces and set any\nstates in the program to start processing information.\n\nTo shutdown, we transition into deactivating, cleaning up, shutting down and\nend in the finalized state. The networking interfaces are deactivated and stop\nprocessing, deallocate memory, exit cleanly, in those stages, respectively.\n\nThe lifecycle node framework is used extensively through out this project and\nall servers utilize it. It is best convention for all ROS systems to use\nlifecycle nodes if it is possible.\n\nWithin Nav2, we use a wrapper of LifecycleNodes, `nav2_util LifecycleNode`.\nThis wrapper wraps much of the complexities of LifecycleNodes for typical\napplications. It also includes a `bond` connection for the lifecycle manager\nto ensure that after a server transitions up, it also remains active. If a\nserver crashes, it lets the lifecycle manager know and transition down the\nsystem to prevent a critical failure. See Eloquent to Foxy for details.\n\n* * *\n\n## Behavior Trees\uf0c1\n\nBehavior trees (BT) are becoming increasingly common in complex robotics\ntasks. They are a tree structure of tasks to be completed. It creates a more\nscalable and human-understandable framework for defining multi-step or many\nstate applications. This is opposed to a finite state machine (FSM) which may\nhave dozens of states and hundreds of transitions. An example would be a\nsoccer-playing robot. Embedding the logic of soccer game play into a FSM would\nbe challenging and error prone with many possible states and rules.\nAdditionally, modeling choices like to shoot at the goal from the left, right,\nor center, is particularly unclear. With a BT, basic primitives, like \u201ckick\u201d,\n\u201cwalk\u201d, \u201cgo to ball\u201d, can be created and reused for many behaviors. More\ninformation can be found in this book. I **strongly** recommend reading\nchapters 1-3 to get a good understanding of the nomenclature and workflow. It\nshould only take about 30 minutes.\n\nBehavior Trees provide a formal structure for navigation logic which can be\nboth used to create complex systems but also be verifiable and validated as\nprovenly correct using advanced tools. Having the application logic\ncentralized in the behavior tree and with independent task servers (which only\ncommunicate data over the tree) allows for formal analysis.\n\nFor this project, we use BehaviorTree CPP V4 as the behavior tree library. We\ncreate node plugins which can be constructed into a tree, inside the `BT\nNavigator`. The node plugins are loaded into the BT and when the XML file of\nthe tree is parsed, the registered names are associated. At this point, we can\nmarch through the behavior tree to navigate.\n\nOne reason this library is used is its ability to load subtrees. This means\nthat the Nav2 behavior tree can be loaded into another higher-level BT to use\nthis project as node plugin. An example would be in soccer play, using the\nNav2 behavior tree as the \u201cgo to ball\u201d node with a ball detection as part of a\nlarger task. Additionally, we supply a `NavigateToPoseAction` plugin (among\nothers) for BT so the Nav2 stack can be called from a client application\nthrough the usual action interface.\n\nOther systems could be used to design complex autonomous behavior, namely\nHierarchical FSMs (HFSM). Behavior Trees were selected due to popularity\nacross the robotics and related industries and by largely user demand.\nHowever, due to the independent task server nature of Nav2, it is not\ndifficult to offer a `nav2_hfsm_navigator` package in the future, pending\ninterest and contribution.\n\n* * *\n\n## Navigation Servers\uf0c1\n\nPlanners and controllers are at the heart of a navigation task. Recoveries are\nused to get the robot out of a bad situation or attempt to deal with various\nforms of issues to make the system fault-tolerant. Smoothers can be used for\nadditional quality improvements of the planned path. In this section, the\ngeneral concepts around them and their uses in this project are analyzed.\n\n### Planner, Controller, Smoother and Recovery Servers\uf0c1\n\nFour of the action servers in this project are the planner, behavior, smoother\nand controller servers.\n\nThese action servers are used to host a map of algorithm plugins to complete\nvarious tasks. They also host the environmental representation used by the\nalgorithm plugins to compute their outputs.\n\nThe planner, smoother and controller servers will be configured at runtime\nwith the names (aliases) and types of algorithms to use. These types are the\npluginlib names that have been registered and the names are the aliases for\nthe task. An example would be the DWB controller used with name `FollowPath`,\nas it follows a reference path. In this case, then all parameters for DWB\nwould be placed in that namespace, e.g. `FollowPath.<param>`.\n\nThese three servers then expose an action interface corresponding to their\ntask. When the behavior tree ticks the corresponding BT node, it will call the\naction server to process its task. The action server callback inside the\nserver will call the chosen algorithm by its name (e.g. `FollowPath`) that\nmaps to a specific algorithm. This allows a user to abstract the algorithm\nused in the behavior tree to classes of algorithms. For instance, you can have\n`N` plugin controllers to follow paths, dock with charger, avoid dynamic\nobstacles, or interface with a tool. Having all of these plugins in the same\nserver allows the user to make use of a single environmental representation\nobject, which is costly to duplicate.\n\nFor the behavior server, each of the behaviors also contains their own name,\nhowever, each plugin will also expose its own special action server. This is\ndone because of the wide variety of behavior actions that may be created which\ncannot have a single simple interface to share. The behavior server also\ncontains a costmap subscriber to the local costmap, receiving real-time\nupdates from the controller server, to compute its tasks. We do this to avoid\nhaving multiple instances of the local costmap which are computationally\nexpensive to duplicate.\n\nAlternatively, since the BT nodes are trivial plugins calling an action, new\nBT nodes can be created to call other action servers with other action types.\nIt is advisable to use the provided servers if possible at all times. If, due\nto the plugin or action interfaces, a new server is needed, that can be\nsustained with the framework. The new server should use the new type and\nplugin interface, similar to the provided servers. A new BT node plugin will\nneed to be created to call the new action server \u2013 however no forking or\nmodification is required in the Nav2 repo itself by making extensive use of\nservers and plugins.\n\nIf you find that you require a new interface to the pluginlib definition or\naction type, please file a ticket and see if we can rectify that in the same\ninterfaces.\n\n### Planners\uf0c1\n\nThe task of a planner is to compute a path to complete some objective\nfunction. The path can also be known as a route, depending on the nomenclature\nand algorithm selected. Two canonical examples are computing a plan to a goal\n(e.g. from current position to a goal) or complete coverage (e.g. plan to\ncover all free space). The planner will have access to a global environmental\nrepresentation and sensor data buffered into it. Planners can be written to:\n\n  * Compute shortest path\n\n  * Compute complete coverage path\n\n  * Compute paths along sparse or predefined routes\n\nThe general task in Nav2 for the planner is to compute a valid, and\npotentially optimal, path from the current pose to a goal pose. However, many\nclasses of plans and routes exist which are supported.\n\n### Controllers\uf0c1\n\nControllers, also known as local planners in ROS 1, are the way we follow the\nglobally computed path or complete a local task. The controller will have\naccess to a local environment representation to attempt to compute feasible\ncontrol efforts for the base to follow. Many controller will project the robot\nforward in space and compute a locally feasible path at each update iteration.\nControllers can be written to:\n\n  * Follow a path\n\n  * Dock with a charging station using detectors in the odometric frame\n\n  * Board an elevator\n\n  * Interface with a tool\n\nThe general task in Nav2 for a controller is to compute a valid control effort\nto follow the global plan. However, many classes of controllers and local\nplanners exist. It is the goal of this project that all controller algorithms\ncan be plugins in this server for common research and industrial tasks.\n\n### Behaviors\uf0c1\n\nRecovery behaviors are a mainstay of fault-tolerant systems. The goal of\nrecoveries are to deal with unknown or failure conditions of the system and\nautonomously handle them. Examples may include faults in the perception system\nresulting in the environmental representation being full of fake obstacles.\nThe clear costmap recovery would then be triggered to allow the robot to move.\n\nAnother example would be if the robot was stuck due to dynamic obstacles or\npoor control. Backing up or spinning in place, if permissible, allow the robot\nto move from a poor location into free space it may navigate successfully.\n\nFinally, in the case of a total failure, a recovery may be implemented to call\nan operator\u2019s attention for help. This can be done via email, SMS, Slack,\nMatrix, etc.\n\nIt is important to note that the behavior server can hold any behavior to\nshare access to expensive resources like costmaps or TF buffers, not just\nrecovery behaviors. Each may have its own API.\n\n### Smoothers\uf0c1\n\nAs criteria for optimality of the path searched by a planner are usually\nreduced compared to reality, additional path refinement is often beneficial.\nSmoothers have been introduced for this purpose, typically responsible for\nreducing path raggedness and smoothing abrupt rotations, but also for\nincreasing distance from obstacles and high-cost areas as the smoothers have\naccess to a global environmental representation.\n\nUse of a separate smoother over one that is included as part of a planner is\nadvantageous when combining different planners with different smoothers or\nwhen a specific control over smoothing is required, e.g. smoothing only a\nspecific part of the path.\n\nThe general task in Nav2 for a smoother is to receive a path and return its\nimproved version. However, for different input paths, criteria of the\nimprovements and methods of acquiring them exist, creating space for a\nmultitude of smoothers that can be registered in this server.\n\n### Robot Footprints\uf0c1\n\nIt is worth remarking that in the cost maps, we set a robot\u2019s footprint either\nas a circle of radius `robot_radius` or as a vector of points `footprint`\nrepresenting an arbitrary polygon if the robot is non-circular. This can also\nbe adjusted over time using the costmap\u2019s `~/footprint` topic, which will\nupdate the polygon over time as needed due to changes in the robot\u2019s state,\nsuch as movement of an attached manipulator, picking up a pallet, or other\nactions that adjust a robot\u2019s shape. That polygon will then automatically be\nused by the planners and controllers.\n\n### Waypoint Following\uf0c1\n\nWaypoint following is a basic feature of a navigation system. It tells our\nsystem how to use navigation to get to multiple destinations.\n\nThe `nav2_waypoint_follower` contains a waypoint following program with a\nplugin interface for specific task executors. This is useful if you need to go\nto a given location and complete a specific task like take a picture, pick up\na box, or wait for user input. It is a nice demo application for how to use\nNav2 in a sample application.\n\nHowever, it could be used for more than just a sample application. There are 2\nschools of thoughts for fleet managers / dispatchers:\n\n  * Dumb robot; smart centralized dispatcher\n\n  * Smart robot; dumb centralized dispatcher\n\nIn the first, the `nav2_waypoint_follower` is fully sufficient to create a\nproduction-grade on-robot solution. Since the autonomy system / dispatcher is\ntaking into account things like the robot\u2019s pose, battery level, current task,\nand more when assigning tasks, the application on the robot just needs to\nworry about the task at hand and not the other complexities of the system to\ncomplete the requested task. In this situation, you should think of a request\nto the waypoint follower as 1 unit of work (e.g. 1 pick in a warehouse, 1\nsecurity patrole loop, 1 aisle, etc) to do a task and then return to the\ndispatcher for the next task or request to recharge. In this school of\nthought, the waypoint following application is just one step above navigation\nand below the system autonomy application.\n\nIn the second, the `nav2_waypoint_follower` is a nice sample application /\nproof of concept, but you really need your waypoint following / autonomy\nsystem on the robot to carry more weight in making a robust solution. In this\ncase, you should use the `nav2_behavior_tree` package to create a custom\napplication-level behavior tree using navigation to complete the task. This\ncan include subtrees like checking for the charge status mid-task for\nreturning to dock or handling more than 1 unit of work in a more complex task.\nSoon, there will be a `nav2_bt_waypoint_follower` (name subject to adjustment)\nthat will allow you to create this application more easily. In this school of\nthought, the waypoint following application is more closely tied to the system\nautonomy, or in many cases, is the system autonomy.\n\nNeither is better than the other, it highly depends on the tasks your robot(s)\nare completing, in what type of environment, and with what cloud resources\navailable. Often this distinction is very clear for a given business case.\n\n`nav2_waypoint_follower` also supports GPS waypoint following when global\nlocalization is provided by robot_localization using the `navsat_transform`\nnode - but also may be provided by Fuse or any number of other sources. There\nis an action server named `/follow_gps_waypoints` within\n`nav2_waypoint_follower` that can directly take in goals expressed in GPS\ncoordinates, convert them to cartesian goals in the global frame, and execute\nthem as cartesian waypoints.\n\n* * *\n\n## State Estimation\uf0c1\n\nWithin the navigation project, there are 2 major transformations that need to\nbe provided, according to community standards. The `map` to `odom` transform\nis provided by a positioning system (localization, mapping, SLAM) and `odom`\nto `base_link` by an odometry system.\n\nNote\n\nThere is **no** requirement on using a LIDAR on your robot to use the\nnavigation system. There is no requirement to use lidar-based collision\navoidance, localization, or SLAM. However, we do provide instructions and\nsupport tried and true implementations of these things using lidars. You can\nbe equally as successful using a vision or depth based positioning system and\nusing other sensors for collision avoidance. The only requirement is that you\nfollow the standards below with your choice of implementation.\n\n### Standards\uf0c1\n\nREP 105 defines the frames and conventions required for navigation and the\nlarger ROS ecosystem. These conventions should be followed at all times to\nmake use of the rich positioning, odometry, and SLAM projects available in the\ncommunity.\n\nIn a nutshell, REP-105 says that you must, at minimum, build a TF tree that\ncontains a full `map` -> `odom` -> `base_link` -> `[sensor frames]` for your\nrobot. TF2 is the time-variant transformation library in ROS 2 we use to\nrepresent and obtain time synchronized transformations. It is the job of the\nglobal positioning system (GPS, SLAM, Motion Capture) to, at minimum, provide\nthe `map` -> `odom` transformation. It is then the role of the odometry system\nto provide the `odom` -> `base_link` transformation. The remainder of the\ntransformations relative to `base_link` should be static and defined in your\nURDF.\n\n### Global Positioning: Localization and SLAM\uf0c1\n\nIt is the job of the global positioning system (GPS, SLAM, Motion Capture) to,\nat minimum, provide the `map` -> `odom` transformation. We provide `amcl`\nwhich is an Adaptive Monte-Carlo Localization technique based on a particle\nfilter for localization in a static map. We also provide SLAM Toolbox as the\ndefault SLAM algorithm for use to position and generate a static map.\n\nThese methods may also produce other output including position topics, maps,\nor other metadata, but they must provide that transformation to be valid.\nMultiple positioning methods can be fused together using robot localization,\ndiscussed more below.\n\n### Odometry\uf0c1\n\nIt is the role of the odometry system to provide the `odom` -> `base_link`\ntransformation. Odometry can come from many sources including LIDAR, RADAR,\nwheel encoders, VIO, and IMUs. The goal of the odometry is to provide a smooth\nand continuous local frame based on robot motion. The global positioning\nsystem will update the transformation relative to the global frame to account\nfor the odometric drift.\n\nRobot Localization is typically used for this fusion. It will take in `N`\nsensors of various types and provide a continuous and smooth odometry to TF\nand to a topic. A typical mobile robotics setup may have odometry from wheel\nencoders, IMUs, and vision fused in this manner.\n\nThe smooth output can be used then for dead-reckoning for precise motion and\nupdating the position of the robot accurately between global position updates.\n\n* * *\n\n## Environmental Representation\uf0c1\n\nThe environmental representation is the way the robot perceives its\nenvironment. It also acts as the central localization for various algorithms\nand data sources to combine their information into a single space. This space\nis then used by the controllers, planners, and recoveries to compute their\ntasks safely and efficiently.\n\n### Costmaps and Layers\uf0c1\n\nThe current environmental representation is a costmap. A costmap is a regular\n2D grid of cells containing a cost from unknown, free, occupied, or inflated\ncost. This costmap is then searched to compute a global plan or sampled to\ncompute local control efforts.\n\nVarious costmap layers are implemented as pluginlib plugins to buffer\ninformation into the costmap. This includes information from LIDAR, RADAR,\nsonar, depth images, etc. It may be wise to process sensor data before\ninputting it into the costmap layer, but that is up to the developer.\n\nCostmap layers can be created to detect and track obstacles in the scene for\ncollision avoidance using camera or depth sensors. Additionally, layers can be\ncreated to algorithmically change the underlying costmap based on some rule or\nheuristic. Finally, they may be used to buffer live data into the 2D or 3D\nworld for binary obstacle marking.\n\n### Costmap Filters\uf0c1\n\nImagine, you\u2019re annotating a map file (or any image file) in order to have a\nspecific action occur based on the location in the annotated map. Examples of\nmarking/annotating might be keep out zones to avoid planning inside, or have\npixels belong to maximum speeds in marked areas. This annotated map is called\n\u201cfilter mask\u201d. Just like a mask overlaid on a surface, it can or cannot be\nsame size, pose and scale as a main map. The main goal of filter mask - is to\nprovide the ability of marking areas on maps with some additional features or\nbehavioral changes.\n\nCostmap filters are a costmap layer-based approach of applying spatial-\ndependent behavioral changes, annotated in filter masks, into the Nav2 stack.\nCostmap filters are implemented as costmap plugins. These plugins are called\n\u201cfilters\u201d as they are filtering a costmap by spatial annotations marked on\nfilter masks. In order to make a filtered costmap and change a robot\u2019s\nbehavior in annotated areas, the filter plugin reads the data coming from the\nfilter mask. This data is being linearly transformed into a feature map in a\nfilter space. Having this transformed feature map along with a map/costmap,\nany sensor data and current robot coordinate filters can update the underlying\ncostmap and change the behavior of the robot depending on where it is. For\nexample, the following functionality could be made by use of costmap filters:\n\n  * Keep-out/safety zones where robots will never enter.\n\n  * Speed restriction areas. Maximum speed of robots going inside those areas will be limited.\n\n  * Preferred lanes for robots moving in industrial environments and warehouses.\n\n### Other Forms\uf0c1\n\nVarious other forms of environmental representations exist. These include:\n\n  * gradient maps, which are similar to costmaps but represent surface gradients to check traversibility over\n\n  * 3D costmaps, which represent the space in 3D, but then also requires 3D planning and collision checking\n\n  * Mesh maps, which are similar to gradient maps but with surface meshes at many angles\n\n  * \u201cVector space\u201d, taking in sensor information and using machine learning to detect individual items and locations to track rather than buffering discrete points.\n\n* * *\n\n## Nav2 Academic Overview\uf0c1\n\n#\n\n* * *\n\n(C) Copyright 2023.\n\n",
                "language": "en"
            },
            "platform": "docs.nav2.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://docs.nav2.org/concepts/index.html"
        },
        {
            "id": "f60c8b0c-149b-4817-8b53-cbbfd2fd764b",
            "content": {
                "Title": "First-Time Robot Setup Guide \u2014 Nav2 1.0.0 documentation",
                "Subtitle": null,
                "Content": "Nav2\n\nlatest\n\n  * Getting Started\n    * Installation\n    * Running the Example\n    * Navigating\n  * Development Guides\n    * Build and Install\n      * Install\n        * For Iron and Older\n        * For Jazzy and Newer\n      * Build\n        * Released Distribution Binaries\n        * Rolling Development Source\n        * Docker Container Images\n      * Generate Doxygen\n      * Help\n        * Build Troubleshooting Guide\n    * Dev Containers\n      * Dev Container Guide\n        * Creating Dev Containers\n        * Using Dev Containers\n      * What, Why, How?\n        * What is a Dev Container?\n        * Why use a Dev Container?\n        * How do Dev Containers work?\n      * Prerequisites\n      * Getting started\n      * Security\n    * Getting Involved\n      * Getting Involved\n      * Process\n      * Licensing\n      * Developer Certification of Origin (DCO)\n  * Navigation Concepts\n    * ROS 2\n      * Action Server\n      * Lifecycle Nodes and Bond\n    * Behavior Trees\n    * Navigation Servers\n      * Planner, Controller, Smoother and Recovery Servers\n      * Planners\n      * Controllers\n      * Behaviors\n      * Smoothers\n      * Robot Footprints\n      * Waypoint Following\n    * State Estimation\n      * Standards\n      * Global Positioning: Localization and SLAM\n      * Odometry\n    * Environmental Representation\n      * Costmaps and Layers\n      * Costmap Filters\n      * Other Forms\n    * Nav2 Academic Overview\n  * First-Time Robot Setup Guide\n    * Setting Up Transformations\n      * Transforms Introduction\n      * Static Transform Publisher Demo\n      * Transforms in Navigation2\n      * Conclusion\n    * Setting Up The URDF\n      * URDF and the Robot State Publisher\n      * Setting Up the Environment\n      * Writing the URDF\n      * Build and Launch\n      * Visualization using RVIZ\n      * Adding Physical Properties\n      * Conclusion\n    * Setting Up Odometry\n      * Odometry Introduction\n      * Setting Up Odometry on your Robot\n      * Simulating an Odometry System using Gazebo\n        * Setup and Prerequisites\n        * Adding Gazebo Plugins to a URDF\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Robot Localization Demo\n        * Configuring Robot Localization\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Conclusion\n    * Setting Up Sensors\n      * Sensor Introduction\n        * Common Sensor Messages\n      * Simulating Sensors using Gazebo\n        * Adding Gazebo Plugins to a URDF\n        * Launch and Build Files\n        * Build, Run and Verification\n      * Mapping and Localization\n      * Costmap 2D\n        * Configuring nav2_costmap_2d\n        * Build, Run and Verification\n      * Conclusion\n    * Setting Up the Robot\u2019s Footprint\n      * Footprint Introduction\n      * Configuring the Robot\u2019s Footprint\n      * Build, Run and Verification\n      * Visualizing Footprint in RViz\n      * Conclusion\n    * Setting Up Navigation Plugins\n      * Planner and Controller Servers\n      * Selecting the Algorithm Plugins\n        * Planner Server\n        * Controller Server\n      * Conclusion\n  * Robots Using\n  * General Tutorials\n    * Navigating with a Physical Turtlebot 3\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Setup Your Environment Variables\n        * 1- Launch Turtlebot 3\n        * 2- Launch Nav2\n        * 3- Launch RVIZ\n        * 4- Initialize the Location of Turtlebot 3\n        * 5- Send a Goal Pose\n    * (SLAM) Navigating While Mapping\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Launch Robot Interfaces\n        * 1- Launch Navigation2\n        * 2- Launch SLAM\n        * 3- Working with SLAM\n        * 4- Getting Started Simplification\n    * (STVL) Using an External Costmap Plugin\n      * Overview\n      * Costmap2D and STVL\n      * Tutorial Steps\n        * 0- Setup\n        * 1- Install STVL\n        * 1- Modify Navigation2 Parameter\n        * 2- Launch Navigation2\n        * 3- RVIZ\n    * Navigating Using GPS Localization\n      * Overview\n      * Requirements\n      * GPS Localization Overview\n      * Tutorial Steps\n        * 0- Setup Gazebo World\n        * 1- Setup GPS Localization system\n        * 2- Setup Navigation system\n        * 3- Interactive GPS Waypoint Follower\n        * 4- Logged GPS Waypoint Follower & Waypoint Logging\n      * Conclusion\n    * Groot - Interacting with Behavior Trees\n      * Overview\n      * Visualize Behavior Trees\n      * Edit Behavior Trees\n      * Adding A Custom Node\n    * Using VIO to Augment Robot Odometry\n      * Overview\n      * Setting Up the ZED X Camera\n      * Setting Up ZED ROS\n      * Fusing VIO Into Local State Estimate\n        * Fusing VSLAM Into Global State Estimate\n      * Testing it Out!\n    * Dynamic Object Following\n      * Overview\n      * Tutorial Steps\n        * 0- Create the Behavior Tree\n        * 1- Setup Rviz clicked point\n        * 2- Run Dynamic Object Following in Nav2 Simulation\n    * Navigating with Keepout Zones\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Prepare filter mask\n        * 2\\. Configure Costmap Filter Info Publisher Server\n        * 3\\. Enable Keepout Filter\n        * 4\\. Run Nav2 stack\n    * Navigating with Speed Limits\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Prepare filter mask\n        * 2\\. Configure Costmap Filter Info Publisher Server\n        * 3\\. Enable Speed Filter\n        * 4\\. Run Nav2 stack\n    * Using Docking Server\n      * Overview\n      * Requirements\n      * ChargingDock Plugins\n      * Dock Database\n      * Configuring Docking Server\n      * Adding Docking Server to Launch\n      * Docking Action API\n      * Putting It All Together\n    * Using Rotation Shim Controller\n      * Overview\n      * What is the Rotation Shim Controller?\n      * Configuring Rotation Shim Controller\n      * Configuring Primary Controller\n      * Demo Execution\n    * Adding a Smoother to a BT\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 0- Familiarization with the Smoother BT Node\n        * 1- Specifying a Smoother Plugin\n        * 2- Modifying your BT XML\n    * Using Collision Monitor\n      * Overview\n      * Requirements\n      * Configuring Collision Monitor\n      * Configuring Collision Monitor with VelocityPolygon\n      * Preparing Nav2 stack\n      * Demo Execution\n    * Adding a New Nav2 Task Server\n      * Lifecycle Nodes\n      * Composition\n      * Error codes\n      * Conclusion\n    * Filtering of Noise-Induced Obstacles\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1\\. Enable Denoise Layer\n        * 2\\. Run Nav2 stack\n      * How it works\n    * Camera Calibration\n      * Overview\n      * Requirements\n      * Tutorial Steps\n    * Get Backtrace in ROS 2 / Nav2\n      * Overview\n      * Preliminaries\n      * From a Node\n      * From a Launch File\n      * From Large Project\n      * From Nav2 Bringup\n      * Automatic backtrace on crash\n    * Profiling in ROS 2 / Nav2\n      * Overview\n      * Preliminaries\n      * Profile from a Node\n      * Profile from a Launch File\n      * From Nav2 Bringup\n      * Interpreting Results\n    * Docker for Development: Zero to Hero\n      * Overview\n      * Preliminaries\n      * Important Docker Commands\n      * Exploring Your First Container\n      * Understanding ROS Docker Images\n      * For Docker-Based Development\n        * Building a Development Image\n        * Visualizations from Docker\n      * For Docker-Based Deployment\n      * Conclusion\n      * Appendix\n        * Nav2 Development Image\n        * Nav2 Deployment Image\n  * Plugin Tutorials\n    * Writing a New Costmap2D Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Write a new Costmap2D plugin\n        * 2- Export and make GradientLayer plugin\n        * 3- Enable the plugin in Costmap2D\n        * 4- Run GradientLayer plugin\n    * Writing a New Planner Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new Planner Plugin\n        * 2- Exporting the planner plugin\n        * 3- Pass the plugin name through params file\n        * 4- Run StraightLine plugin\n    * Writing a New Controller Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Create a new Controller Plugin\n        * 2- Exporting the controller plugin\n        * 3- Pass the plugin name through the params file\n        * 4- Run Pure Pursuit Controller plugin\n    * Writing a New Behavior Tree Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new BT Plugin\n        * 2- Exporting the planner plugin\n        * 3- Add plugin library name to config\n        * 4- Run Your Custom plugin\n    * Writing a New Behavior Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Creating a new Behavior Plugin\n        * 2- Exporting the Behavior Plugin\n        * 3- Pass the plugin name through params file\n        * 4- Run Behavior Plugin\n    * Writing a New Navigator Plugin\n      * Overview\n      * Requirements\n      * Tutorial Steps\n        * 1- Create a new Navigator Plugin\n        * 2- Exporting the navigator plugin\n        * 3- Pass the plugin name through the params file\n        * 4- Run plugin\n  * Configuration Guide\n    * Behavior-Tree Navigator\n      * Parameters\n      * Example\n    * Behavior Tree XML Nodes\n      * Action Plugins\n        * Wait\n        * Spin\n        * BackUp\n        * DriveOnHeading\n        * AssistedTeleop\n        * ComputePathToPose\n        * FollowPath\n        * NavigateToPose\n        * ClearEntireCostmap\n        * ClearCostmapExceptRegion\n        * ClearCostmapAroundRobot\n        * ReinitializeGlobalLocalization\n        * TruncatePath\n        * TruncatePathLocal\n        * PlannerSelector\n        * ControllerSelector\n        * SmootherSelector\n        * GoalCheckerSelector\n        * ProgressCheckerSelector\n        * NavigateThroughPoses\n        * ComputePathThroughPoses\n        * ComputeCoveragePath\n        * CancelCoverage\n        * RemovePassedGoals\n        * RemoveInCollisionGoals\n        * CancelControl\n        * CancelBackUp\n        * CancelSpin\n        * CancelWait\n        * CancelDriveOnHeading\n        * CancelAssistedTeleop\n        * SmoothPath\n        * GetPoseFromPath\n        * DockRobot\n        * UndockRobot\n      * Condition Plugins\n        * GoalReached\n        * TransformAvailable\n        * DistanceTraveled\n        * GoalUpdated\n        * GloballyUpdatedGoal\n        * InitialPoseReceived\n        * IsStuck\n        * IsStopped\n        * TimeExpired\n        * IsBatteryLow\n        * IsPathValid\n        * PathExpiringTimer\n        * AreErrorCodesPresent\n        * WouldAControllerRecoveryHelp\n        * WouldAPlannerRecoveryHelp\n        * WouldASmootherRecoveryHelp\n        * IsBatteryCharging\n      * Control Plugins\n        * PipelineSequence\n        * RoundRobin\n        * RecoveryNode\n      * Decorator Plugins\n        * RateController\n        * DistanceController\n        * SpeedController\n        * GoalUpdater\n        * PathLongerOnApproach\n        * SingleTrigger\n      * Example\n    * Costmap 2D\n      * Costmap2D ROS Parameters\n      * Default Plugins\n      * Plugin Parameters\n        * Static Layer Parameters\n        * Inflation Layer Parameters\n        * Obstacle Layer Parameters\n        * Voxel Layer Parameters\n        * Range Sensor Parameters\n        * Denoise Layer Parameters\n      * Costmap Filters Parameters\n        * Keepout Filter Parameters\n        * Speed Filter Parameters\n        * Binary Filter Parameters\n      * Example\n    * Lifecycle Manager\n      * Parameters\n      * Example\n    * Planner Server\n      * Parameters\n      * Default Plugins\n      * Example\n    * Coverage Server\n      * Parameters\n      * Example\n    * NavFn Planner\n      * Parameters\n      * Example\n    * Smac Planner\n      * Provided Plugins\n        * Smac 2D Planner\n        * Smac Hybrid-A* Planner\n        * Smac State Lattice Planner\n      * Description\n    * Theta Star Planner\n      * Parameters\n      * Example\n    * Controller Server\n      * Parameters\n      * Provided Plugins\n        * SimpleProgressChecker\n        * PoseProgressChecker\n        * SimpleGoalChecker\n        * StoppedGoalChecker\n      * Default Plugins\n      * Example\n    * DWB Controller\n      * Controller\n        * DWB Controller\n        * XYTheta Iterator\n        * Kinematic Parameters\n        * Publisher\n      * Plugins\n        * LimitedAccelGenerator\n        * StandardTrajectoryGenerator\n      * Trajectory Critics\n        * BaseObstacleCritic\n        * GoalAlignCritic\n        * GoalDistCritic\n        * ObstacleFootprintCritic\n        * OscillationCritic\n        * PathAlignCritic\n        * PathDistCritic\n        * PreferForwardCritic\n        * RotateToGoalCritic\n        * TwirlingCritic\n      * Example\n    * Regulated Pure Pursuit\n      * Regulated Pure Pursuit Parameters\n      * Example\n    * Model Predictive Path Integral Controller\n      * MPPI Parameters\n        * Trajectory Visualization\n        * Path Handler\n        * Ackermann Motion Model\n        * Constraint Critic\n        * Goal Angle Critic\n        * Goal Critic\n        * Obstacles Critic\n        * Cost Critic\n        * Path Align Critic\n        * Path Angle Critic\n        * Path Follow Critic\n        * Prefer Forward Critic\n        * Twirling Critic\n        * Velocity Deadband Critic\n      * Example\n      * Notes to Users\n        * General Words of Wisdom\n        * Prediction Horizon, Costmap Sizing, and Offsets\n        * Obstacle, Inflation Layer, and Path Following\n    * Rotation Shim Controller\n      * Rotation Shim Controller Parameters\n      * Example\n    * Graceful Controller\n      * Graceful Controller Parameters\n      * Example\n    * Map Server / Saver\n      * Map Saver Parameters\n      * Map Server Parameters\n      * Costmap Filter Info Server Parameters\n      * Example\n    * AMCL\n      * Parameters\n      * Example\n    * Behavior Server\n      * Behavior Server Parameters\n      * Default Plugins\n      * Spin Behavior Parameters\n      * BackUp Behavior Parameters\n      * DriveOnHeading Behavior Parameters\n      * AssistedTeleop Behavior Parameters\n      * Example\n    * Smoother Server\n      * Smoother Server Parameters\n      * Example\n    * Simple Smoother\n      * Simple Smoother Parameters\n      * Example\n    * Savitzky-Golay Smoother\n      * Savitzky-Golay Smoother Parameters\n      * Example\n    * Constrained smoother\n      * Smoother Server Parameters\n      * Example\n    * Velocity Smoother\n      * Velocity Smoother Parameters\n      * Example\n    * Collision Monitor\n      * Provided Nodes\n        * Collision Monitor Node\n        * Collision Detector Node\n    * Waypoint Follower\n      * Parameters\n      * Provided Plugins\n        * WaitAtWaypoint\n        * PhotoAtWaypoint\n        * InputAtWaypoint\n      * Default Plugin\n      * Example\n    * Loopback Simulator\n      * Parameters\n      * Example\n    * Docking Server\n      * Parameters\n      * SimpleChargingDock Parameters\n      * Example\n  * Tuning Guide\n    * Inflation Potential Fields\n    * Robot Footprint vs Radius\n    * Rotate in Place Behavior\n    * Planner Plugin Selection\n    * Controller Plugin Selection\n    * Caching Obstacle Heuristic in Smac Planners\n    * Costmap2D Plugins\n    * Nav2 Launch Options\n    * Other Pages We\u2019d Love To Offer\n  * Nav2 Behavior Trees\n    * Introduction To Nav2 Specific Nodes\n      * Action Nodes\n      * Condition Nodes\n      * Decorator Nodes\n      * Control: PipelineSequence\n      * Control: Recovery\n      * Control: RoundRobin\n    * Detailed Behavior Tree Walkthrough\n      * Overview\n      * Prerequisites\n      * Navigate To Pose With Replanning and Recovery\n      * Navigation Subtree\n      * Recovery Subtree\n    * Navigate To Pose\n    * Navigate Through Poses\n    * Navigate To Pose and Pause Near Goal-Obstacle\n    * Navigate To Pose With Consistent Replanning And If Path Becomes Invalid\n    * Follow Dynamic Point\n    * Odometry Calibration\n  * Navigation Plugins\n    * Behavior-Tree Navigators\n    * Costmap Layers\n    * Costmap Filters\n    * Controllers\n    * Planners\n    * Smoothers\n    * Behaviors\n    * Waypoint Task Executors\n    * Goal Checkers\n    * Progress Checkers\n    * Behavior Tree Nodes\n  * Migration Guides\n    * Dashing to Eloquent\n      * New Packages\n      * New Plugins\n      * Navigation2 Architectural Changes\n    * Eloquent to Foxy\n      * General\n      * Server Updates\n      * New Plugins\n      * Map Server Re-Work\n      * New Particle Filter Messages\n      * Selection of Behavior Tree in each navigation action\n      * FollowPoint Capability\n      * New Costmap Layer\n    * Foxy to Galactic\n      * NavigateToPose Action Feedback updates\n      * NavigateToPose BT-node Interface Changes\n      * NavigateThroughPoses and ComputePathThroughPoses Actions Added\n      * ComputePathToPose BT-node Interface Changes\n      * ComputePathToPose Action Interface Changes\n      * BackUp BT-node Interface Changes\n      * BackUp Recovery Interface Changes\n      * Nav2 Controllers and Goal Checker Plugin Interface Changes\n      * FollowPath goal_checker_id attribute\n      * Groot Support\n      * New Plugins\n      * Costmap Filters\n      * SmacPlanner\n      * ThetaStarPlanner\n      * RegulatedPurePursuitController\n      * Costmap2D `current_` Usage\n      * Standard time units in parameters\n      * Ray Tracing Parameters\n      * Obstacle Marking Parameters\n      * Recovery Action Changes\n      * Default Behavior Tree Changes\n      * NavFn Planner Parameters\n      * New ClearCostmapExceptRegion and ClearCostmapAroundRobot BT-nodes\n      * New Behavior Tree Nodes\n      * sensor_msgs/PointCloud to sensor_msgs/PointCloud2 Change\n      * ControllerServer New Parameter failure_tolerance\n      * Removed BT XML Launch Configurations\n      * Nav2 RViz Panel Action Feedback Information\n    * Galactic to Humble\n      * Major improvements to Smac Planners\n      * Simple (Python) Commander\n      * Reduce Nodes and Executors\n      * API Change for nav2_core\n      * Extending the BtServiceNode to process Service-Results\n      * Including new Rotation Shim Controller Plugin\n      * Spawning the robot in Gazebo\n      * Recovery Behavior Timeout\n      * New parameter `use_final_approach_orientation` for the 3 2D planners\n      * SmacPlanner2D and Theta*: fix goal orientation being ignored\n      * SmacPlanner2D, NavFn and Theta*: fix small path corner cases\n      * Change and fix behavior of dynamic parameter change detection\n      * Dynamic Parameters\n      * BT Action Nodes Exception Changes\n      * BT Navigator Groot Multiple Navigators\n      * Removed Kinematic Limiting in RPP\n      * Added Smoother Task Server\n      * Removed Use Approach Velocity Scaling Param in RPP\n      * Refactored AMCL motion models as plugins\n      * Dropping Support for Live Groot Monitoring of Nav2\n      * Replanning Only if Path is Invalid\n      * Fix CostmapLayer clearArea invert param logic\n      * Dynamic Composition\n      * BT Cancel Node\n      * BT PathLongerOnApproach Node\n      * BT TruncatePathLocal Node\n      * Constrained Smoother\n      * Replanning at a Constant Rate and if the Path is Invalid\n      * Euclidean Distance 2D\n      * Recovery To Behavior\n      * Respawn Support in Launch and Lifecycle Manager\n      * New Nav2 Velocity Smoother\n      * Goal Checker API Changed\n      * Added Assisted Teleop\n    * Humble to Iron\n      * New Behavior-Tree Navigator Plugins\n      * Added Collision Monitor\n      * Removed use_sim_time from yaml\n      * Run-time Speed up of Smac Planner\n      * Recursive Refinement of Smac and Simple Smoothers\n      * Simple Commander Python API\n      * Smac Planner Start Pose Included in Path\n      * Parameterizable Collision Checking in RPP\n      * Expanded Planner Benchmark Tests\n      * Smac Planner Path Tolerances\n      * costmap_2d_node default constructor\n      * Feedback for Navigation Failures\n      * Costmap Filters\n      * Savitzky-Golay Smoother\n      * Changes to Map yaml file path for map_server node in Launch\n      * SmootherSelector BT Node\n      * Publish Costmap Layers\n      * Give Behavior Server Access to Both Costmaps\n      * New Model Predictive Path Integral Controller\n      * Behavior Tree Uses Error Codes\n      * Load, Save and Loop Waypoints from the Nav2 Panel in RViz\n      * DWB Forward vs Reverse Pruning\n      * More stable regulation on curves for long lookahead distances\n      * Publish Collision Monitor State\n      * Renamed ROS-parameter in Collision Monitor\n      * New safety behavior model \u201climit\u201d in Collision Monitor\n      * Velocity smoother applies deceleration when timeout\n      * PoseProgressChecker plugin\n      * Allow multiple goal checkers and change parameter progress_checker_plugin(s) name and type\n      * IsBatteryChargingCondition BT Node\n      * Behavior Server Error Codes\n      * New Denoise Costmap Layer Plugin\n      * SmacPlannerHybrid viz_expansions parameter\n    * Iron to Jazzy\n      * BehaviorTree.CPP upgraded to version 4.5+\n      * Added TwistStamped Option for Commands\n      * Add VelocityPolygon in Collision Monitor\n      * Change polygon points parameter format in Collision Monitor\n      * Introduction of Soft-Real Time Action Servers\n      * `opennav_coverage` Project\n      * `opennav_docking` Project\n      * Introduce a new Multi-Robot Bringup Launch\n      * New option for the Voxel and Obstacle Layers\n      * use_interpolation RPP Parameter Depreciated\n      * Changes to MPPI Goal Critic\n      * Changes to MPPI Path Angle Critic\n      * Changes to MPPI Path Handling For Directionality\n      * Addition of new MPPI Cost Critic\n      * MPPI Acceleration\n      * Move Error Code Enumerations\n      * Substitution in parameter file\n      * Allow Behavior Server Plugins to Access The Action Result\n      * Smac Planner Debug Param Name Change\n      * Smac Planner On Approach to Goal Shortcutting Solutions\n      * Added GPS Waypoint Follower Server\n      * Smac Planner Hybrid-A* New Features\n      * New node in nav2_collision_monitor: Collision Detector\n      * Dynamic enabling/disabling of sources/polygons in Collision Monitor/Detector\n      * Expose action server\u2019s result timeout\n      * RewrittenYaml could add new parameters to YAMLs\n      * Simple Commander API Allows Multi-Robot Namespacing\n      * Change duration type in wait_action node\n      * The costmap activation fails when required transforms are not available\n      * Subtrees Obtain Shared Resources\n      * Collision Monitor: added watchdog mechanism based on `source_timeout` parameter with default blocking behavior\n      * BtActionServer: use native library haltTree()\n      * Global Frame Removed from 2 BT Nodes\n      * Introduction of `CostmapUpdate.msg`\n      * Full Stack Uses Node Clocks\n      * New Graceful Motion Controller\n      * Plugin Libraries in BT Navigator Only Includes Custom Nodes\n      * New RViz Plugin for selecting Planners, Controllers, Goal Checkers, Progress Checkers and Smoothers\n      * RPP new optional `interpolate_curvature_after_goal` behavior and fix conflict between `use_rotate_to_heading` and `allow_reversing`\n      * Cancel Checker Interface For GlobalPlanner\n      * New BtActionServer/BtNavigator parameter\n      * New collision monitor parameter\n      * New graceful cancellation API for Controllers\n      * Standardization of Plugin Naming with Double Colons (::)\n      * Collision monitor: dynamic radius for circle type polygons\n      * Static Layer: new parameter `footprint_clearing_enabled`\n      * Lifecycle Node: added bond_heartbeat_period parameter (and allow disabling the bond mechanism)\n      * Rotation Shim Controller: new parameter `rotate_to_goal_heading`\n      * MPPI Controller: Addition of acceleration constraints\n      * RegulatedPurePursuit Controller [RPP]: new parameter `use_cancel_deceleration`\n    * Jazzy to K-Turtle\n      * TwistStamped Default CmdVel Change\n      * New Nav2 Loopback Simulator\n      * Docking with Static Infrastructure or Dynamic Docking\n      * New RViz panel for Docking\n      * New BT Nodes\n      * New RViz Tool for Costmap Cost Cell Inspection\n      * Fix flickering visualization\n      * Option to limit velocity through DWB trajectory\n      * Option to disable zero velocity publishing on goal exit\n      * Added optional collision checking for the Docking Server\n      * Revamped multirobot bringup and config files to use namespaces\n      * Removed global map_topic from Costmap node\n      * Simplified Costmap2DROS constructors\n  * Simple Commander API\n    * Overview\n    * Commander API\n    * Costmap API\n    * Footprint Collision Checker API\n    * Examples and Demos\n  * Roadmaps\n    * Jazzy Roadmap\n    * Iron Roadmap\n    * Humble Roadmap\n  * About and Contact\n    * Related Projects\n    * About\n    * Contact\n\n__Nav2\n\nEdit\n\n  *   * First-Time Robot Setup Guide\n  * \n\n* * *\n\n# First-Time Robot Setup Guide\uf0c1\n\nThis section is a collection of guides that aims to provide readers a good\nresource for setting up Nav2. The objectives for this section are as follows:\n\n  * Help new users with setting up Navigation2 with a new robot\n\n  * Help people with custom built robots to properly set up their robots to be used in ROS/Navigation2\n\n  * Act as a checklist, template or boilerplate reference for more experienced readers\n\n  * Provide examples which can be run on simulators/tools like Gazebo or RViz to guide readers on the Nav2 setup process even without a physical robot.\n\n  * Broad strokes, tips, and tricks for configuring certain packages and integrating different components of the robot platform (sensors, odometry, etc.)\n\nTo guide you through the first-time setup of your robot, we will be tackling\nthe following topics:\n\n  * Introduce TF2 and setup your robot URDF\n\n  * Setup sensor sources for robot odometry\n\n  * Setup sensor sources for perception\n\n  * Configure round or arbitrary shaped footprints for your robot\n\n  * Select and set up planner and controller navigation plugins for your robot\u2019s navigation tasks\n\n  * Lifecycle node management for easy bringup of other related sensors or nodes\n\nThe simulator of record in these tutorials is Gazebo Classic, which is the\ndefault simulator in ROS 2 Humble, Iron and all previous distributions. When\nusing Jazzy or newer, consider that the simulation elements of the tutorial\nmay be out of date and are worth looking at other resources like\nnav2_minimal_turtlebot_simulation which fully leverages modern Gazebo with\nNav2.\n\n**Table of Contents:**\n\n  * Setting Up Transformations\n  * Setting Up The URDF\n  * Setting Up Odometry\n  * Setting Up Sensors\n  * Setting Up the Robot\u2019s Footprint\n  * Setting Up Navigation Plugins\n\nNote\n\nThese tutorials are not meant to be full tuning and configuration guides since\nthey only aim to help you get your robot up and running with a basic\nconfiguration. For more detailed discussions and guides on how to customize\nand tune Nav2 for your robot, head on to the Configuration Guide section.\n\n* * *\n\n(C) Copyright 2023.\n\n",
                "language": "en"
            },
            "platform": "docs.nav2.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://docs.nav2.org/setup_guides/index.html"
        },
        {
            "id": "31c8a614-792c-420f-b999-6027c0682cba",
            "content": {
                "Title": "MoveIt 2 Documentation \u2014 MoveIt Documentation: Rolling  documentation",
                "Subtitle": null,
                "Content": "  * Tutorials\n  * Examples\n  * Concepts\n  * How-To Guides\n  * API Documentation\n  * Contributing\n\n__MoveIt Documentation: Rolling\n\n  *   * MoveIt 2 Documentation\n  * Edit on GitHub\n\n* * *\n\n# MoveIt 2 Documentation\uf0c1\n\nWelcome to the unified MoveIt documentation, which includes tutorials, how-to\nguides, core concepts, and more.\n\nMoveIt 2 is the robotic manipulation platform for ROS 2 and incorporates the\nlatest advances in motion planning, manipulation, 3D perception, kinematics,\ncontrol, and navigation. MoveIt 2 was first released in 2019; for ROS 1\ndocumentation, see MoveIt 1 tutorials. For the commercially supported version\nsee MoveIt Pro tutorials.\n\n## How-To Use This Website\uf0c1\n\n  * Tutorials will walk you through creating your first project with MoveIt.\n\n  * How-To Guides answers the question \u201cHow to do X with MoveIt?\u201d\n\n  * Concepts discusses the design of MoveIt.\n\n  * Contributing is a place to learn about making changes to MoveIt and this website.\n\n  * Examples contains other useful pages that have not been adapted to the new layout of this site or are not yet ported from ROS 1.\n\n  * API Documentation will redirect you to a reference API page.\n\n## Table Of Contents\uf0c1\n\n  * Tutorials\n    * Getting Started\n    * MoveIt Quickstart in RViz\n    * Your First C++ MoveIt Project\n    * Visualizing In RViz\n    * Planning Around Objects\n    * Pick and Place with MoveIt Task Constructor\n  * Examples\n    * MoveGroup - ROS Wrappers in C++\n    * Using MoveIt Directly Through the C++ API\n    * Using MoveIt Directly Through the Python API\n    * Integration with a New Robot\n    * Configuration\n    * Miscellaneous\n  * Concepts\n    * Kinematics\n    * Motion Planning\n    * Hybrid Planning\n    * The `move_group` node\n    * Planning Scene Monitor\n    * Trajectory Processing\n    * MoveIt Task Constructor\n  * How-To Guides\n    * Configuring and Using MoveIt\n    * Developing and Documenting MoveIt\n  * API Documentation\n    * C++ API Documentation\n    * Python API Documentation\n  * Contributing\n    * How to Contribute to This Site\n    * How to Write a MoveIt Tutorial\n    * How to Write a MoveIt How-To Guide\n    * How to Cross-Reference Content\n\n## Attribution\uf0c1\n\nSome major past contributors to the MoveIt tutorials are listed in\nchronological order: Sachin Chitta, Dave Hershberger, Acorn Pooley, Dave\nColeman, Michael Goerner, Francisco Suarez, Mike Lautman, Tyler Weaver, David\nLu!!, Vatan Tezer, and Andy Zelenak. These are just some of the 46+\nContributors over the years who have a big impact on this documentation.\n\nHelp us improve these docs and we\u2019ll be happy to include you here also!\n\n## Corporate Sponsorship\uf0c1\n\n  * The tutorials had a major update in 2018 during a code sprint sponsored by Franka Emika in collaboration with PickNik Robotics (Check out the blog post!)\n\n  * The tutorials had another major update in 2022 during a doc-a-thon sponsored by PickNik Robotics.\n\nNext\n\n* * *\n\n(C) Copyright 2024, PickNik Robotics.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n\n",
                "language": "en"
            },
            "platform": "moveit.picknik.ai",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://moveit.picknik.ai/main/index.html"
        },
        {
            "id": "3c94f766-cff7-4523-ae68-8197c5c662ae",
            "content": {
                "Title": "Getting Started \u2014 MoveIt Documentation: Rolling  documentation",
                "Subtitle": null,
                "Content": "  * Tutorials\n    * Getting Started\n      * Install ROS 2 and colcon\n      * Create A Colcon Workspace and Download Tutorials\n      * Download Source Code of MoveIt and the Tutorials\n      * Build your Colcon Workspace\n      * Setup Your Colcon Workspace\n      * Next Step\n    * MoveIt Quickstart in RViz\n    * Your First C++ MoveIt Project\n    * Visualizing In RViz\n    * Planning Around Objects\n    * Pick and Place with MoveIt Task Constructor\n  * Examples\n  * Concepts\n  * How-To Guides\n  * API Documentation\n  * Contributing\n\n__MoveIt Documentation: Rolling\n\n  *   * Tutorials\n  * Getting Started\n  * Edit on GitHub\n\n* * *\n\n# Getting Started\uf0c1\n\nHere, we will setup your environment for best running the tutorials. This will\ncreate a colcon workspace, download all of the latest MoveIt source code, and\nbuild everything from source to ensure you have the latest fixes and\nimprovements.\n\nBuilding all the source code of MoveIt can take 20-30 minutes, depending on\nthe CPU speed and available RAM of your computer. If you are on a less\nperformant system, or generally just want to get started quicker, check out\nour Docker Guide.\n\n## Install ROS 2 and colcon\uf0c1\n\nMoveIt 2 currently supports multiple versions of ROS. Install whichever\nversion you prefer. We primarily support ROS installed on Ubuntu 22.04 or\n24.04 but other methods and platforms may work with small changes to the\ninstructions listed below. If you are just getting started, we recommend you\nuse the latest stable version of ROS (Jazzy) on Ubuntu 24.04 for the most\nseamless experience.\n\n  * Rolling Ridley \\- Rolling Development Release\n\n  * Jazzy Jalisco \\- Latest LTS Release - May 2024\n\n  * Humble Hawksbill \\- Supported LTS Release - May 2022\n\nIt is easy to miss steps when going through the ROS 2 installation tutorial.\nIf you run into errors in the next few steps, a good place to start is to go\nback and make sure you have installed ROS 2 correctly. One that users commonly\nforget is to source the ROS 2 install itself. Note to source the version of\nROS you installed.\n\n    \n    \n    source /opt/ros/jazzy/setup.bash\n    \n\nNote\n\nUnlike ROS 1 setup scripts, in ROS 2 the setup scripts do not attempt to\nswitch what version of ROS you are using. This means that if you have\npreviously sourced a different version of ROS, including from within your\n`.bashrc` file, you will run into errors during the building step. To fix this\nchange what is sourced in your `.bashrc` and start a new terminal.\n\nInstall rosdep to install system dependencies :\n\n    \n    \n    sudo apt install python3-rosdep\n    \n\nOnce you have ROS 2 installed, make sure you have the most up to date\npackages:\n\n    \n    \n    sudo rosdep init\n    rosdep update\n    sudo apt update\n    sudo apt dist-upgrade\n    \n\nInstall Colcon the ROS 2 build system with mixin:\n\n    \n    \n    sudo apt install python3-colcon-common-extensions\n    sudo apt install python3-colcon-mixin\n    colcon mixin add default https://raw.githubusercontent.com/colcon/colcon-mixin-repository/master/index.yaml\n    colcon mixin update default\n    \n\nInstall vcstool :\n\n    \n    \n    sudo apt install python3-vcstool\n    \n\n## Create A Colcon Workspace and Download Tutorials\uf0c1\n\nFor tutorials you will need to have a colcon workspace setup.\n\n    \n    \n    mkdir -p ~/ws_moveit/src\n    \n\n## Download Source Code of MoveIt and the Tutorials\uf0c1\n\nMove into your Colcon workspace and pull the MoveIt tutorials source, where\n`<branch>` can be e.g. `humble` for ROS Humble, or `main` for the latest\nversion of the tutorials :\n\n    \n    \n    cd ~/ws_moveit/src\n    git clone -b <branch> https://github.com/moveit/moveit2_tutorials\n    \n\nNext we will download the source code for the rest of MoveIt:\n\n    \n    \n    vcs import --recursive < moveit2_tutorials/moveit2_tutorials.repos\n    \n\nThe import command may ask for your GitHub credentials. You can just press\nEnter until it moves on (ignore the \u201cAuthentication failed\u201d error).\n\n## Build your Colcon Workspace\uf0c1\n\nFirst remove all previously installed moveit binaries:\n\n    \n    \n    sudo apt remove ros-$ROS_DISTRO-moveit*\n    \n\nThe following will install from Debian any package dependencies not already in\nyour workspace. This is the step that will install MoveIt and all of its\ndependencies:\n\n    \n    \n    sudo apt update && rosdep install -r --from-paths . --ignore-src --rosdistro $ROS_DISTRO -y\n    \n\nThe next command will configure your Colcon workspace:\n\n    \n    \n    cd ~/ws_moveit\n    colcon build --mixin release\n    \n\nThis build command will likely take a long time (20+ minutes) depending on\nyour computer speed and amount of RAM available (we recommend 32 GB).\n\nWarning\n\nSome of the packages built with this command require up to 16Gb of RAM to\nbuild. By default, `colcon` tries to build as many packages as possible at the\nsame time. If you are low on computer memory, or if the build is generally\nhaving trouble completing on your computer, you can try appending `--executor\nsequential` to the `colcon` command above to build only one package at a time,\nor `--parallel-workers <X>` to limit the number of simultaneous builds. For\neven more limited machines, you can try running `MAKEFLAGS=\"-j4 -l1\" colcon\nbuild --executor sequential`.\n\nIf everything goes well, you should see the message \u201cSummary: X packages\nfinished\u201d where X might be 50. If you have problems, try re-checking your ROS\nInstallation.\n\n## Setup Your Colcon Workspace\uf0c1\n\nSource the Colcon workspace:\n\n    \n    \n    source ~/ws_moveit/install/setup.bash\n    \n\nOptional: add the previous command to your `.bashrc`:\n\n    \n    \n    echo 'source ~/ws_moveit/install/setup.bash' >> ~/.bashrc\n    \n\nNote\n\nSourcing the `setup.bash` automatically in your `~/.bashrc` is not required\nand often skipped by advanced users who use more than one Colcon workspace at\na time, but we recommend it for simplicity.\n\n## Next Step\uf0c1\n\nNice job! Next, we will Visualize a robot with the interactive motion planning\nplugin for RViz\n\nPrevious Next\n\n* * *\n\n(C) Copyright 2024, PickNik Robotics.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n\n",
                "language": "en"
            },
            "platform": "moveit.picknik.ai",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://moveit.picknik.ai/main/doc/tutorials/getting_started/getting_started.html"
        },
        {
            "id": "295a7809-e227-4e39-9110-e5747def47a3",
            "content": {
                "Title": "MoveIt Quickstart in RViz \u2014 MoveIt Documentation: Rolling  documentation",
                "Subtitle": null,
                "Content": "  * Tutorials\n    * Getting Started\n    * MoveIt Quickstart in RViz\n      * Getting Started\n      * Step 1: Launch the Demo and Configure the Plugin\n      * Step 2: Play with the Visualized Robots\n      * Step 3: Interact with the Kinova Gen 3\n        * Moving into collision\n        * Moving out of Reachable Workspace\n        * Moving Joints or in Null Space\n      * Step 4: Use Motion Planning with the Kinova Gen 3\n        * Introspecting Trajectory Waypoints\n        * Plan Cartesian motions\n        * Executing Trajectories, Adjusting Speed\n      * Next Steps\n        * RViz Visual Tools\n        * Saving Your Configuration\n        * Next Tutorial\n    * Your First C++ MoveIt Project\n    * Visualizing In RViz\n    * Planning Around Objects\n    * Pick and Place with MoveIt Task Constructor\n  * Examples\n  * Concepts\n  * How-To Guides\n  * API Documentation\n  * Contributing\n\n__MoveIt Documentation: Rolling\n\n  *   * Tutorials\n  * MoveIt Quickstart in RViz\n  * Edit on GitHub\n\n* * *\n\n# MoveIt Quickstart in RViz\uf0c1\n\nThis tutorial will teach you how to create motion plans in MoveIt using RViz\nand the MoveIt Display plugin. Rviz is the primary visualizer in ROS and a\nvery useful tool for debugging robotics. The MoveIt Display plugin allows you\nto setup virtual environments (planning scenes), create start and goal states\nfor the robot interactively, test various motion planners, and visualize the\noutput. Let\u2019s get started!\n\n## Getting Started\uf0c1\n\nIf you haven\u2019t already done so, make sure you\u2019ve completed the steps in\nGetting Started or our Docker Guide. If you followed the Docker Guide, also\nfollow the Create A Colcon Workspace and Download Tutorials guide onwards to\nset up the tutorials.\n\n## Step 1: Launch the Demo and Configure the Plugin\uf0c1\n\n  * Launch the demo:\n    \n        ros2 launch moveit2_tutorials demo.launch.py\n    \n\n  * If you are doing this for the first time, you should see an empty world in RViz and will have to add the Motion Planning Plugin:\n\n    * You should see an empty world in RViz:\n\n    * In the RViz Displays Tab, press _Add_ :\n\n    * From the moveit_ros_visualization folder, choose \u201cMotionPlanning\u201d as the DisplayType. Press \u201cOk\u201d.\n\n    * You should now see the Kinova robot in RViz:\n\n  * Once you have the Motion Planning Plugin loaded, we can configure it. In the \u201cGlobal Options\u201d tab of the \u201cDisplays\u201d subwindow, set the **Fixed Frame** field to `/base_link`\n\n  * Now, you can start configuring the Plugin for your robot (the Kinova Gen 3 in this case). Click on \u201cMotionPlanning\u201d within \u201cDisplays\u201d.\n\n    * Make sure the **Robot Description** field is set to `robot_description`.\n\n    * Make sure the **Planning Scene Topic** field is set to `/monitored_planning_scene`. Click on topic name to expose topic-name drop-down.\n\n    * Make sure the **Trajectory Topic** under **Planned Path** is set to `/display_planned_path`.\n\n    * In **Planning Request** , change the **Planning Group** to `manipulator`. You can also see this in the MotionPlanning panel in the bottom left.\n\n## Step 2: Play with the Visualized Robots\uf0c1\n\nThere are four different overlapping visualizations:\n\n  1. The robot\u2019s configuration in the `/monitored_planning_scene` planning environment (active by default).\n\n  2. The planned path for the robot (active by default).\n\n  3. Green: The start state for motion planning (disabled by default).\n\n  4. Orange: The goal state for motion planning (active by default).\n\nThe display states for each of these visualizations can be toggled on and off\nusing checkboxes:\n\n  1. The planning scene robot using the **Show Robot Visual** checkbox in the **Scene Robot** tree menu.\n\n  2. The planned path using the **Show Robot Visual** checkbox in the **Planned Path** tree menu.\n\n  3. The start state using the **Query Start State** checkbox in the **Planning Request** tree menu.\n\n  4. The goal state using the **Query Goal State** checkbox in the **Planning Request** tree menu.\n\n  * Play with all these checkboxes to switch on and off different visualizations.\n\n## Step 3: Interact with the Kinova Gen 3\uf0c1\n\nFor the next steps we will want only the scene robot, start state and goal\nstate:\n\n  1. Check the **Show Robot Visual** checkbox in the **Planned Path** tree menu\n\n  2. Un-check the **Show Robot Visual** checkbox in the **Scene Robot** tree menu\n\n  3. Check the **Query Goal State** checkbox in the **Planning Request** tree menu.\n\n  4. Check the **Query Start State** checkbox in the **Planning Request** tree menu.\n\nThere should now be two interactive markers. One marker corresponding to the\norange colored arm will be used to set the \u201cGoal State\u201d for motion planning\nand the other marker corresponding to a green colored arm are used to set the\n\u201cStart State\u201d for motion planning. If you don\u2019t see the interactive markers\npress **Interact** in the top menu of RViz (Note: some tools may be hidden,\npress **\u201c+\u201d** in the top menu to add the **Interact** tool as shown below).\n\nYou should now be able to use these markers to drag the arm around and change\nits orientation. Try it!\n\n### Moving into collision\uf0c1\n\nFor this section, hide the planned path and the goal state:\n\n  1. Un-check the **Show Robot Visual** checkbox in the **Planned Path** tree menu\n\n  2. Un-check the **Query Goal State** checkbox in the **Planning Request** tree menu.\n\nNow, only the Start State (the green colored arm) should be visible. Try to\nmove the arm into a configuration where two of its links are in collision with\neach other. (If you find this difficult, make sure the \u201cUse Collision-Aware\nIK\u201d checkbox under the Planning tab of the MotionPlanning plugin is un-\nchecked.) Once you do this, the links that are in collision will turn red.\n\nNow, check the \u201cUse Collision-Aware IK\u201d checkbox, and try again to move two of\nthe links into collision with each other. When the checkbox is ticked, the IK\nsolver will keep attempting to find a collision-free solution for the desired\nend-effector pose. When it is not checked, the solver will allow collisions to\nhappen in the solution. The links in collision will always still be visualized\nin red, regardless of the state of the checkbox.\n\n### Moving out of Reachable Workspace\uf0c1\n\nNote what happens when you try to move an end-effector out of its reachable\nworkspace.\n\nBefore moving onto the next section, re-enable the planned path and the goal\nstate:\n\n  1. Check the **Show Robot Visual** checkbox in the **Planned Path** tree menu\n\n  2. Check the **Query Goal State** checkbox in the **Planning Request** tree menu.\n\n### Moving Joints or in Null Space\uf0c1\n\nYou can use the **Joints** tab to move single joints and the redundant joints\nof 7-DOF robots. Try moving the \u201cnull space exploration\u201d slider as shown in\nthe animation below.\n\nThe joints moving while the end effector stays still\n\n## Step 4: Use Motion Planning with the Kinova Gen 3\uf0c1\n\n  * Now, you can start motion planning with the Kinova Gen 3 in the MoveIt RViz Plugin.\n\n    * Move the Start State to a desired location.\n\n    * Move the Goal State to another desired location.\n\n    * Make sure both states are not in collision with the robot itself.\n\n    * Un-check the **Show Trail** checkbox in the **Planned Path** tree menu.\n\n  * In the **MotionPlanning** window under the **Planning** tab, press the **Plan** button.\n\n  * Check the **Show Trail** checkbox in the **Planned Path** tree menu. You should see the arm\u2019s path represented by a series of manipulator poses.\n\n### Introspecting Trajectory Waypoints\uf0c1\n\nYou can visually introspect trajectories point by point in RViz.\n\n  * From \u201c _Panels_ \u201d menu, select \u201c _Trajectory - Trajectory Slider_ \u201d. You\u2019ll see a new Slider panel on RViz.\n\n  * Set your goal pose, then run _Plan_.\n\n  * Play with the \u201c _Slider_ \u201d panel, e.g. move the slider, push \u201c _Play_ \u201d button.\n\nNote: Once you placed your end-effector to a new goal, be sure to run _Plan_\nbefore running _Play_ \u2013 otherwise you\u2019ll see the waypoints for the previous\ngoal if available.\n\n### Plan Cartesian motions\uf0c1\n\nIf the \u201cUse Cartesian Path\u201d checkbox is activated, the robot will attempt to\nmove the end effector linearly in cartesian space.\n\n### Executing Trajectories, Adjusting Speed\uf0c1\n\nClicking \u201cPlan & Execute\u201d or \u201cExecute\u201d after a successful plan will send the\ntrajectory to the robot - in this tutorial, since you used\n`kinova_demo.launch`, the robot is only simulated.\n\nInitially, the default velocity and acceleration are scaled to 10% (`0.1`) of\nthe robot\u2019s maximum. You can change these scaling factors in the Planning tab\nshown below, or change these default values in the `moveit_config` of your\nrobot (in `joint_limits.yaml`).\n\n## Next Steps\uf0c1\n\n### RViz Visual Tools\uf0c1\n\nMany of the tutorials use `moveit_visual_tools` to step through a demo. Before\ncontinuing on to the next tutorials it is a good idea to enable the\n**RvizVisualToolsGui**.\n\nFrom \u201c _Panels_ \u201d menu, select \u201c _Add New Panels_ \u201d. From the menu, select \u201c\n_RvizVisualToolsGui_ \u201d and click OK. You\u2019ll see the new panel added to RViz.\n\n### Saving Your Configuration\uf0c1\n\nRViz enables you to save your configuration under `File->Save Config`. You\nshould do this before continuing on to the next tutorials. If you choose to\nsave your configuration under a new name, you can use `File->Save Config As`\nand refer to your configuration file using:\n\n    \n    \n    ros2 launch moveit2_tutorials demo.launch.py rviz_config:=your_rviz_config.rviz\n    \n\nReplace `your_rviz_config.rviz` with the name of the file you saved to\n`moveit2_tutorials/doc/tutorials/quickstart_in_rviz/launch/` and build the\nworkspace so it can be found.\n\n### Next Tutorial\uf0c1\n\nIn Your First MoveIt Project, you will create a C++ program using MoveIt to\nplan and execute moves.\n\nPrevious Next\n\n* * *\n\n(C) Copyright 2024, PickNik Robotics.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n\n",
                "language": "en"
            },
            "platform": "moveit.picknik.ai",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://moveit.picknik.ai/main/doc/tutorials/quickstart_in_rviz/quickstart_in_rviz_tutorial.html"
        },
        {
            "id": "998c6068-3ba9-4f6e-a5b4-262f560153ee",
            "content": {
                "Title": "Your First C++ MoveIt Project \u2014 MoveIt Documentation: Rolling  documentation",
                "Subtitle": null,
                "Content": "  * Tutorials\n    * Getting Started\n    * MoveIt Quickstart in RViz\n    * Your First C++ MoveIt Project\n      * Prerequisites\n      * Steps\n        * 1 Create a package\n        * 2 Create a ROS Node and Executor\n          * 2.1 Build and Run\n          * 2.2 Examine the code\n        * 3 Plan and Execute using MoveGroupInterface\n          * 3.1 Build and Run\n          * 3.2 Examine the code\n      * Summary\n      * Further Reading\n      * Next Step\n    * Visualizing In RViz\n    * Planning Around Objects\n    * Pick and Place with MoveIt Task Constructor\n  * Examples\n  * Concepts\n  * How-To Guides\n  * API Documentation\n  * Contributing\n\n__MoveIt Documentation: Rolling\n\n  *   * Tutorials\n  * Your First C++ MoveIt Project\n  * Edit on GitHub\n\n* * *\n\n# Your First C++ MoveIt Project\uf0c1\n\nThis tutorial will step you through writing your first C++ application with\nMoveIt.\n\nWarning: Most features in MoveIt will not work properly since additional\nparameters are required for full Move Group functionality. For a full setup,\nplease continue with the Move Group C++ Interface Tutorial.\n\n## Prerequisites\uf0c1\n\nIf you haven\u2019t already done so, make sure you\u2019ve completed the steps in\nGetting Started.\n\nThis tutorial assumes you understand the basics of ROS 2. To prepare yourself\nfor this please complete the Official ROS 2 Tutorials up until \u201cWriting a\nsimple publisher and Subscriber (C++)\u201d.\n\n## Steps\uf0c1\n\n### 1 Create a package\uf0c1\n\nOpen a terminal and source your ROS 2 installation so that `ros2` commands\nwill work.\n\nNavigate to your `ws_moveit` directory you created in the Getting Started\nTutorial.\n\nChange directory into the `src` directory, as that is where we put our source\ncode.\n\nCreate a new package with the ROS 2 command line tools:\n\n    \n    \n    ros2 pkg create \\\n     --build-type ament_cmake \\\n     --dependencies moveit_ros_planning_interface rclcpp \\\n     --node-name hello_moveit hello_moveit\n    \n\nThe output of this will show that it created some files in a new directory.\n\nNote that we added `moveit_ros_planning_interface` and `rclcpp` as\ndependencies. This will create the necessary changes in the `package.xml` and\n`CMakeLists.txt` files so that we can depend on these two packages.\n\nOpen the new source file created for you at\n`ws_moveit/src/hello_moveit/src/hello_moveit.cpp` in your favorite editor.\n\n### 2 Create a ROS Node and Executor\uf0c1\n\nThis first block of code is a bit of boilerplate but you should be used to\nseeing this from the ROS 2 tutorials.\n\n    \n    \n    #include <memory>\n    \n    #include <rclcpp/rclcpp.hpp>\n    #include <moveit/move_group_interface/move_group_interface.h>\n    \n    int main(int argc, char * argv[])\n    {\n      // Initialize ROS and create the Node\n      rclcpp::init(argc, argv);\n      auto const node = std::make_shared<rclcpp::Node>(\n        \"hello_moveit\",\n        rclcpp::NodeOptions().automatically_declare_parameters_from_overrides(true)\n      );\n    \n      // Create a ROS logger\n      auto const logger = rclcpp::get_logger(\"hello_moveit\");\n    \n      // Next step goes here\n    \n      // Shutdown ROS\n      rclcpp::shutdown();\n      return 0;\n    }\n    \n\n#### 2.1 Build and Run\uf0c1\n\nWe will build and run the program to see that everything is right before we\nmove on.\n\nChange the directory back to the workspace directory `ws_moveit` and run this\ncommand:\n\n    \n    \n    colcon build --mixin debug\n    \n\nAfter this succeeds, **open a new terminal** , then source the workspace\nenvironment script in that new terminal so that we can run our program.\n\n    \n    \n    cd ~/ws_moveit\n    source install/setup.bash\n    \n\nRun your program and see the output.\n\n    \n    \n    ros2 run hello_moveit hello_moveit\n    \n\nThe program should run and exit without error.\n\n#### 2.2 Examine the code\uf0c1\n\nThe headers included at the top are just some standard C++ headers and the\nheaders for ROS and MoveIt that we will use later.\n\nAfter that, we have the normal call to initialize rclcpp, and then we create\nour Node.\n\n    \n    \n    auto const node = std::make_shared<rclcpp::Node>(\n      \"hello_moveit\",\n      rclcpp::NodeOptions().automatically_declare_parameters_from_overrides(true)\n    );\n    \n\nThe first argument is a string that ROS will use to name a unique node. The\nsecond is needed for MoveIt because of how we use ROS Parameters.\n\nNext, we create a logger named \u201chello_moveit\u201d to keep our log outputs\norganized and configurable.\n\n    \n    \n    // Create a ROS logger\n    auto const logger = rclcpp::get_logger(\"hello_moveit\");\n    \n\nLastly, we have the code to shutdown ROS.\n\n    \n    \n    // Shutdown ROS\n    rclcpp::shutdown();\n    return 0;\n    \n\n### 3 Plan and Execute using MoveGroupInterface\uf0c1\n\nIn place of the comment that says \u201cNext step goes here\u201d, add this code:\n\n    \n    \n    // Create the MoveIt MoveGroup Interface\n    using moveit::planning_interface::MoveGroupInterface;\n    auto move_group_interface = MoveGroupInterface(node, \"manipulator\");\n    \n    // Set a target Pose\n    auto const target_pose = []{\n      geometry_msgs::msg::Pose msg;\n      msg.orientation.w = 1.0;\n      msg.position.x = 0.28;\n      msg.position.y = -0.2;\n      msg.position.z = 0.5;\n      return msg;\n    }();\n    move_group_interface.setPoseTarget(target_pose);\n    \n    // Create a plan to that target pose\n    auto const [success, plan] = [&move_group_interface]{\n      moveit::planning_interface::MoveGroupInterface::Plan msg;\n      auto const ok = static_cast<bool>(move_group_interface.plan(msg));\n      return std::make_pair(ok, msg);\n    }();\n    \n    // Execute the plan\n    if(success) {\n      move_group_interface.execute(plan);\n    } else {\n      RCLCPP_ERROR(logger, \"Planning failed!\");\n    }\n    \n\n#### 3.1 Build and Run\uf0c1\n\nJust like before, we need to build the code before we can run it.\n\nIn the workspace directory, `ws_moveit`, run this command:\n\n    \n    \n    colcon build --mixin debug\n    \n\nAfter this succeeds, we need to reuse the demo launch file from the previous\ntutorial to start RViz and the MoveGroup node. In a separate terminal, source\nthe workspace and then execute this:\n\n    \n    \n    ros2 launch moveit2_tutorials demo.launch.py\n    \n\nThen in the `Displays` window under `MotionPlanning/Planning Request`, uncheck\nthe box `Query Goal State`.\n\nIn a third terminal, source the workspace and run your program.\n\n    \n    \n    ros2 run hello_moveit hello_moveit\n    \n\nThis should cause the robot in RViz to move and end up in this pose:\n\nNote that if you run the node `hello_moveit` without launching the demo launch\nfile first, it will wait for 10 seconds and then print this error and exit.\n\n    \n    \n    [ERROR] [1644181704.350825487] [hello_moveit]: Could not find parameter robot_description and did not receive robot_description via std_msgs::msg::String subscription within 10.000000 seconds.\n    \n\nThis is because the `demo.launch.py` launch is starting the `MoveGroup` node\nthat provides the robot description. When `MoveGroupInterface` is constructed,\nit looks for a node publishing a topic with the robot description. If it fails\nto find that within 10 seconds, it prints this error and terminates the\nprogram.\n\n#### 3.2 Examine the code\uf0c1\n\nThe first thing we do is create the `MoveGroupInterface`. This object will be\nused to interact with `move_group`, which allows us to plan and execute\ntrajectories. Note that this is the only mutable object that we create in this\nprogram. Another thing to take note of is the second argument to the\n`MoveGroupInterface` object we are creating here: `\"manipulator\"`. That is the\ngroup of joints as defined in the robot description that we are going to\noperate on with this `MoveGroupInterface`.\n\n    \n    \n    using moveit::planning_interface::MoveGroupInterface;\n    auto move_group_interface = MoveGroupInterface(node, \"manipulator\");\n    \n\nThen, we set our target pose and plan. Note that only the target pose is set\n(via `setPoseTarget`). The starting pose is implicitly the position published\nby the joint state publisher, which could be changed using the\n`MoveGroupInterface::setStartState*` family of functions (but is not in this\ntutorial).\n\nOne more thing to note about this next section is the use of lambdas for\nconstructing the message type `target_pose` and planning. This is a pattern\nyou\u2019ll find in modern C++ codebases that enables writing in a more declarative\nstyle. For more information about this pattern, there are a couple of links at\nthe end of this tutorial.\n\n    \n    \n    // Set a target Pose\n    auto const target_pose = []{\n      geometry_msgs::msg::Pose msg;\n      msg.orientation.w = 1.0;\n      msg.position.x = 0.28;\n      msg.position.y = -0.2;\n      msg.position.z = 0.5;\n      return msg;\n    }();\n    move_group_interface.setPoseTarget(target_pose);\n    \n    // Create a plan to that target pose\n    auto const [success, plan] = [&move_group_interface]{\n      moveit::planning_interface::MoveGroupInterface::Plan msg;\n      auto const ok = static_cast<bool>(move_group_interface.plan(msg));\n      return std::make_pair(ok, msg);\n    }();\n    \n\nFinally, we execute our plan if planning is successful, otherwise, we log an\nerror:\n\n    \n    \n    // Execute the plan\n    if(success) {\n      move_group_interface.execute(plan);\n    } else {\n      RCLCPP_ERROR(logger, \"Planning failed!\");\n    }\n    \n\n## Summary\uf0c1\n\n  * You created a ROS 2 package and wrote your first program using MoveIt.\n\n  * You learned about using the MoveGroupInterface to plan and execute moves.\n\n  * Here is a copy of the full hello_moveit.cpp source at the end of this tutorial.\n\n## Further Reading\uf0c1\n\n  * We used lambdas to be able to initialize objects as constants. This is known as a technique called IIFE. Read more about this pattern from C++ Stories.\n\n  * We also declared everything we could as const. Read more about the usefulness of const here.\n\n## Next Step\uf0c1\n\nIn the next tutorial Visualizing in RViz, you will expand on the program you\nbuilt here to create visual markers that make it easier to understand what\nMoveIt is doing.\n\nPrevious Next\n\n* * *\n\n(C) Copyright 2024, PickNik Robotics.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n\n",
                "language": "en"
            },
            "platform": "moveit.picknik.ai",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://moveit.picknik.ai/main/doc/tutorials/your_first_project/your_first_project.html"
        },
        {
            "id": "7837daac-ef90-4264-8350-0aa9d3b01da6",
            "content": {
                "Title": "Visualizing In RViz \u2014 MoveIt Documentation: Rolling  documentation",
                "Subtitle": null,
                "Content": "  * Tutorials\n    * Getting Started\n    * MoveIt Quickstart in RViz\n    * Your First C++ MoveIt Project\n    * Visualizing In RViz\n      * Prerequisites\n      * Steps\n        * 1 Add the dependency moveit_visual_tools\n        * 2 Create a ROS executor and spin the node on a thread\n        * 3 Create and Initialize MoveItVisualTools\n        * 4 Write closures for visualizations\n        * 5 Visualize the steps of your program\n        * 6 Enable visualizations in RViz\n        * 7 Run the Program\n      * Summary\n      * Further Reading\n      * Next Step\n    * Planning Around Objects\n    * Pick and Place with MoveIt Task Constructor\n  * Examples\n  * Concepts\n  * How-To Guides\n  * API Documentation\n  * Contributing\n\n__MoveIt Documentation: Rolling\n\n  *   * Tutorials\n  * Visualizing In RViz\n  * Edit on GitHub\n\n* * *\n\n# Visualizing In RViz\uf0c1\n\nThis tutorial will introduce you to a tool that can help you more easily\nunderstand what your MoveIt application is doing by rendering visualizations\nin RViz.\n\n## Prerequisites\uf0c1\n\nIf you haven\u2019t already done so, make sure you\u2019ve completed the steps in Your\nFirst Project. This project assumes you are starting with the `hello_moveit`\nproject, where the previous tutorial left off.\n\n## Steps\uf0c1\n\n### 1 Add the dependency moveit_visual_tools\uf0c1\n\nAdd this line to your `package.xml` in the `hello_moveit` project after the\nother `<depend>` statements:\n\n    \n    \n    <depend>moveit_visual_tools</depend>\n    \n\nThen in your `CMakeLists.txt` add this line to the section of `find_package`\nstatements:\n\n    \n    \n    find_package(moveit_visual_tools REQUIRED)\n    \n\nFurther down in the file extend the `ament_target_dependencies` macro call to\ninclude the new dependency like this:\n\n    \n    \n    ament_target_dependencies(\n      hello_moveit\n      \"moveit_ros_planning_interface\"\n      \"moveit_visual_tools\"\n      \"rclcpp\"\n    )\n    \n\nTo verify that you added the dependency correctly, add the required include to\nyour source file `hello_moveit.cpp`:\n\n    \n    \n    #include <moveit_visual_tools/moveit_visual_tools.h>\n    \n\nTo test that this all worked, open a terminal in the workspace directory\n(remembering to source your ROS install in opt) and then build with colcon:\n\n    \n    \n    cd ~/ws_moveit\n    colcon build --mixin debug\n    \n\n### 2 Create a ROS executor and spin the node on a thread\uf0c1\n\nBefore we can initialize MoveItVisualTools, we need to have a executor\nspinning on our ROS node. This is necessary because of how MoveItVisualTools\ninteracts with ROS services and topics. First, add the threading library to\nyour includes at the top.\n\n    \n    \n    #include <thread>  // <---- add this to the set of includes at the top\n    \n\nBy creating and naming loggers, we are able to keep our program logs\norganized.\n\n>\n>     // Create a ROS logger\n>     auto const logger = rclcpp::get_logger(\"hello_moveit\");\n>  \n\nNext, add your executor before creating the MoveIt MoveGroup Interface.\n\n    \n    \n      // Spin up a SingleThreadedExecutor for MoveItVisualTools to interact with ROS\n      rclcpp::executors::SingleThreadedExecutor executor;\n      executor.add_node(node);\n      auto spinner = std::thread([&executor]() { executor.spin(); });\n    \n      // Create the MoveIt MoveGroup Interface\n    \n    ...\n    \n\nFinally, make sure to join the thread before exiting.\n\n    \n    \n    // Shutdown ROS\n    rclcpp::shutdown();  // <--- This will cause the spin function in the thread to return\n    spinner.join();  // <--- Join the thread before exiting\n    return 0;\n    \n\nAfter making these changes, rebuild your workspace to make sure you don\u2019t have\nany syntax errors.\n\n### 3 Create and Initialize MoveItVisualTools\uf0c1\n\nNext, we will construct and initialize MoveItVisualTools after the\nconstruction of MoveGroupInterface.\n\n    \n    \n    // Create the MoveIt MoveGroup Interface\n    using moveit::planning_interface::MoveGroupInterface;\n    auto move_group_interface = MoveGroupInterface(node, \"manipulator\");\n    \n    // Construct and initialize MoveItVisualTools\n    auto moveit_visual_tools = moveit_visual_tools::MoveItVisualTools{\n        node, \"base_link\", rviz_visual_tools::RVIZ_MARKER_TOPIC,\n        move_group_interface.getRobotModel()};\n    moveit_visual_tools.deleteAllMarkers();\n    moveit_visual_tools.loadRemoteControl();\n    \n\nWe pass the following into the constructor: the ROS node, the base link of the\nrobot, the marker topic to use (more on this later), and the robot model\n(which we get from the move_group_interface). Next, we make a call to delete\nall the markers. This clears any rendered state out of RViz that we have left\nover from previous runs. Lastly, we load remote control. Remote control is a\nreally simple plugin that lets us have a button in RViz to interact with our\nprogram.\n\n### 4 Write closures for visualizations\uf0c1\n\nAfter we\u2019ve constructed and initialized, we now create some closures (function\nobjects that have access to variables in our current scope) that we can use\nlater in our program to help render visualizations in RViz.\n\n    \n    \n    // Create closures for visualization\n    auto const draw_title = [&moveit_visual_tools](auto text) {\n      auto const text_pose = [] {\n        auto msg = Eigen::Isometry3d::Identity();\n        msg.translation().z() = 1.0;  // Place text 1m above the base link\n        return msg;\n      }();\n      moveit_visual_tools.publishText(text_pose, text, rviz_visual_tools::WHITE,\n                                      rviz_visual_tools::XLARGE);\n    };\n    auto const prompt = [&moveit_visual_tools](auto text) {\n      moveit_visual_tools.prompt(text);\n    };\n    auto const draw_trajectory_tool_path =\n        [&moveit_visual_tools,\n         jmg = move_group_interface.getRobotModel()->getJointModelGroup(\n             \"manipulator\")](auto const trajectory) {\n          moveit_visual_tools.publishTrajectoryLine(trajectory, jmg);\n        };\n    \n\nEach of the three closures capture `moveit_visual_tools` by reference and the\nlast one captures a pointer to the joint model group object we are planning\nwith. Each of these call a function on `moveit_visual_tools` that changes\nsomething in RViz.\n\n  * The first one, `draw_title` adds text one meter above the base of the robot. This is a useful way to show the state of your program from a high level.\n\n  * The second one calls a function called `prompt`. This function blocks your program until the user presses the `next` button in RViz. This is helpful for stepping through a program when debugging.\n\n  * The last one draws the tool path of a trajectory that we have planned. This is often helpful for understanding a planned trajectory from the perspective of the tool.\n\nYou might be asking yourself why we would create lambdas like this, and the\nreason is simply to make the code that comes later easier to read and\nunderstand. As your write software, it is often helpful to break up your\nfunctionality into named functions which can be easily reused and tested on\ntheir own. You will see in the next section how we use these functions we\ncreated.\n\n### 5 Visualize the steps of your program\uf0c1\n\nNow we\u2019ll augment the code in the middle of your program. Update your code for\nplanning and executing to include these new features:\n\n    \n    \n    // Set a target Pose\n    auto const target_pose = [] {\n      geometry_msgs::msg::Pose msg;\n      msg.orientation.w = 1.0;\n      msg.position.x = 0.28;\n      msg.position.y = -0.2;\n      msg.position.z = 0.5;\n      return msg;\n    }();\n    move_group_interface.setPoseTarget(target_pose);\n    \n    // Create a plan to that target pose\n    prompt(\"Press 'Next' in the RvizVisualToolsGui window to plan\");\n    draw_title(\"Planning\");\n    moveit_visual_tools.trigger();\n    auto const [success, plan] = [&move_group_interface] {\n      moveit::planning_interface::MoveGroupInterface::Plan msg;\n      auto const ok = static_cast<bool>(move_group_interface.plan(msg));\n      return std::make_pair(ok, msg);\n    }();\n    \n    // Execute the plan\n    if (success) {\n      draw_trajectory_tool_path(plan.trajectory);\n      moveit_visual_tools.trigger();\n      prompt(\"Press 'Next' in the RvizVisualToolsGui window to execute\");\n      draw_title(\"Executing\");\n      moveit_visual_tools.trigger();\n      move_group_interface.execute(plan);\n    } else {\n      draw_title(\"Planning Failed!\");\n      moveit_visual_tools.trigger();\n      RCLCPP_ERROR(logger, \"Planning failed!\");\n    }\n    \n\nOne thing you\u2019ll quickly notice is that we have to call a method called\n`trigger` on `moveit_visual_tools` after each call to change something\nrendered in RViz. The reason for this is that messages sent to RViz are\nbatched up and sent when you call `trigger` to reduce bandwidth of the marker\ntopics.\n\nLastly, build your project again to make sure all the code additions are\ncorrect.\n\n    \n    \n    cd ~/ws_moveit\n    source /opt/ros/rolling/setup.bash\n    colcon build --mixin debug\n    \n\n### 6 Enable visualizations in RViz\uf0c1\n\nOpen a new terminal, source the workspace, and then start the demo launch file\nthat opens RViz.\n\n    \n    \n    cd ~/ws_moveit\n    source install/setup.bash\n    ros2 launch moveit2_tutorials demo.launch.py\n    \n\nUncheck \u201cMotionPlanning\u201d in the \u201cDisplays\u201d tab to hide it. We aren\u2019t going to\nbe using the \u201cMotionPlanning\u201d plugin for this next part.\n\nTo add the buttons to interact with the prompts we added to our program open\nthe dialog with the \u201cPanels/Add New Panel\u201d menu:\n\nThen select `RvizVisualToolsGui` and click OK. This will create a new panel on\nthe bottom left with a `Next` button we\u2019ll use later.\n\nFinally, we need to add a `Marker Array` to render the visualizations we\u2019ve\nadded. Click on the \u201cAdd\u201d Button in the \u201cDisplays\u201d panel.\n\nSelect `Marker Array` and click `OK`.\n\nScroll to the bottom of the items in the Displays panel and edit the topic\nthat the new Marker Array is using to `/rviz_visual_tools`.\n\nYou are now ready to run your new program with visualizations.\n\n### 7 Run the Program\uf0c1\n\nIn a new terminal, go to the workspace, source the workspace, and run\n`hello_moveit`:\n\n    \n    \n    cd ~/ws_moveit\n    source install/setup.bash\n    ros2 run hello_moveit hello_moveit\n    \n\nYou\u2019ll notice that your program has stopped with a log that looks like this:\n\n    \n    \n    [INFO] [1652822889.492940200] [hello_moveit.remote_control]: Waiting to continue: Press 'Next' in the RvizVisualToolsGui window to plan\n    \n\nClick the `Next` button in RViz and see your application advance.\n\nYou\u2019ll see after you clicked the next button, your application planned, added\na title above the robot, and drew a line representing the tool path. To\ncontinue, press `Next` again to see your robot execute the plan.\n\n## Summary\uf0c1\n\nYou extended the program you wrote with MoveIt to interact with the Gui in\nRViz, allowing you to step through your program with a button, render some\ntext above the robot, and display the tool path that you planned.\n\n## Further Reading\uf0c1\n\n  * MoveItVisualTools has many more useful features for visualizing robot motions. You can read more about it here.\n\n  * There are also more examples of using `MoveItVisualTools` in MoveItCpp Tutorial.\n\n  * Here is a copy of the full hello_moveit.cpp source.\n\n## Next Step\uf0c1\n\nIn the next tutorial Planning Around Objects, you will expand on the program\nyou built here to add to the collision environment and see the robot plan with\nthese changes.\n\nPrevious Next\n\n* * *\n\n(C) Copyright 2024, PickNik Robotics.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n\n",
                "language": "en"
            },
            "platform": "moveit.picknik.ai",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://moveit.picknik.ai/main/doc/tutorials/visualizing_in_rviz/visualizing_in_rviz.html"
        },
        {
            "id": "52e2e1f9-edff-4c0c-8094-ae5fc3377c1e",
            "content": {
                "Title": "Planning Around Objects \u2014 MoveIt Documentation: Rolling  documentation",
                "Subtitle": null,
                "Content": "  * Tutorials\n    * Getting Started\n    * MoveIt Quickstart in RViz\n    * Your First C++ MoveIt Project\n    * Visualizing In RViz\n    * Planning Around Objects\n      * Prerequisites\n      * Steps\n        * 1 Add include for Planning Scene Interface\n        * 2 Change the Target Pose\n        * 3 Create a Collision Object\n        * 4 Add the Object to the Planning Scene\n        * 5 Run the Program and Observe the Change\n      * Summary\n      * Further Reading\n      * Next Step\n    * Pick and Place with MoveIt Task Constructor\n  * Examples\n  * Concepts\n  * How-To Guides\n  * API Documentation\n  * Contributing\n\n__MoveIt Documentation: Rolling\n\n  *   * Tutorials\n  * Planning Around Objects\n  * Edit on GitHub\n\n* * *\n\n# Planning Around Objects\uf0c1\n\nThis tutorial will introduce you to inserting objects into the planning scene\nand planning around them.\n\n## Prerequisites\uf0c1\n\nIf you haven\u2019t already done so, make sure you\u2019ve completed the steps in\nVisualizing in RViz. This project assumes you are starting with the\n`hello_moveit` project, where the previous tutorial left off. If you just want\nto run the tutorial, you can follow the Docker Guide to start a container with\nthe completed tutorial.\n\n## Steps\uf0c1\n\n### 1 Add include for Planning Scene Interface\uf0c1\n\nAt the top of your source file, add this to the list of includes:\n\n    \n    \n    #include <moveit/planning_scene_interface/planning_scene_interface.h>\n    \n\n### 2 Change the Target Pose\uf0c1\n\nFirst, update the target pose with the following change to make the robot plan\nto a different location:\n\n    \n    \n    // Set a target Pose with updated values !!!\n    auto const target_pose = [] {\n      geometry_msgs::msg::Pose msg;\n      msg.orientation.y = 0.8;\n      msg.orientation.w = 0.6;\n      msg.position.x = 0.1;\n      msg.position.y = 0.4;\n      msg.position.z = 0.4;\n      return msg;\n    }();\n    move_group_interface.setPoseTarget(target_pose);\n    \n\n### 3 Create a Collision Object\uf0c1\n\nIn the next block of code, we create a collision object. The first thing to\nnotice is that it is being placed in the coordinate frame of the robot. If we\nhad a perception system that reported the location of obstacles in our scene,\nthen this is the sort of message it would build. Because this is just an\nexample, we are creating it manually. One thing to notice at the end of this\nblock of code is that we set the operation on this message to `ADD`. This\nresults in the object getting added to the collision scene. Place this code\nblock between setting the target pose from the previous step and creating a\nplan.\n\n    \n    \n    // Create collision object for the robot to avoid\n    auto const collision_object = [frame_id =\n                                     move_group_interface.getPlanningFrame()] {\n      moveit_msgs::msg::CollisionObject collision_object;\n      collision_object.header.frame_id = frame_id;\n      collision_object.id = \"box1\";\n      shape_msgs::msg::SolidPrimitive primitive;\n    \n      // Define the size of the box in meters\n      primitive.type = primitive.BOX;\n      primitive.dimensions.resize(3);\n      primitive.dimensions[primitive.BOX_X] = 0.5;\n      primitive.dimensions[primitive.BOX_Y] = 0.1;\n      primitive.dimensions[primitive.BOX_Z] = 0.5;\n    \n      // Define the pose of the box (relative to the frame_id)\n      geometry_msgs::msg::Pose box_pose;\n      box_pose.orientation.w = 1.0;  // We can leave out the x, y, and z components of the quaternion since they are initialized to 0\n      box_pose.position.x = 0.2;\n      box_pose.position.y = 0.2;\n      box_pose.position.z = 0.25;\n    \n      collision_object.primitives.push_back(primitive);\n      collision_object.primitive_poses.push_back(box_pose);\n      collision_object.operation = collision_object.ADD;\n    \n      return collision_object;\n    }();\n    \n\n### 4 Add the Object to the Planning Scene\uf0c1\n\nFinally, we need to add this object to the collision scene. To do this, we use\nan object called the `PlanningSceneInterface` that uses ROS interfaces to\ncommunicate changes to the planning scene to `MoveGroup`. This code block\nshould directly follow the code block that creates the collision object.\n\n    \n    \n    // Add the collision object to the scene\n    moveit::planning_interface::PlanningSceneInterface planning_scene_interface;\n    planning_scene_interface.applyCollisionObject(collision_object);\n    \n\n### 5 Run the Program and Observe the Change\uf0c1\n\nJust as we did in the last tutorial, start RViz using the `demo.launch.py`\nscript and run our program. If you\u2019re using one of the Docker tutorial\ncontainers, you can specify a different RViz configuration that already has\nthe RvizVisualToolsGui panel added using:\n\n    \n    \n    ros2 launch moveit2_tutorials demo.launch.py rviz_config:=kinova_hello_moveit.rviz\n    \n\n## Summary\uf0c1\n\n  * You extended the program you wrote with MoveIt to plan around an object in the scene.\n\n  * Here is a copy of the full hello_moveit.cpp source.\n\n## Further Reading\uf0c1\n\n  * Examples of using the Planning Scene for collision and constraint checking.\n\n  * Examples of using the Planning Scene ROS API.\n\n  * Example of visualizing collision objects.\n\n  * Example of subframes used for planning with objects.\n\n## Next Step\uf0c1\n\nIn the next tutorial Pick and Place with MoveIt Task Constructor, you will be\nintroduced to a higher layer tool designed to solve harder motion plans. In\nthis next tutorial, you will create a program to pick and place an object.\n\nPrevious Next\n\n* * *\n\n(C) Copyright 2024, PickNik Robotics.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n\n",
                "language": "en"
            },
            "platform": "moveit.picknik.ai",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://moveit.picknik.ai/main/doc/tutorials/planning_around_objects/planning_around_objects.html"
        },
        {
            "id": "71ba1ab9-d3b7-4724-a3cb-722eff9a3b14",
            "content": {
                "Title": "Pick and Place with MoveIt Task Constructor \u2014 MoveIt Documentation: Rolling  documentation",
                "Subtitle": null,
                "Content": "  * Tutorials\n    * Getting Started\n    * MoveIt Quickstart in RViz\n    * Your First C++ MoveIt Project\n    * Visualizing In RViz\n    * Planning Around Objects\n    * Pick and Place with MoveIt Task Constructor\n      * 1 Basic Concepts\n      * 2 Getting Started\n      * 3 Trying It Out\n      * 4 Setting up a Project with MoveIt Task Constructor\n        * 4.1 Create a New Package\n        * 4.2 The Code\n        * 4.3 Code Breakdown\n      * 5 Running the Demo\n        * 5.1 Launch Files\n        * 5.2 RViz Configuration\n        * 5.3 Launching the Demo\n      * 6 Adding Stages\n        * 6.1 Pick Stages\n        * 6.2 Place Stages\n      * 7 Further Discussion\n        * 7.1 Debugging Information Printed to the Terminal\n        * 7.2 Stages\n  * Examples\n  * Concepts\n  * How-To Guides\n  * API Documentation\n  * Contributing\n\n__MoveIt Documentation: Rolling\n\n  *   * Tutorials\n  * Pick and Place with MoveIt Task Constructor\n  * Edit on GitHub\n\n* * *\n\n# Pick and Place with MoveIt Task Constructor\uf0c1\n\nMoveIt Task Constructor Pick and Place example\n\nThis tutorial will walk you through creating a package that plans a pick and\nplace operation using MoveIt Task Constructor. MoveIt Task Constructor\nprovides a way to plan for tasks that consist of multiple different subtasks\n(known as stages). If you just want to run the tutorial, you can follow the\nDocker Guide to start a container with the completed tutorial.\n\n## 1 Basic Concepts\uf0c1\n\nThe fundamental idea of MTC is that complex motion planning problems can be\ncomposed into a set of simpler subproblems. The top-level planning problem is\nspecified as a **Task** while all subproblems are specified by **Stages**.\nStages can be arranged in any arbitrary order and hierarchy only limited by\nthe individual stages types. The order in which stages can be arranged is\nrestricted by the direction in which results are passed. There are three\npossible stages relating to the result flow: generator, propagator, and\nconnector stages:\n\n**Generators** compute their results independently of their neighbor stages\nand pass them in both directions, backwards and forwards. An example is an IK\nsampler for geometric poses where approaching and departing motions (neighbor\nstages) depend on the solution.\n\n**Propagators** receive the result of one neighbor stage, solve a subproblem\nand then propagate their result to the neighbor on the opposite site.\nDepending on the implementation, propagating stages can pass solutions\nforward, backward or in both directions separately. An example is a stage that\ncomputes a Cartesian path based on either a start or a goal state.\n\n**Connectors** do not propagate any results, but rather attempt to bridge the\ngap between the resulting states of both neighbors. An example is the\ncomputation of a free-motion plan from one given state to another.\n\nAdditional to the order types, there are different hierarchy types allowing to\nencapsulate subordinate stages. Stages without subordinate stages are called\n**primitive stages** , higher-level stages are called **container stages**.\nThere are three container types:\n\n**Wrappers** encapsulate a single subordinate stage and modify or filter the\nresults. For example, a filter stage that only accepts solutions of its child\nstage that satisfy a certain constraint can be realized as a wrapper. Another\nstandard use of this type includes the IK wrapper stage, which generates\ninverse kinematics solutions based on planning scenes annotated with a pose\ntarget property.\n\n**Serial Containers** hold a sequence of subordinate stages and only consider\nend-to-end solutions as results. An example is a picking motion that consists\nof a sequence of coherent steps.\n\n**Parallel Containers** combine set of subordinate stages and can be used for\npassing the best of alternative results, running fallback solvers or for\nmerging multiple independent solutions. Examples are running alternative\nplanners for a free-motion plan, picking objects with the right hand or with\nthe left hand as a fallback, or moving the arm and opening the gripper at the\nsame time.\n\nStages not only support solving motion planning problems. They can also be\nused for all kinds of state transitions, as for instance modifying the\nplanning scene. Combined with the possibility of using class inheritance it is\npossible to construct very complex behavior while only relying on a well-\nstructured set of primitive stages.\n\nMore detailed information on MTC can be found in the MoveIt Task Constructor\nconcepts page\n\n## 2 Getting Started\uf0c1\n\nIf you haven\u2019t already done so, make sure you\u2019ve completed the steps in\nGetting Started.\n\nMove into your colcon workspace and pull the MoveIt Task Constructor source,\nwhere `<branch>` can be e.g. `humble` for ROS Humble, or `ros2` for the latest\nversion compatible with MoveIt 2 `main`:\n\n    \n    \n    cd ~/ws_moveit/src\n    git clone -b <branch> https://github.com/moveit/moveit_task_constructor.git\n    \n\nInstall missing packages with rosdep:\n\n    \n    \n    rosdep install --from-paths . --ignore-src --rosdistro $ROS_DISTRO\n    \n\nBuild the workspace:\n\n    \n    \n    cd ~/ws_moveit\n    colcon build --mixin release\n    \n\n## 3 Trying It Out\uf0c1\n\nThe MoveIt Task Constructor package contains several basic examples and a\npick-and-place demo. For all demos you should launch the basic environment:\n\n    \n    \n    ros2 launch moveit_task_constructor_demo demo.launch.py\n    \n\nSubsequently, you can run the individual demos:\n\n    \n    \n    ros2 launch moveit_task_constructor_demo run.launch.py exe:=cartesian\n    ros2 launch moveit_task_constructor_demo run.launch.py exe:=modular\n    ros2 launch moveit_task_constructor_demo run.launch.py exe:=pick_place_demo\n    \n\nOn the right side you should see the **Motion Planning Tasks** panel outlining\nthe hierarchical stage structure of the tasks. When you select a particular\nstage, the list of successful and failed solutions will be shown in the right-\nmost window. Selecting one of those solutions will start its visualization.\n\n## 4 Setting up a Project with MoveIt Task Constructor\uf0c1\n\nThis section walks through the steps required to build a simple task with\nMoveIt Task Constructor.\n\n### 4.1 Create a New Package\uf0c1\n\nCreate a new package with the following command:\n\n    \n    \n    ros2 pkg create \\\n    --build-type ament_cmake \\\n    --dependencies moveit_task_constructor_core rclcpp \\\n    --node-name mtc_node mtc_tutorial\n    \n\nThis will create a new package and folder called `mtc_tutorial` with a\ndependency on `moveit_task_constructor_core` as well as a hello world example\nin `src/mtc_node`.\n\n### 4.2 The Code\uf0c1\n\nOpen `mtc_node.cpp` in your editor of choice, and paste in the following code.\n\n    \n    \n    #include <rclcpp/rclcpp.hpp>\n    #include <moveit/planning_scene/planning_scene.h>\n    #include <moveit/planning_scene_interface/planning_scene_interface.h>\n    #include <moveit/task_constructor/task.h>\n    #include <moveit/task_constructor/solvers.h>\n    #include <moveit/task_constructor/stages.h>\n    #if __has_include(<tf2_geometry_msgs/tf2_geometry_msgs.hpp>)\n    #include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>\n    #else\n    #include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n    #endif\n    #if __has_include(<tf2_eigen/tf2_eigen.hpp>)\n    #include <tf2_eigen/tf2_eigen.hpp>\n    #else\n    #include <tf2_eigen/tf2_eigen.h>\n    #endif\n    \n    static const rclcpp::Logger LOGGER = rclcpp::get_logger(\"mtc_tutorial\");\n    namespace mtc = moveit::task_constructor;\n    \n    class MTCTaskNode\n    {\n    public:\n      MTCTaskNode(const rclcpp::NodeOptions& options);\n    \n      rclcpp::node_interfaces::NodeBaseInterface::SharedPtr getNodeBaseInterface();\n    \n      void doTask();\n    \n      void setupPlanningScene();\n    \n    private:\n      // Compose an MTC task from a series of stages.\n      mtc::Task createTask();\n      mtc::Task task_;\n      rclcpp::Node::SharedPtr node_;\n    };\n    \n    MTCTaskNode::MTCTaskNode(const rclcpp::NodeOptions& options)\n      : node_{ std::make_shared<rclcpp::Node>(\"mtc_node\", options) }\n    {\n    }\n    \n    rclcpp::node_interfaces::NodeBaseInterface::SharedPtr MTCTaskNode::getNodeBaseInterface()\n    {\n      return node_->get_node_base_interface();\n    }\n    \n    void MTCTaskNode::setupPlanningScene()\n    {\n      moveit_msgs::msg::CollisionObject object;\n      object.id = \"object\";\n      object.header.frame_id = \"world\";\n      object.primitives.resize(1);\n      object.primitives[0].type = shape_msgs::msg::SolidPrimitive::CYLINDER;\n      object.primitives[0].dimensions = { 0.1, 0.02 };\n    \n      geometry_msgs::msg::Pose pose;\n      pose.position.x = 0.5;\n      pose.position.y = -0.25;\n      pose.orientation.w = 1.0;\n      object.pose = pose;\n    \n      moveit::planning_interface::PlanningSceneInterface psi;\n      psi.applyCollisionObject(object);\n    }\n    \n    void MTCTaskNode::doTask()\n    {\n      task_ = createTask();\n    \n      try\n      {\n        task_.init();\n      }\n      catch (mtc::InitStageException& e)\n      {\n        RCLCPP_ERROR_STREAM(LOGGER, e);\n        return;\n      }\n    \n      if (!task_.plan(5))\n      {\n        RCLCPP_ERROR_STREAM(LOGGER, \"Task planning failed\");\n        return;\n      }\n      task_.introspection().publishSolution(*task_.solutions().front());\n    \n      auto result = task_.execute(*task_.solutions().front());\n      if (result.val != moveit_msgs::msg::MoveItErrorCodes::SUCCESS)\n      {\n        RCLCPP_ERROR_STREAM(LOGGER, \"Task execution failed\");\n        return;\n      }\n    \n      return;\n    }\n    \n    mtc::Task MTCTaskNode::createTask()\n    {\n      mtc::Task task;\n      task.stages()->setName(\"demo task\");\n      task.loadRobotModel(node_);\n    \n      const auto& arm_group_name = \"panda_arm\";\n      const auto& hand_group_name = \"hand\";\n      const auto& hand_frame = \"panda_hand\";\n    \n      // Set task properties\n      task.setProperty(\"group\", arm_group_name);\n      task.setProperty(\"eef\", hand_group_name);\n      task.setProperty(\"ik_frame\", hand_frame);\n    \n    // Disable warnings for this line, as it's a variable that's set but not used in this example\n    #pragma GCC diagnostic push\n    #pragma GCC diagnostic ignored \"-Wunused-but-set-variable\"\n      mtc::Stage* current_state_ptr = nullptr;  // Forward current_state on to grasp pose generator\n    #pragma GCC diagnostic pop\n    \n      auto stage_state_current = std::make_unique<mtc::stages::CurrentState>(\"current\");\n      current_state_ptr = stage_state_current.get();\n      task.add(std::move(stage_state_current));\n    \n      auto sampling_planner = std::make_shared<mtc::solvers::PipelinePlanner>(node_);\n      auto interpolation_planner = std::make_shared<mtc::solvers::JointInterpolationPlanner>();\n    \n      auto cartesian_planner = std::make_shared<mtc::solvers::CartesianPath>();\n      cartesian_planner->setMaxVelocityScalingFactor(1.0);\n      cartesian_planner->setMaxAccelerationScalingFactor(1.0);\n      cartesian_planner->setStepSize(.01);\n    \n      auto stage_open_hand =\n          std::make_unique<mtc::stages::MoveTo>(\"open hand\", interpolation_planner);\n      stage_open_hand->setGroup(hand_group_name);\n      stage_open_hand->setGoal(\"open\");\n      task.add(std::move(stage_open_hand));\n    \n      return task;\n    }\n    \n    int main(int argc, char** argv)\n    {\n      rclcpp::init(argc, argv);\n    \n      rclcpp::NodeOptions options;\n      options.automatically_declare_parameters_from_overrides(true);\n    \n      auto mtc_task_node = std::make_shared<MTCTaskNode>(options);\n      rclcpp::executors::MultiThreadedExecutor executor;\n    \n      auto spin_thread = std::make_unique<std::thread>([&executor, &mtc_task_node]() {\n        executor.add_node(mtc_task_node->getNodeBaseInterface());\n        executor.spin();\n        executor.remove_node(mtc_task_node->getNodeBaseInterface());\n      });\n    \n      mtc_task_node->setupPlanningScene();\n      mtc_task_node->doTask();\n    \n      spin_thread->join();\n      rclcpp::shutdown();\n      return 0;\n    }\n    \n\n### 4.3 Code Breakdown\uf0c1\n\nThe top of the code includes the ROS and MoveIt Libraries that this package\nuses.\n\n>   * `rclcpp/rclcpp.hpp` includes core ROS2 functionality\n>\n>   * `moveit/planning_scene/planning_scene.h` and\n> `moveit/planning_scene_interface/planning_scene_interface.h` include\n> functionality to interface with the robot model and collision objects\n>\n>   * `moveit/task_constructor/task.h`, `moveit/task_constructor/solvers.h`,\n> and `moveit/task_constructor/stages.h` include different components of\n> MoveIt Task Constructor that are used in the example\n>\n>   * `tf2_geometry_msgs/tf2_geometry_msgs.hpp` and `tf2_eigen/tf2_eigen.hpp`\n> won\u2019t be used in this initial example, but they will be used for pose\n> generation when we add more stages to the MoveIt Task Constructor task.\n>\n>\n\n    \n    \n    #include <rclcpp/rclcpp.hpp>\n    #include <moveit/planning_scene/planning_scene.h>\n    #include <moveit/planning_scene_interface/planning_scene_interface.h>\n    #include <moveit/task_constructor/task.h>\n    #include <moveit/task_constructor/solvers.h>\n    #include <moveit/task_constructor/stages.h>\n    #if __has_include(<tf2_geometry_msgs/tf2_geometry_msgs.hpp>)\n    #include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>\n    #else\n    #include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n    #endif\n    #if __has_include(<tf2_eigen/tf2_eigen.hpp>)\n    #include <tf2_eigen/tf2_eigen.hpp>\n    #else\n    #include <tf2_eigen/tf2_eigen.h>\n    #endif\n    \n\nThe next line gets a logger for our new node. We also create a namespace alias\nfor `moveit::task_constructor` for convenience.\n\n    \n    \n    static const rclcpp::Logger LOGGER = rclcpp::get_logger(\"mtc_tutorial\");\n    namespace mtc = moveit::task_constructor;\n    \n\nWe start by defining a class that will contain the main MoveIt Task\nConstructor functionality. We also declare the MoveIt Task Constructor task\nobject as a member variable for our class: this isn\u2019t strictly necessary for a\ngiven application, but it helps save the task for later visualization\npurposes. We will explore each function individually below.\n\n    \n    \n    class MTCTaskNode\n    {\n    public:\n      MTCTaskNode(const rclcpp::NodeOptions& options);\n    \n      rclcpp::node_interfaces::NodeBaseInterface::SharedPtr getNodeBaseInterface();\n    \n      void doTask();\n    \n      void setupPlanningScene();\n    \n    private:\n      // Compose an MTC task from a series of stages.\n      mtc::Task createTask();\n      mtc::Task task_;\n      rclcpp::Node::SharedPtr node_;\n    };\n    \n\nThese lines initialize the node with specified options (it is the constructor\nof our `MTCTaskNode` class).\n\n    \n    \n    MTCTaskNode::MTCTaskNode(const rclcpp::NodeOptions& options)\n      : node_{ std::make_shared<rclcpp::Node>(\"mtc_node\", options) }\n    {\n    }\n    \n\nThese next lines define a getter function to get the node base interface,\nwhich will be used for the executor later.\n\n    \n    \n    rclcpp::node_interfaces::NodeBaseInterface::SharedPtr MTCTaskNode::getNodeBaseInterface()\n    {\n      return node_->get_node_base_interface();\n    }\n    \n\nThis class method is used to set up the planning scene that is used in the\nexample. It creates a cylinder with dimensions specified by\n`object.primitives[0].dimensions` and position specified by `pose.position.x`\nand `pose.position.y`. You can try changing these numbers to resize and move\nthe cylinder around. If we move the cylinder out of the robot\u2019s reach,\nplanning will fail.\n\n    \n    \n    void MTCTaskNode::setupPlanningScene()\n    {\n      moveit_msgs::msg::CollisionObject object;\n      object.id = \"object\";\n      object.header.frame_id = \"world\";\n      object.primitives.resize(1);\n      object.primitives[0].type = shape_msgs::msg::SolidPrimitive::CYLINDER;\n      object.primitives[0].dimensions = { 0.1, 0.02 };\n    \n      geometry_msgs::msg::Pose pose;\n      pose.position.x = 0.5;\n      pose.position.y = -0.25;\n      object.pose = pose;\n    \n      moveit::planning_interface::PlanningSceneInterface psi;\n      psi.applyCollisionObject(object);\n    }\n    \n\nThis function interfaces with the MoveIt Task Constructor task object. It\nfirst creates a task, which includes setting some properties and adding\nstages. This will be discussed further in the `createTask` function\ndefinition. Next, `task.init()` initializes the task and `task.plan(5)`\ngenerates a plan, stopping after 5 successful plans are found. The next line\npublishes the solution to be visualized in RViz - this line can be removed if\nyou don\u2019t care for visualization. Finally, `task.execute()` executes the plan.\nExecution occurs via an action server interface with the RViz plugin.\n\n    \n    \n    void MTCTaskNode::doTask()\n    {\n      task_ = createTask();\n    \n      try\n      {\n        task_.init();\n      }\n      catch (mtc::InitStageException& e)\n      {\n        RCLCPP_ERROR_STREAM(LOGGER, e);\n        return;\n      }\n    \n      if (!task_.plan(5))\n      {\n        RCLCPP_ERROR_STREAM(LOGGER, \"Task planning failed\");\n        return;\n      }\n      task_.introspection().publishSolution(*task_.solutions().front());\n    \n      auto result = task_.execute(*task_.solutions().front());\n      if (result.val != moveit_msgs::msg::MoveItErrorCodes::SUCCESS)\n      {\n        RCLCPP_ERROR_STREAM(LOGGER, \"Task execution failed\");\n        return;\n      }\n    \n      return;\n    }\n    \n\nAs mentioned above, this function creates a MoveIt Task Constructor object and\nsets some initial properties. In this case, we set the task name to\n\u201cdemo_task\u201d, load the robot model, define the names of some useful frames, and\nset those frame names as properties of the task with\n`task.setProperty(property_name, value)`. The next few code blocks will fill\nout this function body.\n\n    \n    \n    mtc::Task MTCTaskNode::createTask()\n    {\n      moveit::task_constructor::Task task;\n      task.stages()->setName(\"demo task\");\n      task.loadRobotModel(node_);\n    \n      const auto& arm_group_name = \"panda_arm\";\n      const auto& hand_group_name = \"hand\";\n      const auto& hand_frame = \"panda_hand\";\n    \n      // Set task properties\n      task.setProperty(\"group\", arm_group_name);\n      task.setProperty(\"eef\", hand_group_name);\n      task.setProperty(\"ik_frame\", hand_frame);\n    \n\nNow, we add an example stage to the node. The first line sets\n`current_state_ptr` to `nullptr`; this creates a pointer to a stage such that\nwe can reuse stage information in specific scenarios. This line is not used at\nthis moment, but will be used later when more stages are added to the task.\nNext, we make a `current_state` stage (a generator stage) and add it to our\ntask - this starts the robot off in its current state. Now that we\u2019ve created\nthe `CurrentState` stage, we save a pointer to it in the `current_state_ptr`\nfor later use.\n\n    \n    \n    mtc::Stage* current_state_ptr = nullptr;  // Forward current_state on to grasp pose generator\n    auto stage_state_current = std::make_unique<mtc::stages::CurrentState>(\"current\");\n    current_state_ptr = stage_state_current.get();\n    task.add(std::move(stage_state_current));\n    \n\nSolvers are used to define the type of robot motion. MoveIt Task Constructor\nhas three options for solvers:\n\n> **PipelinePlanner** uses MoveIt\u2019s planning pipeline, which typically\n> defaults to OMPL.\n>  \n>  \n>     auto sampling_planner =\n> std::make_shared<mtc::solvers::PipelinePlanner>(node_);\n>  \n>\n> **JointInterpolation** is a simple planner that interpolates between the\n> start and goal joint states. It is typically used for simple motions as it\n> computes quickly but doesn\u2019t support complex motions.\n>  \n>  \n>     auto interpolation_planner =\n> std::make_shared<mtc::solvers::JointInterpolationPlanner>();\n>  \n>\n> **CartesianPath** is used to move the end effector in a straight line in\n> Cartesian space.\n>  \n>  \n>     auto cartesian_planner =\n> std::make_shared<mtc::solvers::CartesianPath>();\n>  \n\nFeel free to try out the different solvers and see how the robot motion\nchanges. For the first stage we will use the Cartesian planner, which requires\nthe following properties to be set:\n\n    \n    \n    auto cartesian_planner = std::make_shared<mtc::solvers::CartesianPath>();\n    cartesian_planner->setMaxVelocityScalingFactor(1.0);\n    cartesian_planner->setMaxAccelerationScalingFactor(1.0);\n    cartesian_planner->setStepSize(.01);\n    \n\nNow that we added in the planners, we can add a stage that will move the\nrobot. The following lines use a `MoveTo` stage (a propagator stage). Since\nopening the hand is a relatively simple movement, we can use the joint\ninterpolation planner. This stage plans a move to the \u201copen hand\u201d pose, which\nis a named pose defined in the SRDF for the Panda robot. We return the task\nand finish with the `createTask()` function.\n\n    \n    \n      auto stage_open_hand =\n          std::make_unique<mtc::stages::MoveTo>(\"open hand\", interpolation_planner);\n      stage_open_hand->setGroup(hand_group_name);\n      stage_open_hand->setGoal(\"open\");\n      task.add(std::move(stage_open_hand));\n    \n      return task;\n    }\n    \n\nFinally, we have `main`: the following lines create a node using the class\ndefined above, and calls the class methods to set up and execute a basic MTC\ntask. In this example, we do not cancel the executor once the task has\nfinished executing to keep the node alive to inspect the solutions in RViz.\n\n    \n    \n    int main(int argc, char** argv)\n    {\n      rclcpp::init(argc, argv);\n    \n      rclcpp::NodeOptions options;\n      options.automatically_declare_parameters_from_overrides(true);\n    \n      auto mtc_task_node = std::make_shared<MTCTaskNode>(options);\n      rclcpp::executors::MultiThreadedExecutor executor;\n    \n      auto spin_thread = std::make_unique<std::thread>([&executor, &mtc_task_node]() {\n        executor.add_node(mtc_task_node->getNodeBaseInterface());\n        executor.spin();\n        executor.remove_node(mtc_task_node->getNodeBaseInterface());\n      });\n    \n      mtc_task_node->setupPlanningScene();\n      mtc_task_node->doTask();\n    \n      spin_thread->join();\n      rclcpp::shutdown();\n      return 0;\n    }\n    \n\n## 5 Running the Demo\uf0c1\n\n### 5.1 Launch Files\uf0c1\n\nWe will need a launch file to launch the `move_group`, `ros2_control`,\n`static_tf`, `robot_state_publisher`, and `rviz` nodes that provide us the\nenvironment to run the demo. The one we will use for this example can be found\nhere.\n\nTo run the MoveIt Task Constructor node, we will use a second launch file to\nstart the `mtc_tutorial` executable with the proper parameters. Here we can\nload URDF, SRDF, and OMPL parameters, or use MoveIt Configs Utils to do so.\nYour launch file should look something like the one found in this tutorial\npackage here (pay close attention to the `package` and `executable` arguments\nbelow as they are different from the launch file linked) :\n\n    \n    \n    from launch import LaunchDescription\n    from launch_ros.actions import Node\n    from moveit_configs_utils import MoveItConfigsBuilder\n    \n    def generate_launch_description():\n        moveit_config = MoveItConfigsBuilder(\"moveit_resources_panda\").to_dict()\n    \n        # MTC Demo node\n        pick_place_demo = Node(\n            package=\"mtc_tutorial\",\n            executable=\"mtc_node\",\n            output=\"screen\",\n            parameters=[\n                moveit_config,\n            ],\n        )\n    \n        return LaunchDescription([pick_place_demo])\n    \n\nSave a launch file as `pick_place_demo.launch.py` or download one to the\npackage\u2019s launch directory. Make sure to edit the `CMakeLists.txt` so it\nincludes the launch folder by adding the following lines:\n\n    \n    \n    install(DIRECTORY launch\n      DESTINATION share/${PROJECT_NAME}\n      )\n    \n\nNow we can build and source the colcon workspace.\n\n    \n    \n    cd ~/ws_moveit\n    colcon build --mixin release\n    source ~/ws_moveit/install/setup.bash\n    \n\nStart by launching the first launch file. If you want to use the one provided\nby the tutorials:\n\n    \n    \n    ros2 launch moveit2_tutorials mtc_demo.launch.py\n    \n\nRViz will now load. If you\u2019re using your own launch file and haven\u2019t included\nan rviz config such as this, you will need to configure RViz before you see\nanything displayed. If you\u2019re using the launch file from the tutorials\npackage, RViz will already be configured for you and you can jump to the end\nof the next section.\n\n### 5.2 RViz Configuration\uf0c1\n\nIf you are not using the RViz configuration provided, we\u2019ll have to make some\nchanges to the RViz configuration to see your robot and the MoveIt Task\nConstructor solutions. First, start RViz. The following steps will cover how\nto set up RViz for MoveIt Task Constructor solution visualization.\n\n  1. If the **MotionPlanning** display is active, uncheck it to hide it for now.\n\n  2. Under **Global Options** , change the **Fixed Frame** from `map` to `panda_link0` if not already done.\n\n  3. On the bottom left of the window, click the **Add** button.\n\n  4. Under `moveit_task_constructor_visualization` select **Motion Planning Tasks** and click OK. The **Motion Planning Tasks** display should appear on the bottom left.\n\n  5. In the **Displays** , under **Motion Planning Tasks** , change **Task Solution Topic** to `/solution`\n\nYou should see the panda arm in the main view with Motion Planning Tasks\ndisplay open in the bottom left and nothing in it. Your MTC task will show up\nin this panel once you launch the `mtc_tutorial` node. If you\u2019re using\n`mtc_demo.launch.py` from the tutorials, jump back in here.\n\n### 5.3 Launching the Demo\uf0c1\n\nLaunch the `mtc_tutorial` node with\n\n    \n    \n    ros2 launch mtc_tutorial pick_place_demo.launch.py\n    \n\nYou should see the arm execute the task with the single stage to open the\nhand, with the cylinder in green in front of it. It should look something like\nthis:\n\nIf you haven\u2019t made your own package, but still want to see what this looks\nlike, you can launch this file from the tutorials:\n\n    \n    \n    ros2 launch moveit2_tutorials mtc_demo_minimal.launch.py\n    \n\n## 6 Adding Stages\uf0c1\n\nSo far, we\u2019ve walked through creating and executing a simple task, which runs\nbut does not do much. Now, we will start adding the pick-and-place stages to\nthe task. The image below shows an outline of the stages we will use in our\ntask.\n\nWe will start adding stages after our existing open hand stage. Open\n`mtc_node.cpp` and locate the following lines:\n\n    \n    \n    auto stage_open_hand =\n        std::make_unique<mtc::stages::MoveTo>(\"open hand\", interpolation_planner);\n    stage_open_hand->setGroup(hand_group_name);\n    stage_open_hand->setGoal(\"open\");\n    task.add(std::move(stage_open_hand));\n    // Add the next lines of codes to define more stages here\n    \n\n### 6.1 Pick Stages\uf0c1\n\nWe need to move the arm to a position where we can pick up our object. This is\ndone with a `Connect` stage, which as its name implies, is a Connector stage.\nThis means that it tries to bridge between the results of the stage before and\nafter it. This stage is initialized with a name, `move_to_pick`, and a\n`GroupPlannerVector` that specifies the planning group and the planner. We\nthen set a timeout for the stage, set the properties for the stage, and add it\nto our task.\n\n    \n    \n    auto stage_move_to_pick = std::make_unique<mtc::stages::Connect>(\n        \"move to pick\",\n        mtc::stages::Connect::GroupPlannerVector{ { arm_group_name, sampling_planner } });\n    stage_move_to_pick->setTimeout(5.0);\n    stage_move_to_pick->properties().configureInitFrom(mtc::Stage::PARENT);\n    task.add(std::move(stage_move_to_pick));\n    \n\nNext, we create a pointer to a MoveIt Task Constructor stage object, and set\nit to `nullptr` for now. Later, we will use this to save a stage.\n\n    \n    \n    mtc::Stage* attach_object_stage =\n        nullptr;  // Forward attach_object_stage to place pose generator\n    \n\nThis next block of code creates a `SerialContainer`. This is a container that\ncan be added to our task and can hold several substages. In this case, we\ncreate a serial container that will contain the stages relevant to the picking\naction. Instead of adding the stages to the task, we will add the relevant\nstages to the serial container. We use `exposeTo()` to declare the task\nproperties from the parent task in the new serial container, and use\n`configureInitFrom()` to initialize them. This allows the contained stages to\naccess these properties.\n\n    \n    \n    {\n      auto grasp = std::make_unique<mtc::SerialContainer>(\"pick object\");\n      task.properties().exposeTo(grasp->properties(), { \"eef\", \"group\", \"ik_frame\" });\n      grasp->properties().configureInitFrom(mtc::Stage::PARENT,\n                                            { \"eef\", \"group\", \"ik_frame\" });\n    \n\nWe then create a stage to approach the object. This stage is a `MoveRelative`\nstage, which allows us to specify a relative movement from our current\nposition. `MoveRelative` is a propagator stage: it receives the solution from\nits neighbouring stages and propagates it to the next or previous stage. Using\n`cartesian_planner` finds a solution that involves moving the end effector in\na straight line. We set the properties, and set the minimum and maximum\ndistance to move. Now we create a `Vector3Stamped` message to indicate the\ndirection we want to move - in this case, in the Z direction from the hand\nframe. Finally, we add this stage to our serial container\n\n    \n    \n    {\n      auto stage =\n          std::make_unique<mtc::stages::MoveRelative>(\"approach object\", cartesian_planner);\n      stage->properties().set(\"marker_ns\", \"approach_object\");\n      stage->properties().set(\"link\", hand_frame);\n      stage->properties().configureInitFrom(mtc::Stage::PARENT, { \"group\" });\n      stage->setMinMaxDistance(0.1, 0.15);\n    \n      // Set hand forward direction\n      geometry_msgs::msg::Vector3Stamped vec;\n      vec.header.frame_id = hand_frame;\n      vec.vector.z = 1.0;\n      stage->setDirection(vec);\n      grasp->insert(std::move(stage));\n    }\n    \n\nNow, create a stage to generate the grasp pose. This is a generator stage, so\nit computes its results without regard to the stages before and after it. The\nfirst stage, `CurrentState` is a generator stage as well - to connect the\nfirst stage and this stage, a connecting stage must be used, which we already\ncreated above. This code sets the stage properties, sets the pose before\ngrasping, the angle delta, and the monitored stage. Angle delta is a property\nof the `GenerateGraspPose` stage that is used to determine the number of poses\nto generate; when generating solutions, MoveIt Task Constructor will try to\ngrasp the object from many different orientations, with the difference between\nthe orientations specified by the angle delta. The smaller the delta, the\ncloser together the grasp orientations will be. When defining the current\nstage, we set `current_state_ptr`, which is now used to forward information\nabout the object pose and shape to the inverse kinematics solver. This stage\nwon\u2019t be directly added to the serial container like previously, as we still\nneed to do inverse kinematics on the poses it generates.\n\n    \n    \n    {\n      // Sample grasp pose\n      auto stage = std::make_unique<mtc::stages::GenerateGraspPose>(\"generate grasp pose\");\n      stage->properties().configureInitFrom(mtc::Stage::PARENT);\n      stage->properties().set(\"marker_ns\", \"grasp_pose\");\n      stage->setPreGraspPose(\"open\");\n      stage->setObject(\"object\");\n      stage->setAngleDelta(M_PI / 12);\n      stage->setMonitoredStage(current_state_ptr);  // Hook into current state\n    \n\nBefore we compute inverse kinematics for the poses generated above, we first\nneed to define the frame. This can be done with a `PoseStamped` message from\n`geometry_msgs` or in this case, we define the transform using Eigen\ntransformation matrix and the name of the relevant link. Here, we define the\ntransformation matrix.\n\n    \n    \n    Eigen::Isometry3d grasp_frame_transform;\n    Eigen::Quaterniond q = Eigen::AngleAxisd(M_PI / 2, Eigen::Vector3d::UnitX()) *\n                          Eigen::AngleAxisd(M_PI / 2, Eigen::Vector3d::UnitY()) *\n                          Eigen::AngleAxisd(M_PI / 2, Eigen::Vector3d::UnitZ());\n    grasp_frame_transform.linear() = q.matrix();\n    grasp_frame_transform.translation().z() = 0.1;\n    \n\nNow, we create the `ComputeIK` stage, and give it the name `generate pose IK`\nas well as the `generate grasp pose` stage defined above. Some robots have\nmultiple inverse kinematics solutions for a given pose - we set the limit on\nthe amount of solutions to solve for up to 8. We also set the minimum solution\ndistance, which is a threshold on how different solutions must be: if the\njoint positions in a solution are too similar to a previous solution, it will\nbe marked as invalid. Next, we configure some additional properties, and add\nthe `ComputeIK` stage to the serial container.\n\n    \n    \n      // Compute IK\n      auto wrapper =\n          std::make_unique<mtc::stages::ComputeIK>(\"grasp pose IK\", std::move(stage));\n      wrapper->setMaxIKSolutions(8);\n      wrapper->setMinSolutionDistance(1.0);\n      wrapper->setIKFrame(grasp_frame_transform, hand_frame);\n      wrapper->properties().configureInitFrom(mtc::Stage::PARENT, { \"eef\", \"group\" });\n      wrapper->properties().configureInitFrom(mtc::Stage::INTERFACE, { \"target_pose\" });\n      grasp->insert(std::move(wrapper));\n    }\n    \n\nTo pick up the object, we must allow collision between the hand and the\nobject. This can be done with a `ModifyPlanningScene` stage. The\n`allowCollisions` function lets us specify which collisions to disable.\n`allowCollisions` can be used with a container of names, so we can use\n`getLinkModelNamesWithCollisionGeometry` to get all the names of links with\ncollision geometry in the hand group.\n\n    \n    \n    {\n      auto stage =\n          std::make_unique<mtc::stages::ModifyPlanningScene>(\"allow collision (hand,object)\");\n      stage->allowCollisions(\"object\",\n                            task.getRobotModel()\n                                ->getJointModelGroup(hand_group_name)\n                                ->getLinkModelNamesWithCollisionGeometry(),\n                            true);\n      grasp->insert(std::move(stage));\n    }\n    \n\nWith collisions allowed, we now can close the hand. This is done with a\n`MoveTo` stage, similarly to the `open hand` stage from above, except moving\nto the `close` position as defined in the SRDF.\n\n    \n    \n    {\n      auto stage = std::make_unique<mtc::stages::MoveTo>(\"close hand\", interpolation_planner);\n      stage->setGroup(hand_group_name);\n      stage->setGoal(\"close\");\n      grasp->insert(std::move(stage));\n    }\n    \n\nWe now use a `ModifyPlanningScene` stage again, this time to attach the object\nto the hand using `attachObject`. Similarly to what we did with the\n`current_state_ptr`, we get a pointer to this stage for later use when\ngenerating the place pose for the object.\n\n    \n    \n    {\n      auto stage = std::make_unique<mtc::stages::ModifyPlanningScene>(\"attach object\");\n      stage->attachObject(\"object\", hand_frame);\n      attach_object_stage = stage.get();\n      grasp->insert(std::move(stage));\n    }\n    \n\nNext, we lift the object with a `MoveRelative` stage, similarly to the\n`approach_object` stage.\n\n    \n    \n    {\n      auto stage =\n          std::make_unique<mtc::stages::MoveRelative>(\"lift object\", cartesian_planner);\n      stage->properties().configureInitFrom(mtc::Stage::PARENT, { \"group\" });\n      stage->setMinMaxDistance(0.1, 0.3);\n      stage->setIKFrame(hand_frame);\n      stage->properties().set(\"marker_ns\", \"lift_object\");\n    \n      // Set upward direction\n      geometry_msgs::msg::Vector3Stamped vec;\n      vec.header.frame_id = \"world\";\n      vec.vector.z = 1.0;\n      stage->setDirection(vec);\n      grasp->insert(std::move(stage));\n    }\n    \n\nWith this, we have all the stages needed to pick the object. Now, we add the\nserial container (with all its substages) to the task. If you build the\npackage as-is, you can see the robot plan to pick up the object.\n\n    \n    \n      task.add(std::move(grasp));\n    }\n    \n\nTo test out the newly created stage, build the code and execute:\n\n    \n    \n    ros2 launch mtc_tutorial pick_place_demo.launch.py\n    \n\n### 6.2 Place Stages\uf0c1\n\nNow that the stages that define the pick are complete, we move on to defining\nthe stages for placing the object. Picking up where we left off, we add a\n`Connect` stage to connect the two, as we will soon be using a generator stage\nto generate the pose for placing the object.\n\n    \n    \n    {\n      auto stage_move_to_place = std::make_unique<mtc::stages::Connect>(\n          \"move to place\",\n          mtc::stages::Connect::GroupPlannerVector{ { arm_group_name, sampling_planner },\n                                                    { hand_group_name, interpolation_planner } });\n      stage_move_to_place->setTimeout(5.0);\n      stage_move_to_place->properties().configureInitFrom(mtc::Stage::PARENT);\n      task.add(std::move(stage_move_to_place));\n    }\n    \n\nWe also create a serial container for the place stages. This is done similarly\nto the pick serial container. The next stages will be added to the serial\ncontainer rather than the task.\n\n    \n    \n    {\n      auto place = std::make_unique<mtc::SerialContainer>(\"place object\");\n      task.properties().exposeTo(place->properties(), { \"eef\", \"group\", \"ik_frame\" });\n      place->properties().configureInitFrom(mtc::Stage::PARENT,\n                                            { \"eef\", \"group\", \"ik_frame\" });\n    \n\nThis next stage generates the poses used to place the object and compute the\ninverse kinematics for those poses - it is somewhat similar to the `generate\ngrasp pose` stage from the pick serial container. We start by creating a stage\nto generate the poses and inheriting the task properties. We specify the pose\nwhere we want to place the object with a `PoseStamped` message from\n`geometry_msgs` \\- in this case, we choose `y = 0.5` in the `\"object\"` frame.\nWe then pass the target pose to the stage with `setPose`. Next, we use\n`setMonitoredStage` and pass it the pointer to the `attach_object` stage from\nearlier. This allows the stage to know how the object is attached. We then\ncreate a `ComputeIK` stage and pass it our `GeneratePlacePose` stage - the\nrest follows the same logic as above with the pick stages.\n\n    \n    \n    {\n      // Sample place pose\n      auto stage = std::make_unique<mtc::stages::GeneratePlacePose>(\"generate place pose\");\n      stage->properties().configureInitFrom(mtc::Stage::PARENT);\n      stage->properties().set(\"marker_ns\", \"place_pose\");\n      stage->setObject(\"object\");\n    \n      geometry_msgs::msg::PoseStamped target_pose_msg;\n      target_pose_msg.header.frame_id = \"object\";\n      target_pose_msg.pose.position.y = 0.5;\n      target_pose_msg.pose.orientation.w = 1.0;\n      stage->setPose(target_pose_msg);\n      stage->setMonitoredStage(attach_object_stage);  // Hook into attach_object_stage\n    \n      // Compute IK\n      auto wrapper =\n          std::make_unique<mtc::stages::ComputeIK>(\"place pose IK\", std::move(stage));\n      wrapper->setMaxIKSolutions(2);\n      wrapper->setMinSolutionDistance(1.0);\n      wrapper->setIKFrame(\"object\");\n      wrapper->properties().configureInitFrom(mtc::Stage::PARENT, { \"eef\", \"group\" });\n      wrapper->properties().configureInitFrom(mtc::Stage::INTERFACE, { \"target_pose\" });\n      place->insert(std::move(wrapper));\n    }\n    \n\nNow that we\u2019re ready to place the object, we open the hand with `MoveTo` stage\nand the joint interpolation planner.\n\n    \n    \n    {\n      auto stage = std::make_unique<mtc::stages::MoveTo>(\"open hand\", interpolation_planner);\n      stage->setGroup(hand_group_name);\n      stage->setGoal(\"open\");\n      place->insert(std::move(stage));\n    }\n    \n\nWe also can re-enable collisions with the object now that we no longer need to\nhold it. This is done using `allowCollisions` almost exactly the same way as\ndisabling collisions, except setting the last argument to `false` rather than\n`true`.\n\n    \n    \n    {\n      auto stage =\n          std::make_unique<mtc::stages::ModifyPlanningScene>(\"forbid collision (hand,object)\");\n      stage->allowCollisions(\"object\",\n                            task.getRobotModel()\n                                ->getJointModelGroup(hand_group_name)\n                                ->getLinkModelNamesWithCollisionGeometry(),\n                            false);\n      place->insert(std::move(stage));\n    }\n    \n\nNow, we can detach the object using `detachObject`.\n\n    \n    \n    {\n      auto stage = std::make_unique<mtc::stages::ModifyPlanningScene>(\"detach object\");\n      stage->detachObject(\"object\", hand_frame);\n      place->insert(std::move(stage));\n    }\n    \n\nWe retreat from the object using a `MoveRelative` stage, which is done\nsimilarly to the `approach object` and `lift object` stages.\n\n    \n    \n    {\n      auto stage = std::make_unique<mtc::stages::MoveRelative>(\"retreat\", cartesian_planner);\n      stage->properties().configureInitFrom(mtc::Stage::PARENT, { \"group\" });\n      stage->setMinMaxDistance(0.1, 0.3);\n      stage->setIKFrame(hand_frame);\n      stage->properties().set(\"marker_ns\", \"retreat\");\n    \n      // Set retreat direction\n      geometry_msgs::msg::Vector3Stamped vec;\n      vec.header.frame_id = \"world\";\n      vec.vector.x = -0.5;\n      stage->setDirection(vec);\n      place->insert(std::move(stage));\n    }\n    \n\nWe finish our place serial container and add it to the task.\n\n    \n    \n      task.add(std::move(place));\n    }\n    \n\nThe final step is to return home: we use a `MoveTo` stage and pass it the goal\npose of `ready`, which is a pose defined in the Panda SRDF.\n\n    \n    \n    {\n      auto stage = std::make_unique<mtc::stages::MoveTo>(\"return home\", interpolation_planner);\n      stage->properties().configureInitFrom(mtc::Stage::PARENT, { \"group\" });\n      stage->setGoal(\"ready\");\n      task.add(std::move(stage));\n    }\n    \n\nAll these stages should be added above these lines.\n\n    \n    \n      // Stages all added to the task above this line\n    \n      return task;\n    }\n    \n\nCongratulations! You\u2019ve now defined a pick and place task using MoveIt Task\nConstructor! To try it out, build the code and execute:\n\n    \n    \n    ros2 launch mtc_tutorial pick_place_demo.launch.py\n    \n\n## 7 Further Discussion\uf0c1\n\nThe task with each comprising stage is shown in the Motion Planning Tasks\npane. Click on a stage and additional information about the stage will show up\nto the right. The right pane shows different solutions as well as their\nassociated costs. Depending on the stage type and the robot configuration,\nthere may only be one solution shown.\n\nClick one of the solution costs to see an animation of the robot following the\nplan for that stage. Click the \u201cExec\u201d button in the upper-right portion of the\npane to execute the motion.\n\nTo run the complete MoveIt Task Constructor example included with the MoveIt\ntutorials:\n\n    \n    \n    ros2 launch moveit2_tutorials mtc_demo.launch.py\n    \n\nAnd in a second terminal:\n\n    \n    \n    ros2 launch moveit2_tutorials pick_place_demo.launch.py\n    \n\n### 7.1 Debugging Information Printed to the Terminal\uf0c1\n\nWhen running MTC, it prints a diagram like this to terminal:\n\n    \n    \n    [demo_node-1]     1  - \u2190   1 \u2192   -  0 / initial_state\n    [demo_node-1]     -  0 \u2192   0 \u2192   -  0 / move_to_home\n    \n\nThis example^ shows two stages. The first stage (\u201cinitial_state\u201d) is a\n`CurrentState` type of stage, which initializes a `PlanningScene` and captures\nany collision objects that are present at that moment. A pointer to this stage\ncan be used to retrieve the state of the robot. Since `CurrentState` inherits\nfrom `Generator`, it propagates solutions both forward and backward. This is\ndenoted by the arrows in both directions.\n\n  * The first `1` indicates that one solution was successfully propagated backwards to the previous stage.\n\n  * The second `1`, between the arrows, indicates that one solution was generated.\n\n  * The `0` indicates that a solution was not propagated forward successfully to the next stage, because the next stage failed.\n\nThe second stage (\u201cmove_to_home\u201d) is a `MoveTo` type of stage. It inherits its\npropagation direction from the previous stage, so both arrows point forward.\nThe `0`\u2019s indicate that this stage failed completely. From left to right, the\n`0`\u2019s mean:\n\n  * The stage did not receive a solution from the previous stage\n\n  * The stage did not generate a solution\n\n  * The stage did not propagate a solution forward to the next stage\n\nIn this case, we could tell that \u201cmove_to_home\u201d was the root cause of the\nfailure. The problem was a home state that was in collision. Defining a new,\ncollision-free home position fixed the issue.\n\n### 7.2 Stages\uf0c1\n\nInformation about individual stages can be retrieved from the task. For\nexample, here we retrieve the unique ID for a stage:\n\n    \n    \n    uint32_t const unique_stage_id = task_.stages()->findChild(stage_name)->introspectionId();\n    \n\nA `CurrentState` type stage does not just retrieve the current state of the\nrobot. It also initializes a `PlanningScene` object, capturing any collision\nobjects that are present at that moment.\n\nMTC stages can be propagated in forward and backward order. You can easily\ncheck which direction a stage propagates by the arrow in the RViz GUI. When\npropagating backwards, the logic of many operations is reversed. For example,\nto allow collisions with an object in a `ModifyPlanningScene` stage, you would\ncall `allowCollisions(false)` rather than `allowCollisions(true)`. There is a\ndiscussion to be read here.\n\nPrevious Next\n\n* * *\n\n(C) Copyright 2024, PickNik Robotics.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n\n",
                "language": "en"
            },
            "platform": "moveit.picknik.ai",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://moveit.picknik.ai/main/doc/tutorials/pick_and_place_with_moveit_task_constructor/pick_and_place_with_moveit_task_constructor.html"
        },
        {
            "id": "6b6919c7-e2dd-4d9d-9522-ea0003de22be",
            "content": {
                "Title": "Getting Started with Gazebo? \u2014 Gazebo ionic documentation",
                "Subtitle": null,
                "Content": "Skip to main content\n\n__Back to top __ `Ctrl`+`K`\n\n  * Features\n  * Showcase\n  * Docs\n  * Community\n  * More\n    * About\n    * Community\n    * Answers\n    * Blog\n    * Media\n\n__ Search `Ctrl`+`K`\n\n______\n\nAPP\n\n__ Search `Ctrl`+`K`\n\nDocs / Gazebo Ionic\n\nSupported Sep, 2024 to Sep, 2026\n\nRelease:\n\nChoose version\n\n  * Features\n  * Showcase\n  * Docs\n  * Community\n  * More\n    * About\n    * Community\n    * Answers\n    * Blog\n    * Media\n\n______\n\nAPP\n\n  * Get Started\n  * Install __\n    * Binary Ubuntu Install\n    * Binary macOS Install\n    * Binary Windows Install\n    * Ubuntu Source Install\n    * macOS Source Install\n    * Windows Source Install\n    * Troubleshooting\n  * Migration from Ignition\n  * Feature Comparison\n  * Tutorials __\n    * Building your own robot\n    * Moving the robot\n    * SDF worlds\n    * Sensors\n    * Actors\n    * Understanding the GUI\n    * Manipulating Models\n    * Model Insertion from Fuel\n    * Keyboard Shortcuts\n    * Spawn URDF\n    * ROS 2 integration overview\n    * Launch Gazebo from ROS 2\n    * Use ROS 2 to interact with Gazebo\n    * Use ROS 2 to spawn a Gazebo model\n    * ROS 2 interoperability\n    * ROS 2 integration template\n  * ROS/Gazebo Installation __\n    * ROS 2 Gazebo Vendor Packages\n  * Continuous Integration For Gazebo Packages\n  * Gazebo Classic Migration __\n    * Installing Gazebo11 side by side with new Gazebo\n    * Migration from ROS 2 Gazebo Classic\n  * Roadmap\n  * Release Features\n  * Releases\n  * Governance\n  * Development __\n    * Contributing\n    * Continuous Integration\n    * Release process __\n      * Debian/Ubuntu versioning in nightly and prerelease binaries\n    * Release Instructions\n  * Sim Architecture\n  * Fuel __\n    * Content Deletion Policy\n    * Contributing New Model\n    * Contributing New World\n    * Copyright\n    * Data and Privacy Policy\n    * What is Fair Use\n  * Library Reference __\n    * cmake\n    * common\n    * fuel_tools\n    * gui\n    * launch\n    * math\n    * msgs\n    * physics\n    * plugin\n    * rendering\n    * sensors\n    * sim\n    * tools\n    * transport\n    * utils\n    * sdformat\n\n  * __\n  * Getting Started with Gazebo?\n\n# Getting Started with Gazebo?#\n\nWelcome to Gazebo!\n\nWhen you\u2019re ready, follow the next few steps to get up and running with\nsimulation using Gazebo.\n\n## Step 1: Install#\n\nImportant\n\nIf you are a ROS user, please first read our tutorial on ROS/Gazebo\ninstallation\n\nThe recommended installation for new users is the use of binary packages\navailable for the platform to use:\n\nPlatform | Gazebo Versions  \n---|---  \nUbuntu 24.04 Noble | Gazebo Harmonic (recommended), (recommended if using ROS 2 Jazzy) and Gazebo Ionic  \nUbuntu 22.04 Jammy | Gazebo Harmonic (recommended), Gazebo Garden and Gazebo Fortress (recommended if using ROS 2 Humble or Iron)  \nUbuntu 20.04 Focal | Gazebo Garden (recommended), Gazebo Fortress and Gazebo Citadel  \nUbuntu 18.04 Bionic | Gazebo Citadel  \nMac Ventura | Gazebo Harmonic (recommended), Gazebo Garden, Gazebo Fortress and Gazebo Citadel  \nMac Monterey | Gazebo Harmonic (recommended), Gazebo Garden, Gazebo Fortress and Gazebo Citadel  \nWindows | Support via Conda-Forge is not fully functional, as there are known runtime issues see this issue for details.  \n  \nIf the desired platform is not listed above or if a particular feature in a\ngiven Gazebo release is needed, there is an installation package per release\navailable with all the installation options:\n\n  * Gazebo Ionic installation options (EOL 2026 Sep)\n\n  * Gazebo Harmonic (LTS) installation options (EOL 2028 Sep)\n\n  * Gazebo Garden installation options (EOL 2024 Sep)\n\n  * Gazebo Fortress (LTS) installation options (EOL 2026 Sep)\n\n  * Gazebo Citadel (LTS) installation options (EOL 2024 Dec)\n\n## Step 2: Run#\n\nAfter installing Gazebo in Step 1, you can launch Gazebo Sim, a 3D robotics\nsimulator, from a terminal.\n\n  * If you are on macOS, see specific instructions in the macOS section.\n\nLaunch Gazebo by running:\n\n    \n    \n    gz sim shapes.sdf  # Fortress and Citadel use \"ign gazebo\" instead of \"gz sim\"\n    \n\nThis command will launch both the Sim server and Sim GUI with a world that\ncontains three simple shapes.\n\nAdd the `-v 4` command line argument to generate error, warning,\ninformational, and debugging messages on the console.\n\n    \n    \n    gz sim shapes.sdf -v 4  # Fortress and Citadel use \"ign gazebo\" instead of \"gz sim\"\n    \n\nGazebo Sim can also be run headless, i.e. without the GUI, by using the `-s`\n(server only) flag.\n\n    \n    \n    gz sim -s shapes.sdf -v 4  # Fortress and Citadel use \"ign gazebo\" instead of \"gz sim\"\n    \n\nSimilarly, the GUI can be run independently using the `-g` (gui only) flag. On\nstart, the GUI will attempt to connect to a server instance. If a server is\nnot available, then you will see just a blank screen until a server instances\nis started.\n\n## Step 3: Create your own world#\n\nSDF is used to specify the contents of simulation. Take a look at the\navailable SDF tutorials to get started.\n\nModifying an existing SDF world is also a good way to get started. Gazebo Sim\nships with a number of example SDF worlds that you can freely copy and modify.\nThese example SDF files are installed. Many of the SDF files also have\ninstructions located at the top of the SDF file. The instructions typically\ncontain information about how to run Sim with the SDF file in order to\nexperience a particular feature.\n\nThere are a wide variety of simulation resources at your disposal on\nhttps://app.gazebosim.org/fuel. If you find a model you\u2019d like to use, then\nclick on the `<>` icon in the model description page, highlighted in the image\nbelow, to copy an SDF snippet into your clipboard. This snippet can be pasted\ndirectly into your custom SDF file.\n\n## Step 4: Explore and learn#\n\nThis tutorial has covered the basics of getting started with Gazebo. Starting\nwith Citadel, there are more versioned tutorials covering the basics of the\nGUI, creating worlds and robots, and more.\n\nEach Gazebo library also has a set of tutorials and examples. Explore these\nresources, and don\u2019t forget to ask questions and find solutions at\nanswers.gazebosim.org.\n\n## macOS#\n\nOn macOS, you will need to run Gazebo using two terminals, one for the server\nand another for the GUI:\n\n    \n    \n    # launch server in one terminal\n    gz sim -v 4 shapes.sdf -s  # Fortress and Citadel use \"ign gazebo\" instead of \"gz sim\"\n    \n    \n    \n    # launch gui in a separate terminal\n    gz sim -v 4 -g  # Fortress and Citadel use \"ign gazebo\" instead of \"gz sim\"\n    \n\nThe GUI on macOS is currently known to be unstable. Basic interaction with the\n3D scene such as camera view control and translation / rotation tools should\nbe functional. However, some GUI plugins like the Component Inspector may be\nbuggy and interaction with certain GUI elements may cause the GUI to crash.\nPlease ticket an issue at gazebosim/gz-sim if you run into GUI problems on\nmacOS.\n\n__On this page\n\n  * Step 1: Install\n  * Step 2: Run\n  * Step 3: Create your own world\n  * Step 4: Explore and learn\n  * macOS\n\n__Edit on GitHub\n\nCreated using Sphinx 8.1.3.  \n\nBrought to you by Open Robotics.\n\nExcept where otherwise noted, the gazebosim.org web pages are licensed under\nCreative Commons Attribution 3.0.\n\nBuilt with the PyData Sphinx Theme 0.16.0.\n\n",
                "language": "en"
            },
            "platform": "gazebosim.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://gazebosim.org/docs/all/getstarted/"
        },
        {
            "id": "a973ffa2-0067-4177-91ff-1a69332addc0",
            "content": {
                "Title": "Building your own robot \u2014 Gazebo ionic documentation",
                "Subtitle": null,
                "Content": "Skip to main content\n\n__Back to top __ `Ctrl`+`K`\n\n  * Features\n  * Showcase\n  * Docs\n  * Community\n  * More\n    * About\n    * Community\n    * Answers\n    * Blog\n    * Media\n\n__ Search `Ctrl`+`K`\n\n______\n\nAPP\n\n__ Search `Ctrl`+`K`\n\nDocs / Gazebo Ionic\n\nSupported Sep, 2024 to Sep, 2026\n\nRelease:\n\nChoose version\n\n  * Features\n  * Showcase\n  * Docs\n  * Community\n  * More\n    * About\n    * Community\n    * Answers\n    * Blog\n    * Media\n\n______\n\nAPP\n\n  * Get Started\n  * Install __\n    * Binary Ubuntu Install\n    * Binary macOS Install\n    * Binary Windows Install\n    * Ubuntu Source Install\n    * macOS Source Install\n    * Windows Source Install\n    * Troubleshooting\n  * Migration from Ignition\n  * Feature Comparison\n  * Tutorials __\n    * Building your own robot\n    * Moving the robot\n    * SDF worlds\n    * Sensors\n    * Actors\n    * Understanding the GUI\n    * Manipulating Models\n    * Model Insertion from Fuel\n    * Keyboard Shortcuts\n    * Spawn URDF\n    * ROS 2 integration overview\n    * Launch Gazebo from ROS 2\n    * Use ROS 2 to interact with Gazebo\n    * Use ROS 2 to spawn a Gazebo model\n    * ROS 2 interoperability\n    * ROS 2 integration template\n  * ROS/Gazebo Installation __\n    * ROS 2 Gazebo Vendor Packages\n  * Continuous Integration For Gazebo Packages\n  * Gazebo Classic Migration __\n    * Installing Gazebo11 side by side with new Gazebo\n    * Migration from ROS 2 Gazebo Classic\n  * Roadmap\n  * Release Features\n  * Releases\n  * Governance\n  * Development __\n    * Contributing\n    * Continuous Integration\n    * Release process __\n      * Debian/Ubuntu versioning in nightly and prerelease binaries\n    * Release Instructions\n  * Sim Architecture\n  * Fuel __\n    * Content Deletion Policy\n    * Contributing New Model\n    * Contributing New World\n    * Copyright\n    * Data and Privacy Policy\n    * What is Fair Use\n  * Library Reference __\n    * cmake\n    * common\n    * fuel_tools\n    * gui\n    * launch\n    * math\n    * msgs\n    * physics\n    * plugin\n    * rendering\n    * sensors\n    * sim\n    * tools\n    * transport\n    * utils\n    * sdformat\n\n  * __\n  * Gazebo Tutorials\n  * Building your own robot\n\n# Building your own robot#\n\nIn this tutorial we will learn how to build our own robot in SDFormat. We will\nbuild a simple two wheeled robot.\n\nYou can find the finished SDF file for the tutorial here.\n\n## What is SDF#\n\nSDFormat (Simulation Description Format), sometimes abbreviated as SDF, is an\nXML format that describes objects and environments for robot simulators,\nvisualization, and control.\n\n## Building a world#\n\nWe will start by building a simple world and then build our robot in it. Open\na new file called `building_robot.sdf` and copy the following code to it.\n\n    \n    \n    <?xml version=\"1.0\" ?>\n    <sdf version=\"1.10\">\n        <world name=\"car_world\">\n            <physics name=\"1ms\" type=\"ignored\">\n                <max_step_size>0.001</max_step_size>\n                <real_time_factor>1.0</real_time_factor>\n            </physics>\n            <plugin\n                filename=\"gz-sim-physics-system\"\n                name=\"gz::sim::systems::Physics\">\n            </plugin>\n            <plugin\n                filename=\"gz-sim-user-commands-system\"\n                name=\"gz::sim::systems::UserCommands\">\n            </plugin>\n            <plugin\n                filename=\"gz-sim-scene-broadcaster-system\"\n                name=\"gz::sim::systems::SceneBroadcaster\">\n            </plugin>\n    \n            <light type=\"directional\" name=\"sun\">\n                <cast_shadows>true</cast_shadows>\n                <pose>0 0 10 0 0 0</pose>\n                <diffuse>0.8 0.8 0.8 1</diffuse>\n                <specular>0.2 0.2 0.2 1</specular>\n                <attenuation>\n                    <range>1000</range>\n                    <constant>0.9</constant>\n                    <linear>0.01</linear>\n                    <quadratic>0.001</quadratic>\n                </attenuation>\n                <direction>-0.5 0.1 -0.9</direction>\n            </light>\n    \n            <model name=\"ground_plane\">\n                <static>true</static>\n                <link name=\"link\">\n                    <collision name=\"collision\">\n                    <geometry>\n                        <plane>\n                        <normal>0 0 1</normal>\n                        </plane>\n                    </geometry>\n                    </collision>\n                    <visual name=\"visual\">\n                    <geometry>\n                        <plane>\n                        <normal>0 0 1</normal>\n                        <size>100 100</size>\n                        </plane>\n                    </geometry>\n                    <material>\n                        <ambient>0.8 0.8 0.8 1</ambient>\n                        <diffuse>0.8 0.8 0.8 1</diffuse>\n                        <specular>0.8 0.8 0.8 1</specular>\n                    </material>\n                    </visual>\n                </link>\n            </model>\n        </world>\n    </sdf>\n    \n\nSave the file, navigate to the directory where you saved the file and launch\nthe simulator:\n\n`gz sim building_robot.sdf`\n\n**Note** : You can name your file any name and save it anywhere on your\ncomputer.\n\nYou should see an empty world with just a ground plane and a sun light. Check\nWorld demo to learn how to build your own world.\n\n## Building a model#\n\nUnder the `</model>` tag we will add our robot model as follows:\n\n### Defining the model#\n\n    \n    \n    <model name='vehicle_blue' canonical_link='chassis'>\n        <pose relative_to='world'>0 0 0 0 0 0</pose>\n    \n\nHere we define the name of our model `vehicle_blue`, which should be a unique\nname among its siblings (other tags or models on the same level). Each model\nmay have one link designated as the `canonical_link`, the implicit frame of\nthe model is attached to this link. If not defined, the first `<link>` will be\nchosen as the canonical link. The `<pose>` tag is used to define the position\nand orientation of our model and the `relative_to` attribute is used to define\nthe pose of the model relative to any other frame. If `relative_to` is not\ndefined, the model\u2019s `<pose>` will be relative to the world.\n\nLet\u2019s make our pose relative to the `world`. The values inside the pose tag\nare as follows: `<pose>X Y Z R P Y</pose>`, where the `X Y Z` represent the\nposition of the frame and `R P Y` represent the orientation in roll pitch yaw.\nWe set them to zeros which makes the two frames (the model and the world)\nidentical.\n\n## Links forming our robot#\n\nEvery model is a group of `links` (can be just one link) connected together\nwith `joints`.\n\n### Chassis#\n\n    \n    \n        <link name='chassis'>\n            <pose relative_to='__model__'>0.5 0 0.4 0 0 0</pose>\n    \n\nWe define the first link, the `chassis` of our car and it\u2019s pose relative to\nthe `model`.\n\n#### Inertial properties#\n\n    \n    \n        <inertial> <!--inertial properties of the link mass, inertia matix-->\n            <mass>1.14395</mass>\n            <inertia>\n                <ixx>0.095329</ixx>\n                <ixy>0</ixy>\n                <ixz>0</ixz>\n                <iyy>0.381317</iyy>\n                <iyz>0</iyz>\n                <izz>0.476646</izz>\n            </inertia>\n        </inertial>\n    \n\nHere we define the inertial properties of the chassis like the `<mass>` and\nthe `<inertia>` matrix. The values of the inertia matrix for primitive shapes\ncan be calculated using this tool.\n\n#### Visual and collision#\n\n    \n    \n        <visual name='visual'>\n            <geometry>\n                <box>\n                    <size>2.0 1.0 0.5</size>\n                </box>\n            </geometry>\n            <!--let's add color to our link-->\n            <material>\n                <ambient>0.0 0.0 1.0 1</ambient>\n                <diffuse>0.0 0.0 1.0 1</diffuse>\n                <specular>0.0 0.0 1.0 1</specular>\n            </material>\n        </visual>\n    \n\nAs the name suggests, the `<visual>` tag is responsible for how our link will\nlook. We define the shape of our link inside the `<geometry>` tag as a `<box>`\n(cuboid) and then specify the three dimensions (in meters) of this box inside\nthe `<size>` tag. Then, inside the `<material>` tag we define the material of\nour link. Here we defined the `<ambient>`, `<diffuse>` and `<specular>` colors\nin a set of four numbers red/green/blue/alpha each in range [0, 1].\n\n    \n    \n            <collision name='collision'>\n                <geometry>\n                    <box>\n                        <size>2.0 1.0 0.5</size>\n                    </box>\n                </geometry>\n            </collision>\n        </link>\n    </model>\n    \n\nThe `<collision>` tag defines the collision properties of the link, how our\nlink will react with other objects and the effect of the physics engine on it.\n\n**Note** : `<collision>` can be different from the visual properties, for\nexample, simpler collision models are often used to reduce computation time.\n\nAfter copying all the parts above into the world file in order, run the world\nagain:\n\n`gz sim building_robot.sdf`\n\nOur model should look like this:\n\nIn the top left toolbar, click the Translate icon, then select your model. You\nshould see three axes like this:\n\nThese are the axes of our model where red is the x-axis, green is the y-axis\nand blue is the z-axis.\n\n### Left wheel#\n\nLet\u2019s add wheels to our robot. The following code goes after the `</link>` tag\nand before the `</model>` tag. All the links and joints belonging to the same\nmodel should be defined before the `</model>`.\n\n    \n    \n    <link name='left_wheel'>\n        <pose relative_to=\"chassis\">-0.5 0.6 0 -1.5707 0 0</pose>\n        <inertial>\n            <mass>1</mass>\n            <inertia>\n                <ixx>0.043333</ixx>\n                <ixy>0</ixy>\n                <ixz>0</ixz>\n                <iyy>0.043333</iyy>\n                <iyz>0</iyz>\n                <izz>0.08</izz>\n            </inertia>\n        </inertial>\n    \n\nWe defined the name of our link `left_wheel` and then defined its `<pose>`\n`relative_to` the `chassis` link. The wheel needed to be placed on the left to\nthe back of the `chassis` so that\u2019s why we chose the values for `pose` as\n`-0.5 0.6 0`. Also, our wheel is a cylinder, but on its side. That\u2019s why we\ndefined the orientation value as `-1.5707 0 0` which is a `-90` degree\nrotation around the x-axis (the angles are in radians). Then we defined the\n`inertial` properties of the wheel, the `mass` and the `inertia` matrix.\n\n#### Visualization and Collision#\n\n    \n    \n        <visual name='visual'>\n            <geometry>\n                <cylinder>\n                    <radius>0.4</radius>\n                    <length>0.2</length>\n                </cylinder>\n            </geometry>\n            <material>\n                <ambient>1.0 0.0 0.0 1</ambient>\n                <diffuse>1.0 0.0 0.0 1</diffuse>\n                <specular>1.0 0.0 0.0 1</specular>\n            </material>\n        </visual>\n        <collision name='collision'>\n            <geometry>\n                <cylinder>\n                    <radius>0.4</radius>\n                    <length>0.2</length>\n                </cylinder>\n            </geometry>\n        </collision>\n    </link>\n    \n\nThe `<visual>` and the `<collision>` properties are similar to the previous\nlink, except the shape of our link has the shape of `<cylinder>` that requires\ntwo attributes: the `<radius>` and the `<length>` of the cylinder. Save the\nfile and run the world again, our model should look like this:\n\n### Right wheel#\n\n    \n    \n    <!--The same as left wheel but with different position-->\n    <link name='right_wheel'>\n        <pose relative_to=\"chassis\">-0.5 -0.6 0 -1.5707 0 0</pose> <!--angles are in radian-->\n        <inertial>\n            <mass>1</mass>\n            <inertia>\n                <ixx>0.043333</ixx>\n                <ixy>0</ixy>\n                <ixz>0</ixz>\n                <iyy>0.043333</iyy>\n                <iyz>0</iyz>\n                <izz>0.08</izz>\n            </inertia>\n        </inertial>\n        <visual name='visual'>\n            <geometry>\n                <cylinder>\n                    <radius>0.4</radius>\n                    <length>0.2</length>\n                </cylinder>\n            </geometry>\n            <material>\n                <ambient>1.0 0.0 0.0 1</ambient>\n                <diffuse>1.0 0.0 0.0 1</diffuse>\n                <specular>1.0 0.0 0.0 1</specular>\n            </material>\n        </visual>\n        <collision name='collision'>\n            <geometry>\n                <cylinder>\n                    <radius>0.4</radius>\n                    <length>0.2</length>\n                </cylinder>\n            </geometry>\n        </collision>\n    </link>\n    \n\nThe right wheel is similar to the left wheel except for its position.\n\n### Defining an arbitrary frame#\n\nAs of SDF 1.7 (Fortress uses SDF 1.8), we can define arbitrary frames. It\ntakes two attributes:\n\n  * `name`: the name of the frame\n\n  * `attached_to`: the name of the frame or the link to which this frame is attached.\n\nLet\u2019s add a frame for our caster wheel as follows:\n\n    \n    \n    <frame name=\"caster_frame\" attached_to='chassis'>\n        <pose>0.8 0 -0.2 0 0 0</pose>\n    </frame>\n    \n\nWe gave our frame name `caster_frame` and attached it to the `chassis` link,\nthen the `<pose>` tag to define the position and orientation of the frame. We\ndidn\u2019t use the `relative_to` attribute so the pose is with respect to the\nframe named in the `attached_to` attribute, `chassis` in our case.\n\n### Caster wheel#\n\n    \n    \n    <!--caster wheel-->\n    <link name='caster'>\n        <pose relative_to='caster_frame'/>\n        <inertial>\n            <mass>1</mass>\n            <inertia>\n                <ixx>0.016</ixx>\n                <ixy>0</ixy>\n                <ixz>0</ixz>\n                <iyy>0.016</iyy>\n                <iyz>0</iyz>\n                <izz>0.016</izz>\n            </inertia>\n        </inertial>\n        <visual name='visual'>\n            <geometry>\n                <sphere>\n                    <radius>0.2</radius>\n                </sphere>\n            </geometry>\n            <material>\n                <ambient>0.0 1 0.0 1</ambient>\n                <diffuse>0.0 1 0.0 1</diffuse>\n                <specular>0.0 1 0.0 1</specular>\n            </material>\n        </visual>\n        <collision name='collision'>\n            <geometry>\n                <sphere>\n                    <radius>0.2</radius>\n                </sphere>\n            </geometry>\n        </collision>\n    </link>\n    \n\nOur last link is the `caster` and its pose is with respect to the frame\n`caster_frame` we defined above. As you could notice we closed the `pose` tag\nwithout defining the position or the orientation; in this case the pose of the\nlink is the same as (identity) the frame in `relative_to`.\n\nIn the `<visual>` and `<collision>` tags we defined a different shape\n`<sphere>` which requires the `<radius>` of the sphere.\n\n### Connecting links together (joints)#\n\nWe need to connect these links together; here comes the job of the `<joint>`\ntag. The joint tag connects two links together and defines how they will move\nwith respect to each other. Inside the `<joint>` tag we need to define the two\nlinks to connect and their relations (way of movement).\n\n#### Left wheel joint#\n\n    \n    \n    <joint name='left_wheel_joint' type='revolute'>\n        <pose relative_to='left_wheel'/>\n    \n\nOur first joint is the `left_wheel_joint`. It takes two attributes: the name\n`name='left_wheel_joint'` and the type `type='revolute'`. the `revolute` type\ngives 1 rotational degree of freedom with joint limits. The pose of the joint\nis the same as the child link frame, which is the `left_wheel` frame.\n\n    \n    \n        <parent>chassis</parent>\n        <child>left_wheel</child>\n    \n\nEvery joint connects two links (bodies) together. Here we connect the\n`chassis` with the `left_wheel`. `chassis` is the parent link and `left_wheel`\nis the child link.\n\n    \n    \n        <axis>\n            <xyz expressed_in='__model__'>0 1 0</xyz> <!--can be defined as any frame or even arbitrary frames-->\n            <limit>\n                <lower>-1.79769e+308</lower>    <!--negative infinity-->\n                <upper>1.79769e+308</upper>     <!--positive infinity-->\n            </limit>\n        </axis>\n    </joint>\n    \n\nHere we define the axis of rotation. The axis of rotation can be any frame,\nnot just the `parent` or the `child` link. We chose the y-axis with respect to\nthe `model` frame so we put `1` in the y element and zeros in the others. For\nthe revolute joint we need to define the `<limits>` of our rotation angle in\nthe `<lower>` and `<upper>` tags.\n\n**Note** : The angles are in radians.\n\n#### Right wheel joint#\n\nThe `right_wheel_joint` is very similar except for the pose of the joint. This\njoint connects the `right_wheel` with the `chassis`.\n\n    \n    \n    <joint name='right_wheel_joint' type='revolute'>\n        <pose relative_to='right_wheel'/>\n        <parent>chassis</parent>\n        <child>right_wheel</child>\n        <axis>\n            <xyz expressed_in='__model__'>0 1 0</xyz>\n            <limit>\n                <lower>-1.79769e+308</lower>    <!--negative infinity-->\n                <upper>1.79769e+308</upper>     <!--positive infinity-->\n            </limit>\n        </axis>\n    </joint>\n    \n\n#### Caster wheel joint#\n\nFor the caster we need a different type of joint (connection). We used\n`type='ball'` which gives 3 rotational degrees of freedom.\n\n    \n    \n    <joint name='caster_wheel' type='ball'>\n        <parent>chassis</parent>\n        <child>caster</child>\n    </joint>\n    \n\n## Conclusion#\n\nRun the world:\n\n`gz sim building_robot.sdf`\n\nIt should look like this:\n\nHurray! We build our first robot. You can learn more details about SDFormat\ntags here. In the next tutorial we will learn how to move our robot around.\n\n## Video walk-through#\n\nA video walk-through of this tutorial is available from our YouTube channel:\nGazebo tutorials: Building a robot.\n\n__On this page\n\n  * What is SDF\n  * Building a world\n  * Building a model\n    * Defining the model\n  * Links forming our robot\n    * Chassis\n      * Inertial properties\n      * Visual and collision\n    * Left wheel\n      * Visualization and Collision\n    * Right wheel\n    * Defining an arbitrary frame\n    * Caster wheel\n    * Connecting links together (joints)\n      * Left wheel joint\n      * Right wheel joint\n      * Caster wheel joint\n  * Conclusion\n  * Video walk-through\n\n__Edit on GitHub\n\nCreated using Sphinx 8.1.3.  \n\nBrought to you by Open Robotics.\n\nExcept where otherwise noted, the gazebosim.org web pages are licensed under\nCreative Commons Attribution 3.0.\n\nBuilt with the PyData Sphinx Theme 0.16.0.\n\n",
                "language": "en"
            },
            "platform": "gazebosim.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://gazebosim.org/docs/all/building_robot/"
        },
        {
            "id": "eeb635d2-6b32-4261-ac17-60925d71bb28",
            "content": {
                "Title": "Moving the robot \u2014 Gazebo ionic documentation",
                "Subtitle": null,
                "Content": "Skip to main content\n\n__Back to top __ `Ctrl`+`K`\n\n  * Features\n  * Showcase\n  * Docs\n  * Community\n  * More\n    * About\n    * Community\n    * Answers\n    * Blog\n    * Media\n\n__ Search `Ctrl`+`K`\n\n______\n\nAPP\n\n__ Search `Ctrl`+`K`\n\nDocs / Gazebo Ionic\n\nSupported Sep, 2024 to Sep, 2026\n\nRelease:\n\nChoose version\n\n  * Features\n  * Showcase\n  * Docs\n  * Community\n  * More\n    * About\n    * Community\n    * Answers\n    * Blog\n    * Media\n\n______\n\nAPP\n\n  * Get Started\n  * Install __\n    * Binary Ubuntu Install\n    * Binary macOS Install\n    * Binary Windows Install\n    * Ubuntu Source Install\n    * macOS Source Install\n    * Windows Source Install\n    * Troubleshooting\n  * Migration from Ignition\n  * Feature Comparison\n  * Tutorials __\n    * Building your own robot\n    * Moving the robot\n    * SDF worlds\n    * Sensors\n    * Actors\n    * Understanding the GUI\n    * Manipulating Models\n    * Model Insertion from Fuel\n    * Keyboard Shortcuts\n    * Spawn URDF\n    * ROS 2 integration overview\n    * Launch Gazebo from ROS 2\n    * Use ROS 2 to interact with Gazebo\n    * Use ROS 2 to spawn a Gazebo model\n    * ROS 2 interoperability\n    * ROS 2 integration template\n  * ROS/Gazebo Installation __\n    * ROS 2 Gazebo Vendor Packages\n  * Continuous Integration For Gazebo Packages\n  * Gazebo Classic Migration __\n    * Installing Gazebo11 side by side with new Gazebo\n    * Migration from ROS 2 Gazebo Classic\n  * Roadmap\n  * Release Features\n  * Releases\n  * Governance\n  * Development __\n    * Contributing\n    * Continuous Integration\n    * Release process __\n      * Debian/Ubuntu versioning in nightly and prerelease binaries\n    * Release Instructions\n  * Sim Architecture\n  * Fuel __\n    * Content Deletion Policy\n    * Contributing New Model\n    * Contributing New World\n    * Copyright\n    * Data and Privacy Policy\n    * What is Fair Use\n  * Library Reference __\n    * cmake\n    * common\n    * fuel_tools\n    * gui\n    * launch\n    * math\n    * msgs\n    * physics\n    * plugin\n    * rendering\n    * sensors\n    * sim\n    * tools\n    * transport\n    * utils\n    * sdformat\n\n  * __\n  * Gazebo Tutorials\n  * Moving the robot\n\n# Moving the robot#\n\nIn this tutorial we will learn how to move our robot. We will use the robot we\nbuilt in the Build your own robot tutorial. You can download the robot from\nhere. You can also find the finished world of this tutorial here.\n\n## What is a plugin#\n\nTo make our robot move we will use the `diff_drive` plugin. But before doing\nso let\u2019s answer the question \u201cWhat is a plugin?\u201d A plugin is a chunk of code\nthat is compiled as a shared library and inserted into the simulation. Plugins\nmake us control many aspects of the simulation like world, models, etc.\n\n### Diff_drive plugin#\n\n`diff_drive` plugin helps us control our robot, specifically a robot that can\nbe differentially driven. Let\u2019s setup the plugin on our robot. Open the\n`building_robot.sdf` and add the following code within the `vehicle_blue`\nmodel tags.\n\n    \n    \n    <plugin\n        filename=\"gz-sim-diff-drive-system\"\n        name=\"gz::sim::systems::DiffDrive\">\n        <left_joint>left_wheel_joint</left_joint>\n        <right_joint>right_wheel_joint</right_joint>\n        <wheel_separation>1.2</wheel_separation>\n        <wheel_radius>0.4</wheel_radius>\n        <odom_publish_frequency>1</odom_publish_frequency>\n        <topic>cmd_vel</topic>\n    </plugin>\n    \n\nThe `<plugin>` tag has two attributes, `filename` which takes the library file\nname and `name` which takes the name of the plugin. In the `<left_joint>` and\n`<right_joint>` tags we define the joints which connect the left and the right\nwheel with the body of the robot, in our case `left_wheel_joint` and\n`right_wheel_joint`. `<wheel_separation>` takes the distance between the two\nwheels. Our robot has its `left_wheel` at 0.6 m and the `right_wheel` at -0.6\nm in y-axis with respect to the `chassis`, so the `wheel_separation` is 1.2 m.\n`<wheel_radius>` takes the radius of the wheel which was defined in the\n`<radius>` tag under the wheel link. `<odom_publish_frequency>` sets the\nfrequency at which the odometry is published at\n`/model/vehicle_blue/odometry`. `cmd_vel` is the input `<topic>` to the\n`DiffDrive` plugin.\n\n## Topics and Messages#\n\nNow our model is ready. We just need to send commands (messages) to it. These\nmessages will be published (sent) on the `cmd_vel` topic defined above.\n\nA topic is simply a name for grouping a specific set of messages or a\nparticular service. Our model will subscribe (listen) to the messages sent on\nthe `cmd_vel` topic.\n\nLaunch the robot world:\n\n`gz sim building_robot.sdf`\n\nIn another terminal let\u2019s send a message to to our robot:\n\n`gz topic -t \"/cmd_vel\" -m gz.msgs.Twist -p \"linear: {x: 0.5}, angular: {z:\n0.05}\"`\n\nNow you should have your robot moving in the simulation.\n\n**Note:** Don\u2019t forget to press the play button in the simulation.\n\nThe command specifies the topic to publish to after the `-t` option. After the\n`-m` we specify the message type. Our robot expects messages of type `Twist`\nwhich consists of two components, `linear` and `angular`. After the `-p`\noption we specify the content (value) of the message: linear speed `x: 0.5`\nand angular speed `z: 0.05`.\n\n**Hint:** You can know what every topic option does using this command: `gz\ntopic -h`\n\nFor more information about `Topics` and `Messages` in Gazebo check the\nTransport library tutorials\n\n## Moving the robot using the keyboard#\n\nInstead of sending messages from the terminal we will send messages using the\nkeyboard keys. To do so we will add two new plugins: `KeyPublisher` and\n`TriggeredPublisher`.\n\n### KeyPublisher#\n\n`KeyPublisher` is an `gz-gui` plugin that reads the keyboard\u2019s keystrokes and\nsends them on a default topic `/keyboard/keypress`. Let\u2019s try this plugin as\nfollows:\n\n  * In one terminal type\n\n`gz sim building_robot.sdf`\n\n  * In the top right corner click on the plugins dropdown list (vertical ellipsis), click the Key Publisher.\n\n  * In another terminal type\n\n`gz topic -e -t /keyboard/keypress`\n\nThe last command will display all messages sent on `/keyboard/keypress` topic.\n\nIn the Gazebo window press different keys and you should see data (numbers) on\nthe terminal where you run the `gz topic -e -t /keyboard/keypress` command.\n\n    \n    \n    $ gz topic -e -t /keyboard/keypress\n    data: 68\n    \n    data: 85\n    \n    data: 72\n    \n    data: 74\n    \n    data: 81\n    \n    data: 16777235\n    \n    data: 16777234\n    \n    data: 16777237\n    \n    data: 16777236\n    \n\nWe want to map these keystrokes into messages of type `Twist` and publish them\nto the `/cmd_vel` topic which our model listens to. The `TriggeredPublisher`\nplugin will do this.\n\n### Triggered Publisher#\n\nThe `TriggeredPublisher` plugin publishes a user specified message on an\noutput topic in response to an input message that matches user specified\ncriteria. Let\u2019s add the following code under the `<world>` tag:\n\n    \n    \n    <!-- Moving Forward-->\n    <plugin filename=\"gz-sim-triggered-publisher-system\"\n            name=\"gz::sim::systems::TriggeredPublisher\">\n        <input type=\"gz.msgs.Int32\" topic=\"/keyboard/keypress\">\n            <match field=\"data\">16777235</match>\n        </input>\n        <output type=\"gz.msgs.Twist\" topic=\"/cmd_vel\">\n            linear: {x: 0.5}, angular: {z: 0.0}\n        </output>\n    </plugin>\n    \n\nThis code defines the `triggered-publisher` plugin. It accepts messages of\ntype `gz.msgs.Int32` on the `/keyboard/keypress` topic and if the value in the\n`data` field matches `16777235`(Up arrow key) it outputs a `Twist` message on\nthe `cmd_vel` topic with values `x: 0.5`, `z: 0.0`.\n\nNow launch `building_robot.sdf` then add the Key Publisher plugin and our\nrobot should move forward as we press the Up arrow key \u2191 (make sure you start\nthe simulation by pressing the play button to see the robot move forward after\npressing the Up arrow key).\n\nThere is a demo explaining how the Triggered Publisher works.\n\n### Moving using arrow keys#\n\nTo see what values are sent on the `/keyboard/keypress` topic when pressing\nthe arrows we can use the `--echo` or `-e` option\n\n  * Run the model in one terminal:\n\n`gz sim building_robot.sdf`\n\n  * In the top right corner click on the plugins dropdown list (vertical ellipsis), click the Key Publisher.\n\n  * In another terminal run the following command:\n\n`gz topic -e -t /keyboard/keypress`\n\nStart pressing the arrows keys and see what values they give:\n\n  * Left \u2190 : 16777234\n\n  * Up \u2191 : 16777235\n\n  * Right \u2192 : 16777236\n\n  * Down \u2193 : 16777237\n\nWe will add the `Triggered publisher` plugin for each arrow key. For example,\nthe Down arrow:\n\n    \n    \n    <!-- Moving Backward-->\n    <plugin filename=\"gz-sim-triggered-publisher-system\"\n            name=\"gz::sim::systems::TriggeredPublisher\">\n        <input type=\"gz.msgs.Int32\" topic=\"/keyboard/keypress\">\n            <match field=\"data\">16777237</match>\n        </input>\n        <output type=\"gz.msgs.Twist\" topic=\"/cmd_vel\">\n            linear: {x: -0.5}, angular: {z: 0.0}\n        </output>\n    </plugin>\n    \n\nMap each arrow (key stroke) with the desired message (movement) as we did with\nthe backward arrow:\n\n  * Left \u279e 16777234 \u279e linear: {x: 0.0}, angular: {z: 0.5}\n\n  * Up \u279e 16777235 \u279e linear: {x: 0.5}, angular: {z: 0.0}\n\n  * Right \u279e 16777236 \u279e linear: {x: 0.0}, angular: {z: -0.5}\n\n  * Down \u279e 16777237 \u279e linear: {x: -0.5}, angular: {z: 0.0}\n\nNow it\u2019s your turn try to make the robot move using different keys.\n\nIn the next tutorial, you\u2019ll learn to create your own simulated world with\nSDF.\n\n## Video walk-through#\n\nA video walk-through of this tutorial is available from our YouTube channel:\nGazebo tutorials: Moving robot.\n\n__On this page\n\n  * What is a plugin\n    * Diff_drive plugin\n  * Topics and Messages\n  * Moving the robot using the keyboard\n    * KeyPublisher\n    * Triggered Publisher\n    * Moving using arrow keys\n  * Video walk-through\n\n__Edit on GitHub\n\nCreated using Sphinx 8.1.3.  \n\nBrought to you by Open Robotics.\n\nExcept where otherwise noted, the gazebosim.org web pages are licensed under\nCreative Commons Attribution 3.0.\n\nBuilt with the PyData Sphinx Theme 0.16.0.\n\n",
                "language": "en"
            },
            "platform": "gazebosim.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://gazebosim.org/docs/all/moving_robot/"
        },
        {
            "id": "aa6e0cbd-d113-42b6-bdfb-602d2c336a5d",
            "content": {
                "Title": "SDF worlds \u2014 Gazebo ionic documentation",
                "Subtitle": null,
                "Content": "Skip to main content\n\n__Back to top __ `Ctrl`+`K`\n\n  * Features\n  * Showcase\n  * Docs\n  * Community\n  * More\n    * About\n    * Community\n    * Answers\n    * Blog\n    * Media\n\n__ Search `Ctrl`+`K`\n\n______\n\nAPP\n\n__ Search `Ctrl`+`K`\n\nDocs / Gazebo Ionic\n\nSupported Sep, 2024 to Sep, 2026\n\nRelease:\n\nChoose version\n\n  * Features\n  * Showcase\n  * Docs\n  * Community\n  * More\n    * About\n    * Community\n    * Answers\n    * Blog\n    * Media\n\n______\n\nAPP\n\n  * Get Started\n  * Install __\n    * Binary Ubuntu Install\n    * Binary macOS Install\n    * Binary Windows Install\n    * Ubuntu Source Install\n    * macOS Source Install\n    * Windows Source Install\n    * Troubleshooting\n  * Migration from Ignition\n  * Feature Comparison\n  * Tutorials __\n    * Building your own robot\n    * Moving the robot\n    * SDF worlds\n    * Sensors\n    * Actors\n    * Understanding the GUI\n    * Manipulating Models\n    * Model Insertion from Fuel\n    * Keyboard Shortcuts\n    * Spawn URDF\n    * ROS 2 integration overview\n    * Launch Gazebo from ROS 2\n    * Use ROS 2 to interact with Gazebo\n    * Use ROS 2 to spawn a Gazebo model\n    * ROS 2 interoperability\n    * ROS 2 integration template\n  * ROS/Gazebo Installation __\n    * ROS 2 Gazebo Vendor Packages\n  * Continuous Integration For Gazebo Packages\n  * Gazebo Classic Migration __\n    * Installing Gazebo11 side by side with new Gazebo\n    * Migration from ROS 2 Gazebo Classic\n  * Roadmap\n  * Release Features\n  * Releases\n  * Governance\n  * Development __\n    * Contributing\n    * Continuous Integration\n    * Release process __\n      * Debian/Ubuntu versioning in nightly and prerelease binaries\n    * Release Instructions\n  * Sim Architecture\n  * Fuel __\n    * Content Deletion Policy\n    * Contributing New Model\n    * Contributing New World\n    * Copyright\n    * Data and Privacy Policy\n    * What is Fair Use\n  * Library Reference __\n    * cmake\n    * common\n    * fuel_tools\n    * gui\n    * launch\n    * math\n    * msgs\n    * physics\n    * plugin\n    * rendering\n    * sensors\n    * sim\n    * tools\n    * transport\n    * utils\n    * sdformat\n\n  * __\n  * Gazebo Tutorials\n  * SDF worlds\n\n# SDF worlds#\n\nIn this tutorial we will learn how to build our world using SDF, and how to\nadd models to it. Open your text editor and add code as you follow along with\nthis tutorial. You can also download the finished world for this tutorial from\nhere.\n\n## Defining a world#\n\nEvery SDF world starts with these tags.\n\n    \n    \n    <?xml version=\"1.0\" ?>\n    <sdf version=\"1.8\">\n        <world name=\"world_demo\">\n        ...\n        ...\n        </world>\n    </sdf>\n    \n\nThe first two tags define the version of the `XML` and the `SDF`. Then we have\nthe `<world> </world>` tags between which everything goes.\n\n## Physics#\n\n    \n    \n    <physics name=\"1ms\" type=\"ignored\">\n        <max_step_size>0.001</max_step_size>\n        <real_time_factor>1.0</real_time_factor>\n    </physics>\n    \n\nThe physics tag specifies the type and properties of the dynamic engine. We\nchose the `name` `1ms` as the step size is 1 millisecond. The `type` is the\ntype of the dynamic engine (physics library). There are options like, Ode,\nBullet, Simbody and Dart. We set it to `ignored`, as choosing the type of the\nphysics engine is not done through this tag yet.\n\n`<max_step_size>` is the maximum time at which every system in simulation can\ninteract with the states of the world. The smaller the value, the more\naccurate your calculations, but more computation power is needed.\n`<real_time_factor>` is the ratio of simulation time to real time.\n\n## Plugins#\n\nPlugins are a dynamically loaded chunk of code. For example:\n\n    \n    \n    <plugin\n        filename=\"gz-sim-physics-system\"\n        name=\"gz::sim::systems::Physics\">\n    </plugin>\n    \n\nThe `Physics` plugin is very important for simulating the dynamics of the\nworld.\n\n    \n    \n    <plugin\n        filename=\"gz-sim-user-commands-system\"\n        name=\"gz::sim::systems::UserCommands\">\n    </plugin>\n    \n\nThe `UserCommands` plugin is responsible for creating models, moving models,\ndeleting them and many other user commands.\n\n    \n    \n    <plugin\n        filename=\"gz-sim-scene-broadcaster-system\"\n        name=\"gz::sim::systems::SceneBroadcaster\">\n    </plugin>\n    \n\n`SceneBroadcaster` shows our world scene.\n\n## GUI#\n\nNow let\u2019s define the GUI. Under the `<gui>` tag we specify anything related to\nthe `GUI` of Gazebo.\n\n    \n    \n    <gui fullscreen=\"0\">\n        ...\n        ...\n    </gui>\n    \n\ngazebo-gui has a bunch of plugins to choose from. We will add the ones that\nare necessary to get our world up and running with basic functionality.\n\n    \n    \n    <!-- 3D scene -->\n    <plugin filename=\"MinimalScene\" name=\"3D View\">\n      <gz-gui>\n        <title>3D View</title>\n        <property type=\"bool\" key=\"showTitleBar\">false</property>\n        <property type=\"string\" key=\"state\">docked</property>\n      </gz-gui>\n    \n      <engine>ogre2</engine>\n      <scene>scene</scene>\n      <ambient_light>0.4 0.4 0.4</ambient_light>\n      <background_color>0.8 0.8 0.8</background_color>\n      <camera_pose>-6 0 6 0 0.5 0</camera_pose>\n      <camera_clip>\n        <near>0.25</near>\n        <far>25000</far>\n      </camera_clip>\n    </plugin>\n    <plugin filename=\"GzSceneManager\" name=\"Scene Manager\">\n      <gz-gui>\n        <property key=\"resizable\" type=\"bool\">false</property>\n        <property key=\"width\" type=\"double\">5</property>\n        <property key=\"height\" type=\"double\">5</property>\n        <property key=\"state\" type=\"string\">floating</property>\n        <property key=\"showTitleBar\" type=\"bool\">false</property>\n      </gz-gui>\n    </plugin>\n    \n\n`MinimalScene` and `GzSceneManager` are responsible for displaying the 3D\nscene of our world. It has the following properties (most of the GUI plugins\nhave them):\n\n  * `showTitleBar` if true it will show the blue title bar over the plugin with the name mentioned in the `<title>` tag.\n\n  * `state` is the state of the plugin it can be docked in its place using `docked` or it can be `floating`.\n\nFor the rendering engine we can choose `ogre` or `ogre2`. The\n`<ambient_light>` and the `<background_color>` specify the ambient and the\nbackground color of the scene. `<camera_pose>` specifies the `X Y Z` position\nof the camera followed by its rotation in `Roll Pitch Yaw`.\n\n### World control plugin#\n\n    \n    \n    <!-- World control -->\n    <plugin filename=\"WorldControl\" name=\"World control\">\n        <gz-gui>\n            <title>World control</title>\n            <property type=\"bool\" key=\"showTitleBar\">false</property>\n            <property type=\"bool\" key=\"resizable\">false</property>\n            <property type=\"double\" key=\"height\">72</property>\n            <property type=\"double\" key=\"width\">121</property>\n            <property type=\"double\" key=\"z\">1</property>\n    \n            <property type=\"string\" key=\"state\">floating</property>\n            <anchors target=\"3D View\">\n            <line own=\"left\" target=\"left\"/>\n            <line own=\"bottom\" target=\"bottom\"/>\n            </anchors>\n        </gz-gui>\n    \n        <play_pause>true</play_pause>\n        <step>true</step>\n        <start_paused>true</start_paused>\n        <service>/world/world_demo/control</service>\n        <stats_topic>/world/world_demo/stats</stats_topic>\n    </plugin>\n    \n\nThe `World control` plugin is responsible for controlling the world. Some of\nits properties are the following:\n\n  * `<play_pause>` if `true` we will have the play-pause button on the bottom left corner.\n\n  * `<stats_topic>` tag specifies the topic at which the world stats like simulation time and real time are published on.\n\n  * `<start_paused>` if `true` the simulation will be paused at the start of Gazebo.\n\n### World stats plugin#\n\n    \n    \n    <!-- World statistics -->\n    <plugin filename=\"WorldStats\" name=\"World stats\">\n        <gz-gui>\n            <title>World stats</title>\n            <property type=\"bool\" key=\"showTitleBar\">false</property>\n            <property type=\"bool\" key=\"resizable\">false</property>\n            <property type=\"double\" key=\"height\">110</property>\n            <property type=\"double\" key=\"width\">290</property>\n            <property type=\"double\" key=\"z\">1</property>\n    \n            <property type=\"string\" key=\"state\">floating</property>\n            <anchors target=\"3D View\">\n            <line own=\"right\" target=\"right\"/>\n            <line own=\"bottom\" target=\"bottom\"/>\n            </anchors>\n        </gz-gui>\n    \n        <sim_time>true</sim_time>\n        <real_time>true</real_time>\n        <real_time_factor>true</real_time_factor>\n        <iterations>true</iterations>\n        <topic>/world/world_demo/stats</topic>\n    \n    </plugin>\n    \n\nThe `World stats` plugin is responsible for displaying the world statistics,\n`<sim_time>`, `<real_time>`, `<real_time_factor>` and `<iterations>`.\n\nWith these tags we can choose what values to display (expand the bottom right\ncorner to see these values). We can choose which `<topic>` these values will\nbe published on. Let\u2019s try to run the world and listen to that topic.\n\nRun the world:\n\n`gz sim world_demo.sdf`\n\nPress the play button and in another terminal listen to the messages:\n\n`gz topic -e -t /world/world_demo/stats`\n\nThe message should look like this:\n\n### Entity tree#\n\n    \n    \n    <!-- Entity tree -->\n    <plugin filename=\"EntityTree\" name=\"Entity tree\">\n    </plugin>\n    \n\nIn this plugin we can see all the entities of our world (everything in\nsimulation is considered an \u201centity\u201d). We can see the different models, sun\nand also their links, visuals and collisions.\n\nIt is blank because we didn\u2019t add anything to our world yet.\n\nThere are a bunch of useful gz-gui plugins like the `Transform control` plugin\nthat allows us to manipulate different components of our world, and translate\nand rotate the entities. Check out this tutorial explaining how to manipulate\nmodels.\n\nThe plugins can also be added from the GUI using the plugin drop-down menu in\nthe top right corner of Gazebo. Now that we are done with the GUI, let\u2019s add\ndifferent elements to our world. **Don\u2019t** forget to add the closing tag\n`</gui>`.\n\n## Light#\n\n    \n    \n    <light type=\"directional\" name=\"sun\">\n        <cast_shadows>true</cast_shadows>\n        <pose>0 0 10 0 0 0</pose>\n        <diffuse>0.8 0.8 0.8 1</diffuse>\n        <specular>0.2 0.2 0.2 1</specular>\n        <attenuation>\n            <range>1000</range>\n            <constant>0.9</constant>\n            <linear>0.01</linear>\n            <quadratic>0.001</quadratic>\n        </attenuation>\n        <direction>-0.5 0.1 -0.9</direction>\n    </light>\n    \n\n  * `<light>` specifies the light source in the world. The `<type>` of the light can be `point`, `directional` or `spot`.\n\n  * `<pose>` is the position (x,y,z) and orientation (roll, pitch, yaw) of the light element with respect to the frame mentioned in the `relative_to attribute`; in our case (`relative_to` attribute is ignored) it is relative to the world.\n\n  * `<cast_shadows>` when true the light will cast shadows. `<diffuse>` and `<specular>` are the diffuse and specular light color.\n\n  * `<attenuation>` specifies the light attenuation properties, which are:\n\n    * `<range>` is range of light.\n\n    * `<constant>` is the constant attenuation factor, `1` never attenuate and `0` complete attenuation.\n\n    * `<linear>` is the linear attenuation factor, `1` means attenuate evenly over the distance.\n\n    * `<quadratic>` is the quadratic attenuation factor. It adds curvature to the attenuation.\n\n    * `<direction>` is direction of the light, only applicable to spot and directional light.\n\n## Adding models#\n\nInstead of building our own models we can use already built ones. Gazebo Fuel\nhosts hundreds of models that can easily be added to an Gazebo world. Models\ncan be added as follows.\n\n### Spawning a model#\n\nFor adding various models from fuel to your world chekout this tutorial.\n\n### Include the model URI#\n\nAnother way of adding the model to your world is to use the model link. Visit\nthe Gazebo Fuel website. Choose the model you like and click on the `<>` icon\non the model description page. This will copy an SDF snippet to your\nclipboard, then paste it in your world right above the closing `</world>` tag,\nlike this:\n\n    \n    \n    <include>\n        <uri>\n        https://fuel.gazebosim.org/1.0/OpenRobotics/models/Coke\n        </uri>\n    </include>\n    \n\n### Download the model#\n\nThe previous methods download your model on run time. For saving the model\npermanently you can download the model from fuel, and then refer to it like\nthis:\n\n    \n    \n    <include>\n        <uri>\n        model://Coke\n        </uri>\n    </include>\n    \n\nWe need to set `GZ_SIM_RESOURCE_PATH` environment variable to the parent\nfolder of our model. For example, if our directory looks like this:\n\n    \n    \n    world_tutorial<br/>\n    \u251c\u2500\u2500 Coke <br/>\n    \u2514\u2500\u2500 world_demo.sdf\n    \n\nThen we have to set it to the `world_tutorial` directory, like this:\n\n`export GZ_SIM_RESOURCE_PATH=\"$HOME/world_tutorial\"`\n\nRun your world:\n\n`gz sim world_demo.sdf`\n\nYou should see the model in the origin of the world.\n\nYou can also set its coordinates using the `<pose>` tag. If you want to spawn\nmultiple instances of the same model you must give them different names with\nthe `<name>` tag.\n\n    \n    \n        <include>\n            <name>Coke0</name>\n            <pose>0 0 0 0 0 0</pose>\n            <uri>https://fuel.gazebosim.org/1.0/OpenRobotics/models/Coke</uri>\n        </include>\n        <include>\n            <name>Coke1</name>\n            <pose>0 0.1 0 0 0 0</pose>\n            <uri>https://fuel.gazebosim.org/1.0/OpenRobotics/models/Coke</uri>\n        </include>\n    \n\nNow that you have a custom world, the next tutorial will teach you how to add\nsensors to a robot to allow it to interact with the world around it.\n\n## Video walk-through#\n\nA video walk-through of this tutorial is available from our YouTube channel:\nGazebo tutorials: Creating worlds.\n\n__On this page\n\n  * Defining a world\n  * Physics\n  * Plugins\n  * GUI\n    * World control plugin\n    * World stats plugin\n    * Entity tree\n  * Light\n  * Adding models\n    * Spawning a model\n    * Include the model URI\n    * Download the model\n  * Video walk-through\n\n__Edit on GitHub\n\nCreated using Sphinx 8.1.3.  \n\nBrought to you by Open Robotics.\n\nExcept where otherwise noted, the gazebosim.org web pages are licensed under\nCreative Commons Attribution 3.0.\n\nBuilt with the PyData Sphinx Theme 0.16.0.\n\n",
                "language": "en"
            },
            "platform": "gazebosim.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://gazebosim.org/docs/all/sdf_worlds/"
        },
        {
            "id": "f7e068ea-407e-4e2e-89d6-359ce7c51dad",
            "content": {
                "Title": "Sensors \u2014 Gazebo ionic documentation",
                "Subtitle": null,
                "Content": "Skip to main content\n\n__Back to top __ `Ctrl`+`K`\n\n  * Features\n  * Showcase\n  * Docs\n  * Community\n  * More\n    * About\n    * Community\n    * Answers\n    * Blog\n    * Media\n\n__ Search `Ctrl`+`K`\n\n______\n\nAPP\n\n__ Search `Ctrl`+`K`\n\nDocs / Gazebo Ionic\n\nSupported Sep, 2024 to Sep, 2026\n\nRelease:\n\nChoose version\n\n  * Features\n  * Showcase\n  * Docs\n  * Community\n  * More\n    * About\n    * Community\n    * Answers\n    * Blog\n    * Media\n\n______\n\nAPP\n\n  * Get Started\n  * Install __\n    * Binary Ubuntu Install\n    * Binary macOS Install\n    * Binary Windows Install\n    * Ubuntu Source Install\n    * macOS Source Install\n    * Windows Source Install\n    * Troubleshooting\n  * Migration from Ignition\n  * Feature Comparison\n  * Tutorials __\n    * Building your own robot\n    * Moving the robot\n    * SDF worlds\n    * Sensors\n    * Actors\n    * Understanding the GUI\n    * Manipulating Models\n    * Model Insertion from Fuel\n    * Keyboard Shortcuts\n    * Spawn URDF\n    * ROS 2 integration overview\n    * Launch Gazebo from ROS 2\n    * Use ROS 2 to interact with Gazebo\n    * Use ROS 2 to spawn a Gazebo model\n    * ROS 2 interoperability\n    * ROS 2 integration template\n  * ROS/Gazebo Installation __\n    * ROS 2 Gazebo Vendor Packages\n  * Continuous Integration For Gazebo Packages\n  * Gazebo Classic Migration __\n    * Installing Gazebo11 side by side with new Gazebo\n    * Migration from ROS 2 Gazebo Classic\n  * Roadmap\n  * Release Features\n  * Releases\n  * Governance\n  * Development __\n    * Contributing\n    * Continuous Integration\n    * Release process __\n      * Debian/Ubuntu versioning in nightly and prerelease binaries\n    * Release Instructions\n  * Sim Architecture\n  * Fuel __\n    * Content Deletion Policy\n    * Contributing New Model\n    * Contributing New World\n    * Copyright\n    * Data and Privacy Policy\n    * What is Fair Use\n  * Library Reference __\n    * cmake\n    * common\n    * fuel_tools\n    * gui\n    * launch\n    * math\n    * msgs\n    * physics\n    * plugin\n    * rendering\n    * sensors\n    * sim\n    * tools\n    * transport\n    * utils\n    * sdformat\n\n  * __\n  * Gazebo Tutorials\n  * Sensors\n\n# Sensors#\n\n**Note:** This tutorial is a continuation from the Moving the robot tutorial.\n\nIn this tutorial we will learn how to add sensors to our robot and to other\nmodels in our world. We will use three different sensors: an IMU sensor, a\nContact sensor and a Lidar sensor. We will also learn how to launch multiple\ntasks with just one file using `gz launch`.\n\nYou can find the final world of this tutorial showing all these plugins in use\nhere. You may also find an extensive set of world examples with many possible\nsensors and actuation capabilities in `gz-sim/examples/worlds` for individual\nexamples. The full set of sensors can be found in the `gz-sensors` library. If\nusing ROS, you can see demo launches and bridging configuration for these\nexamples here.\n\n## Preliminaries#\n\nWhen adding a `plugin` to an SDF file which does not currently contain one,\nthe default plugins are not loaded. Before adding a sensor, make sure to add\nin a couple of logical defaults to your world so that it is possible to\ncontinue to use the GZ GUI:\n\n    \n    \n    <sdf version='1.9'>\n      <world name='demo'>\n        <plugin\n            filename=\"gz-sim-physics-system\"\n            name=\"gz::sim::systems::Physics\">\n        </plugin>\n        <plugin\n            filename=\"gz-sim-scene-broadcaster-system\"\n            name=\"gz::sim::systems::SceneBroadcaster\">\n        </plugin>\n    \n        <!-- ... -->\n    \n\n## IMU sensor#\n\nThe inertial measurement unit (IMU) outputs the `orientation` of our robot in\nquaternions, the `angular_velocity` in the three axes (X, Y, Z), and the\n`linear_acceleration` in the three axes. Let\u2019s use our moving_robot.sdf world\nand modify it. Create a new file `sensor_tutorial.sdf` and add the code from\n`moving_robot.sdf` to it. To define the `IMU` sensor add this code under the\n`<world>` tag:\n\n    \n    \n    <plugin filename=\"gz-sim-imu-system\"\n            name=\"gz::sim::systems::Imu\">\n    </plugin>\n    \n\nThis code defines the `IMU` sensor plugin to be used in our world. Now we can\nadd the `IMU` sensor to our robot as follows:\n\n    \n    \n    <sensor name=\"imu_sensor\" type=\"imu\">\n        <always_on>1</always_on>\n        <update_rate>1</update_rate>\n        <visualize>true</visualize>\n        <topic>imu</topic>\n    </sensor>\n    \n\nThe sensor is usually added to one of the links of our model; we added it\nunder the `chassis` link.\n\nLet\u2019s describe the tags:\n\n  * `<always_on>` if true the sensor will always be updated according to the update rate.\n\n  * `<update_rate>` the frequency at which the sensor data is generated.\n\n  * `<visualize>` if true the sensor is visualized in the GUI.\n\n  * `<topic>` name of the topic on which data is published.\n\n**Note:** Not all the tags are supported for all sensors yet.\n\n### Read data from IMU#\n\nTo read the data from the `IMU`, run the world in one terminal and press the\nplay button:\n\n`gz sim sensor_tutorial.sdf`\n\nIn another terminal, run:\n\n`gz topic -e -t /imu`\n\nThe last command listens to the messages sent over the `/imu` topic. The IMU\ndata are `orientation`, `angular_velocity` and `linear_acceleration` as\ndescribed above. It should look like this:\n\nMove your robot forward using the keyboard up key. To do so, don\u2019t forget to\nenable the Key Publisher Plugin. You should see the sensor values changing.\n\n## Contact sensor#\n\nLet\u2019s introduce a different type of sensor, the `contact` sensor. You can\nguess from the name that this sensor gives indication when it touches\n(contacts) something else. We will build an obstacle (wall) and add the\ncontact sensor to it. If the robot hits the obstacle it will stop, preventing\nthe robot from damaging itself. Let\u2019s first build the obstacle as follows:\n\n    \n    \n    <model name='wall'>\n        <static>true</static>\n        <pose>5 0 0 0 0 0</pose><!--pose relative to the world-->\n        <link name='box'>\n            <visual name='visual'>\n                <geometry>\n                    <box>\n                        <size>0.5 10.0 2.0</size>\n                    </box>\n                </geometry>\n                <!--let's add color to our link-->\n                <material>\n                    <ambient>0.0 0.0 1.0 1</ambient>\n                    <diffuse>0.0 0.0 1.0 1</diffuse>\n                    <specular>0.0 0.0 1.0 1</specular>\n                </material>\n            </visual>\n            <collision name='collision'>\n                <geometry>\n                    <box>\n                        <size>0.5 10.0 2.0</size>\n                    </box>\n                </geometry>\n            </collision>\n        </link>\n    </model>\n    \n\nIt is just a simple model with one link of box shape. You can check the Build\nyour own robot tutorial to learn how to build models.\n\nNow run the world and make sure that the wall appears in the simulation like\nthis:\n\nLet\u2019s add the contact sensor to the wall. As with the `IMU` sensor, we should\nfirst define the `Contact` sensor by adding the following code:\n\n    \n    \n    <plugin filename=\"gz-sim-contact-system\"\n            name=\"gz::sim::systems::Contact\">\n    </plugin>\n    \n\nNow we can add the `contact` sensor to the `box` link of the `wall` model:\n\n    \n    \n    <sensor name='sensor_contact' type='contact'>\n        <contact>\n            <collision>collision</collision>\n        </contact>\n    </sensor>\n    \n\nThe definition of the `<sensor>` is straight forward, we just define the\n`name` and the `type` of the sensor. And inside the `collision` we define the\nbox link collision name which is `collision`.\n\nWe need also to add the `TouchPlugin` under the `wall` model as follows:\n\n    \n    \n    <plugin filename=\"gz-sim-touchplugin-system\"\n            name=\"gz::sim::systems::TouchPlugin\">\n        <target>vehicle_blue</target>\n        <namespace>wall</namespace>\n        <time>0.001</time>\n        <enabled>true</enabled>\n    </plugin>\n    \n\nThe `TouchPlugin` will publish (send) a message when the `wall` has been\ntouched. The tags of the plugin are as follows:\n\n  * `<target>` which will be in contact with our wall, in our case `vehicle_blue`.\n\n  * `<namespace>` takes the namespace of our topic, so when our robot hits the wall it will send a message to `/wall/touched` topic.\n\nRun the world in one terminal:\n\n`gz sim sensor_tutorial.sdf`\n\nIn another terminal, listen to the `/wall/touched` topic:\n\n`gz topic -e -t /wall/touched`\n\nDrive your robot forward to the wall using the keyboard arrow keys. Make sure\nto start the simulation by hitting the play button, and enable the Key\nPublisher plugin as well by clicking on the plugins dropdown list (vertical\nellipsis), then selecting \u201cKey Publisher\u201d.\n\nWhen you hit the bump you should see a message `data: true` on the terminal\nwhere you ran the `gz topic -e -t /wall/touched`.\n\nNow we can use the `TriggeredPublisher` plugin to make our robot stop when\nhits the wall as follows:\n\n    \n    \n    <plugin filename=\"gz-sim-triggered-publisher-system\"\n            name=\"gz::sim::systems::TriggeredPublisher\">\n        <input type=\"gz.msgs.Boolean\" topic=\"/wall/touched\">\n            <match>data: true</match>\n        </input>\n        <output type=\"gz.msgs.Twist\" topic=\"/cmd_vel\">\n            linear: {x: 0.0}, angular: {z: 0.0}\n        </output>\n    </plugin>\n    \n\nAs explained in the Moving robot tutorial, we can publish an output depending\non a received input. So when we receive `data: true` on the `/wall/touched`\ntopic we publish `linear: {x: 0.0}, angular: {z: 0.0}` to make our robot stop.\n\n## Lidar sensor#\n\nWe don\u2019t want our robot to touch the wall at all because this may cause some\ndamage, so instead of the contact sensor we can use the Lidar. Lidar is an\nacronym for \u201clight detection and ranging\u201d. This sensor can help us detect\nobstacles around the robot. We will use it to measure the distance between our\nrobot and the wall.\n\nFirst let\u2019s create a frame to fix our lidar to. This should be added inside of\nthe `vehicle_blue` `<model>` tag, since the lidar frame is attached to the\nrobot\u2019s `chassis`:\n\n    \n    \n    <frame name=\"lidar_frame\" attached_to='chassis'>\n        <pose>0.8 0 0.5 0 0 0</pose>\n    </frame>\n    \n\nThen add this plugin under the `<world>` tag, to be able to use the `lidar`\nsensor:\n\n    \n    \n        <plugin\n          filename=\"gz-sim-sensors-system\"\n          name=\"gz::sim::systems::Sensors\">\n          <render_engine>ogre2</render_engine>\n        </plugin>\n    \n\nUnder the `chassis` link we can add the `lidar` sensor as follows:\n\n    \n    \n    <sensor name='gpu_lidar' type='gpu_lidar'>\"\n        <pose relative_to='lidar_frame'>0 0 0 0 0 0</pose>\n        <topic>lidar</topic>\n        <update_rate>10</update_rate>\n        <ray>\n            <scan>\n                <horizontal>\n                    <samples>640</samples>\n                    <resolution>1</resolution>\n                    <min_angle>-1.396263</min_angle>\n                    <max_angle>1.396263</max_angle>\n                </horizontal>\n                <vertical>\n                    <samples>1</samples>\n                    <resolution>0.01</resolution>\n                    <min_angle>0</min_angle>\n                    <max_angle>0</max_angle>\n                </vertical>\n            </scan>\n            <range>\n                <min>0.08</min>\n                <max>10.0</max>\n                <resolution>0.01</resolution>\n            </range>\n        </ray>\n        <always_on>1</always_on>\n        <visualize>true</visualize>\n    </sensor>\n    \n\n  * First we defined the `name` and `type` of our sensor, then we defined its `<pose>` relative to the `lidar_frame`.\n\n  * In the `<topic>` we define the topic on which the lidar data will be published.\n\n  * `<update_rate>` is the frequency at which the `lidar` data is generated, in our case `10 Hz` which is equal to `0.1 sec`.\n\n  * Under the `<horizontal>` and `<vertical>` tags we define the properties of the horizontal and vertical laser rays.\n\n  * `<samples>` is the number of simulated lidar rays to generate per complete laser sweep cycle.\n\n  * `<resolution>`: this number is multiplied by samples to determine the number range data points.\n\n  * The `<min_angle>` and `<max_angle>` are the angle range of the generated rays.\n\n  * Under the `<range>` we define range properties of each simulated ray\n\n    * `<min>` and `<max>` define the minimum and maximum distance for each lidar ray.\n\n    * The `<resolution>` tag here defines the linear resolution of each lidar ray.\n\n  * `<always_on>`: if true the sensor will always be updated according to the `<update_rate>`.\n\n  * `<visualize>`: if true the sensor is visualized in the GUI.\n\nNow run the world and press the play button in the bottom-left corner:\n\n`gz sim sensor_tutorial.sdf`\n\nLook at the lidar messages on the `/lidar` topic, specifically the `ranges`\ndata:\n\n`gz topic -e -t /lidar`\n\nThe lidar message has the following attributes:\n\n    \n    \n    message LaserScan\n    {\n      Header header              = 1;\n    \n      string frame               = 2;\n      Pose world_pose            = 3;\n      double angle_min           = 4;\n      double angle_max           = 5;\n      double angle_step          = 6;\n      double range_min           = 7;\n      double range_max           = 8;\n      uint32 count               = 9;\n      double vertical_angle_min  = 10;\n      double vertical_angle_max  = 11;\n      double vertical_angle_step = 12;\n      uint32 vertical_count      = 13;\n    \n      repeated double ranges              = 14;\n      repeated double intensities         = 15;\n    }\n    \n\n### Avoid the wall#\n\nNow as we have the lidar on our robot, we can use the `ranges` data and make\nour robot avoid hitting the wall. To do that, we\u2019ll write a short C++ program\nthat listens to the sensor data and sends velocity commands to the robot. This\nprogram is called a node. We will build a node that subscribes to the `/lidar`\ntopic and reads its data. Have a look at this tutorial to learn how to build a\n`publisher` and a `subscriber` node. You can download the finished node for\nthis demo from here.\n\n#### The lidar_node#\n\n    \n    \n    std::string topic_pub = \"/cmd_vel\";\n    gz::transport::Node node;\n    auto pub = node.Advertise<gz::msgs::Twist>(topic_pub);\n    \n\nWe declare a `node` which will publish to `cmd_vel` topic. Then advertise our\nnode.\n\n    \n    \n    void cb(const gz::msgs::LaserScan &_msg)\n    {\n      gz::msgs::Twist data;\n    \n      bool allMore = true;\n      for (int i = 0; i < _msg.ranges_size(); i++)\n      {\n        if (_msg.ranges(i) < 1.0)\n        {\n          allMore = false;\n          break;\n        }\n      }\n      if (allMore) //if all bigger than one\n      {\n        data.mutable_linear()->set_x(0.5);\n        data.mutable_angular()->set_z(0.0);\n      }\n      else\n      {\n        data.mutable_linear()->set_x(0.0);\n        data.mutable_angular()->set_z(0.5);\n      }\n      pub.Publish(data);\n    }\n    \n\nInside the callback function we check if the range of all rays are bigger than\n`1.0`. If so we publish a message to our car to move forward. Otherwise we\nmake the robot rotate.\n\n    \n    \n    int main(int argc, char **argv)\n    {\n        std::string topic_sub = \"/lidar\";\n        // Subscribe to a topic by registering a callback.\n        if (!node.Subscribe(topic_sub, cb))\n        {\n            std::cerr << \"Error subscribing to topic [\" << topic_sub << \"]\" << std::endl;\n            return -1;\n        }\n    \n        // Zzzzzz.\n        gz::transport::waitForShutdown();\n    \n        return 0;\n    }\n    \n\nInside the main we subscribe to the `lidar` topic, and wait until the node is\nshut down.\n\n#### Build the node#\n\nDownload the CMakeLists.txt, and in the same folder of `lidar_node` create\n`build/` directory:\n\n    \n    \n    mkdir build\n    cd build\n    \n\nRun cmake and build the code:\n\n    \n    \n    cmake ..\n    make lidar_node\n    \n\n##### Run the node#\n\nRun the node from terminal 1:\n\n    \n    \n    ./build/lidar_node\n    \n\nRun the world from terminal 2:\n\n    \n    \n    gz sim sensor_tutorial.sdf\n    \n\nNow you can see the robot move forward and as it approaches the wall it starts\nto turn left until it\u2019s clear and moves forward again (be sure to press the\nplay button in the bottom-left corner to make the robot start moving).\n\n## Gazebo launch#\n\nInstead of running two different tasks from two different terminals we can\nmake a launch file which will run the `sensor_world` and the `lidar_node` at\nthe same time. Open your text editor and add the following code.\n\n    \n    \n    <?xml version='1.0'?>\n    <gz version='1.0'>\n      <executable name='sensor-world'>\n        <command>gz sim sensor_tutorial.sdf</command>\n      </executable>\n    \n      <executable name='lidar_node'>\n        <command>./build/lidar_node</command>\n      </executable>\n    \n    </gz>\n    \n\nThe launch file is an XML file. We simply define what commands will run under\nthe `<executable>` tag. The first command is `gz sim sensor_tutorial.sdf`\nwhich launches the world. And the second command is `./build/lidar_node` which\nruns the `lidar_node`. Save the file as `sensor_launch.gzlaunch`, and then run\nit using the following command:\n\n    \n    \n    gz launch sensor_launch.gzlaunch\n    \n\nPress the play button to start the simulation. Hurray! Our robot is now moving\nand avoiding the wall.\n\nTo add even more complexity to your simulation, learn how to add actors to a\nworld in the next tutorial.\n\n## Video walk-through#\n\nA video walk-through of this tutorial is available from our YouTube channel:\nGazebo tutorials: Sensors\n\n__On this page\n\n  * Preliminaries\n  * IMU sensor\n    * Read data from IMU\n  * Contact sensor\n  * Lidar sensor\n    * Avoid the wall\n      * The lidar_node\n      * Build the node\n        * Run the node\n  * Gazebo launch\n  * Video walk-through\n\n__Edit on GitHub\n\nCreated using Sphinx 8.1.3.  \n\nBrought to you by Open Robotics.\n\nExcept where otherwise noted, the gazebosim.org web pages are licensed under\nCreative Commons Attribution 3.0.\n\nBuilt with the PyData Sphinx Theme 0.16.0.\n\n",
                "language": "en"
            },
            "platform": "gazebosim.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://gazebosim.org/docs/all/sensors/"
        },
        {
            "id": "ff810c0a-22fc-4b0e-867c-263ebd5cf199",
            "content": {
                "Title": "Actors \u2014 Gazebo ionic documentation",
                "Subtitle": null,
                "Content": "Skip to main content\n\n__Back to top __ `Ctrl`+`K`\n\n  * Features\n  * Showcase\n  * Docs\n  * Community\n  * More\n    * About\n    * Community\n    * Answers\n    * Blog\n    * Media\n\n__ Search `Ctrl`+`K`\n\n______\n\nAPP\n\n__ Search `Ctrl`+`K`\n\nDocs / Gazebo Ionic\n\nSupported Sep, 2024 to Sep, 2026\n\nRelease:\n\nChoose version\n\n  * Features\n  * Showcase\n  * Docs\n  * Community\n  * More\n    * About\n    * Community\n    * Answers\n    * Blog\n    * Media\n\n______\n\nAPP\n\n  * Get Started\n  * Install __\n    * Binary Ubuntu Install\n    * Binary macOS Install\n    * Binary Windows Install\n    * Ubuntu Source Install\n    * macOS Source Install\n    * Windows Source Install\n    * Troubleshooting\n  * Migration from Ignition\n  * Feature Comparison\n  * Tutorials __\n    * Building your own robot\n    * Moving the robot\n    * SDF worlds\n    * Sensors\n    * Actors\n    * Understanding the GUI\n    * Manipulating Models\n    * Model Insertion from Fuel\n    * Keyboard Shortcuts\n    * Spawn URDF\n    * ROS 2 integration overview\n    * Launch Gazebo from ROS 2\n    * Use ROS 2 to interact with Gazebo\n    * Use ROS 2 to spawn a Gazebo model\n    * ROS 2 interoperability\n    * ROS 2 integration template\n  * ROS/Gazebo Installation __\n    * ROS 2 Gazebo Vendor Packages\n  * Continuous Integration For Gazebo Packages\n  * Gazebo Classic Migration __\n    * Installing Gazebo11 side by side with new Gazebo\n    * Migration from ROS 2 Gazebo Classic\n  * Roadmap\n  * Release Features\n  * Releases\n  * Governance\n  * Development __\n    * Contributing\n    * Continuous Integration\n    * Release process __\n      * Debian/Ubuntu versioning in nightly and prerelease binaries\n    * Release Instructions\n  * Sim Architecture\n  * Fuel __\n    * Content Deletion Policy\n    * Contributing New Model\n    * Contributing New World\n    * Copyright\n    * Data and Privacy Policy\n    * What is Fair Use\n  * Library Reference __\n    * cmake\n    * common\n    * fuel_tools\n    * gui\n    * launch\n    * math\n    * msgs\n    * physics\n    * plugin\n    * rendering\n    * sensors\n    * sim\n    * tools\n    * transport\n    * utils\n    * sdformat\n\n  * __\n  * Gazebo Tutorials\n  * Actors\n\n# Actors#\n\nIn this tutorial we will learn how to add `actors` to our world and how to\ncreate a scripted animation. You can find the final world of this tutorial\nhere.\n\nAnimations are very useful if we want to have entities following a predefined\npath in simulation without being affected by the physics. This means that they\nwon\u2019t fall due to gravity or collide with other objects. They will however,\nhave a 3D visualization which can be seen by RGB cameras, and 3D meshes which\ncan be detected by GPU based sensors. The tutorial explains how to create\nopen-loop trajectories which don\u2019t interact with the rest of the simulation.\n\n## Actors#\n\nIn Gazebo Sim, an animated model is called an `actor`.\n\nThere are two types of animations which can be used separately or combined\ntogether:\n\n  * Skeleton animation, which is relative motion between links in one model:\n\n  * Trajectory animation, which carries all of the actor\u2019s links around the world as one group along a trajectory:\n\n  * Combined, to achieve a skeleton animation which moves in the world:\n\nActors have the following properties:\n\n  * No forces are applied on them, be it from gravity or contact or anything else\n\n  * Actors support skeleton animation imported from COLLADA (.dae) and BVH (.bvh) files.\n\n  * Actors can have trajectories scripted directly in SDF.\n\nYou can check out the full specification for the `<actor>` SDF element here.\n\n## Skeleton#\n\nGazebo Sim supports two different skeleton animation file formats: COLLADA\n(.dae) and Biovision Hierarchy (.bvh).\n\nOpen any world, empty.sdf world for example, and add an actor called\n`actor_walking` as follows:\n\n    \n    \n    <actor name=\"actor_walking\">\n        <skin>\n            <filename>https://fuel.gazebosim.org/1.0/Mingfei/models/actor/tip/files/meshes/walk.dae</filename>\n            <scale>1.0</scale>\n        </skin>\n        <animation name=\"walk\">\n            <filename>https://fuel.gazebosim.org/1.0/Mingfei/models/actor/tip/files/meshes/walk.dae</filename>\n            <interpolate_x>true</interpolate_x>\n        </animation>\n    </actor>\n    \n\n### Skin#\n\nIn the `<skin>` tag we just loaded a COLLADA file `walk.dae` which specifies\nhow our actor will look. When a COLLADA file is used within the `<skin>` tags\nits animation is loaded. The `<scale>` scales the skin\u2019s size.\n\n### Animation#\n\nIn the `<animation>` tag we specify how our actor will move using the\n`<filename>` tag. `<interpolate_x>` is used to interpolate the animation\nwithin waypoints while following trajectory. Setting it as true allows for a\nmore realistic and smooth animation. We can combine different skins with\ndifferent animations as long as they have compatible skeletons. Now run the\nworld and we should see our model moving.\n\n**Note** : You can find many actors and models on Gazebo Fuel.\n\n## Scripted trajectory#\n\nThis is the high level animation of actors, which consists of specifying a\nseries of poses to be reached at specific times. Gazebo Sim takes care of\ninterpolating the motion between them so the movement is fluid.\n\nAnimations that have displacement on the X axis, like `walk.dae`, will have\nthe skeleton animated while following a trajectory. But for animations that\ndon\u2019t, such as `talk_b.dae`, their skeletons won\u2019t move if there\u2019s a\ntrajectory.\n\nWe can make our actor follow the specified trajectory forever and start\nplaying as soon as the world is loaded as follows:\n\n    \n    \n        <script>\n            <loop>true</loop>\n            <delay_start>0.000000</delay_start>\n            <auto_start>true</auto_start>\n    \n\nThe script is defined between the `<actor>` `</actor>` tags.\n\nInside the `<script>` tag the following parameters are available:\n\n  * `loop`: Set this to true for the script to be repeated in a loop. For a fluid continuous motion, make sure the last waypoint matches the first one, as we will do.\n\n  * `delay_start`: This is the time in seconds to wait before starting the script. If running in a loop, this time will be waited before starting each cycle.\n\n  * `auto_start`: Set to true if the animation should start as soon as the simulation starts playing. It is useful to set this to false if the animation should start playing only when triggered by a plugin, for example.\n\nLet\u2019s define the trajectory as a sequence of waypoints:\n\n    \n    \n            <trajectory id=\"0\" type=\"walk\" tension=\"0.6\">\n                <waypoint>\n                    <time>0</time>\n                    <pose>0 0 1.0 0 0 0</pose>\n                </waypoint>\n                <waypoint>\n                    <time>2</time>\n                    <pose>2.0 0 1.0 0 0 0</pose>\n                </waypoint>\n                <waypoint>\n                    <time>2.5</time>\n                    <pose>2 0 1.0 0 0 1.57</pose>\n                </waypoint>\n                <waypoint>\n                    <time>4</time>\n                    <pose>2 2 1.0 0 0 1.57</pose>\n                </waypoint>\n                <waypoint>\n                    <time>4.5</time>\n                    <pose>2 2 1.0 0 0 3.142</pose>\n                </waypoint>\n                <waypoint>\n                    <time>6</time>\n                    <pose>0 2 1 0 0 3.142</pose>\n                </waypoint>\n                <waypoint>\n                    <time>6.5</time>\n                    <pose>0 2 1 0 0 -1.57</pose>\n                </waypoint>\n                <waypoint>\n                    <time>8</time>\n                    <pose>0 0 1.0 0 0 -1.57</pose>\n                </waypoint>\n                <waypoint>\n                    <time>8.5</time>\n                    <pose>0 0 1.0 0 0 0</pose>\n                </waypoint>\n            </trajectory>\n        </script>\n    \n\nWithin the `<trajectory>` tag we define a series of waypoints which our actor\nwill follow. The `<trajectory>` has three attributes: `id`, `type`, and\n`tension`. The `type` should have the same name as the value specified in\n`name` attribute of the `<animation>` tag. Therefore, in this case it is\nspecified as `walk`. The `tension` parameter is used to control how closely\nthe trajectory will stick to the given waypoints. The default `tension` value\nis zero, which equates to a Catmull-Rom spline, which may cause the animation\nto overshoot waypoints. A `tension` value of one will cause the animation to\nstick to the waypoints. The `tension` value should be in the range 0 to 1.\n\nUnder the `trajectory` tag we define the following:\n\n  * `waypoint`: There can be any number of waypoints in a trajectory. Each waypoint consists of a time and a pose:\n\n    * `time`: The time in seconds, counted from the beginning of the script, when the pose should be reached.\n\n    * `pose`: The pose which should be reached with respect to the initial actor pose.\n\nRun the world and we should see our actor moving in a square following the\nwaypoints.\n\n**Notes** :\n\n  * The order in which waypoints are defined is not important, they will follow the given times.\n\n  * The trajectory is smoothed as a whole. This means that you\u2019ll get a fluid motion, but the exact poses contained in the waypoints might not be reached.\n\nNow it\u2019s your turn! Try out different trajectory descriptions.\n\n## Video walk-through#\n\nA video walk-through of this tutorial is available from our YouTube channel:\nGazebo tutorials: Animated human actors\n\n__On this page\n\n  * Actors\n  * Skeleton\n    * Skin\n    * Animation\n  * Scripted trajectory\n  * Video walk-through\n\n__Edit on GitHub\n\nCreated using Sphinx 8.1.3.  \n\nBrought to you by Open Robotics.\n\nExcept where otherwise noted, the gazebosim.org web pages are licensed under\nCreative Commons Attribution 3.0.\n\nBuilt with the PyData Sphinx Theme 0.16.0.\n\n",
                "language": "en"
            },
            "platform": "gazebosim.org",
            "author_id": "fd6cf9fa-2e79-4249-889b-bcfee93cce43",
            "author_full_name": "ros ros",
            "link": "https://gazebosim.org/docs/all/actors/"
        }
    ]
}